// VLISP - Feb 06 - by Sylvain Huet
// Metal

proto main 0;;
proto setRunState 1;;
proto getRunState 0;;
proto evalTrame 1;;
proto endSleep 0;;

// XMPP ECHO DEBUG
fun Xw str = 
	Secholn str;;
fun Xx i = 
	Iecholn i;;

// ping echo debug
fun Pingw str = nil;; //Secholn str;;

// dns echo debug
fun Dnsw str = nil;; //Secholn str;;

// programs debug
fun Progw str = nil;; //Secholn strcatlist "[program] " :: str :: nil;;

// streaming debug
fun Streamw str = nil;; //Secholn strcatlist "[streaming] " :: str :: nil;;

// #define SIMU

// chose one
// #define PING
// #define XMPP
#define SERVERLESS

#define WEBSERVER
#define NOMINAL

// set doPing to something else than nil to activate ping
var doPing = nil ;;


#ifdef NOMINAL
#define AUDIOLIB;;
#define EARSLIB;;
#define INFOLIB;;
#define RECLIB;;
#endif

const HARDWARE=4;;

proto buttoncheckevent 0;;

//
// Etats generaux
var gItState = 0;;			// interactif
var gSleepState = 1;;		// sleeping
var gStreamingState = 0;;	// streaming
var gProcessingState = 0;; 	// processing a program
var gProcessingWaitState = 0;;  // executing a "wait" command in a program. when checking this var, check gProcessingState first, as it is not always reseted to 0
var gBusyState = 0;;		// busy (incoming message queue full)
var gItApp = nil;;			// the name of the interactive application
var gEarInited = 0;;		// si les oreilles ont été initialisées.
var gRegistrationError = 0;;// registration error during login

proto itNoteEarTouched 3;;
proto processIncomingTrame 3;;
proto dumpStatus 0;;

#include net_vars.mtl

const BYTECODE_REVISION_STR = "$Rev: 20120312 $";;
fun getBytecodeRevision =
	strsub BYTECODE_REVISION_STR 6 ((strlen BYTECODE_REVISION_STR) - 8);;


#include utils.mtl
#include leds.mtl


// ---------------- dns prototypes

proto addnewdns 2;;
proto dnslisttostr 0;;
proto dnslistfromdhcp 1;;

// ---------------- end dns prototypes


#include md5.mtl
#include b64.mtl
#include xmlparser.mtl

#include config.mtl

#ifdef SIMU
#include tcpudp_emu.mtl
#else
#include ip.mtl
#include arp.mtl
#include udp.mtl
#include tcp.mtl
#include udp.mtl
#include dhcp.mtl
#include net.mtl
#endif

#include dns.mtl

#include http.mtl

#include time.mtl

/**
	Les différents états de la boucle principale.
*/
type Run= configstartRun | configwaitRun _ | interactiveReqWaitRun _ | 
#ifdef PING
	pingstartRun | pingwaitRun _| stdWaitRun _ | pingRequestWaitRun _ |
#endif
	rscLoadNextRun | rscLoadWaitRun _ | chorCmdRun _ |streamCmdRun _ | waitCmdRun _ | cmdEvalOne _ | idleRun | sleepRun |
	recordRun |earResetWaitRun _| recordStartRun | xmppLoginRun | xmppReconnectRun _ ;;

var run;;

/**
	Returns a string representation of the run variable
*/
fun runToStr run =
	match run with
    ( configstartRun -> "configStartRun")
  | (configwaitRun _ -> "configWaitRun")
	| (interactiveReqWaitRun _ -> "interactiveReqWaitRun")
	| (rscLoadNextRun -> "rscLoadNextRun" )
	| (rscLoadWaitRun _ -> "rscLoadWaitRun" )
	| (chorCmdRun _ -> "chorCmdRun" )
	| (streamCmdRun _ -> "streamCmdRun" )
	| (waitCmdRun _ -> "waitCmdRun" )
	| (cmdEvalOne _ -> "cmdEvalOne" )
	| (idleRun -> "idleRun" )
	| (sleepRun -> "sleepRun" )
	| (recordRun -> "recordRun" )
	| (earResetWaitRun _ -> "earResetWaitRun" )
	| (recordStartRun -> "recordStartRun" )
	| (xmppLoginRun -> "xmppLoginRun" )
	| (xmppReconnectRun _ -> "xmppReconnectRun" )
;;

proto earInit 0;;

#ifdef XMPP
#include xmpp.mtl
#else
fun XmppSessionRequestResource newRes = 0 ;;
fun XmppSessionRun = 0 ;;
fun XmppSessionIdle = 0 ;;
fun XmppSessionSendButtonMsg btn withEvent eventValue = 0 ;;
fun XmppSessionSendEarMsg leftValue rightValue = 0 ;;
var senddata=0;;
var currentTrameID=0;;
#endif

#ifdef RECLIB
#include reclib.mtl
#endif

#ifdef AUDIOLIB
#include audiolib.mtl
#endif

#ifdef EARSLIB
#include ears.mtl
#endif

#ifdef INFOLIB
#include info.mtl
#endif

#include surprise.mtl
#include crontab.mtl

#include hooks.mtl

proto hookEars 2;;
proto hookRfid 1;;

proto hookClick 1;;
proto hookDblClick 1;;

// ancien format
fun infoUpdate data=
	Secho "infoUpdate OLD FORMAT:";
	let strlen data -> len in (
		// /14/80/0/0/0/0/0/0/0/0/0/0/0/0/0/0/14/13/0/
		Secho "len="; Iecho len; Secho ":";
		for i=0;i<len do (Iecho strget data i; Secho "/");
		
		// sources
		for i=0;i<(min 16 len) do set infosrc.i=strget data i;
		
		// messages
		set infomessages = 0;
		if (len > 16+3) && (strget data (16+3)) then set infomessages = 2
		else if (len > 16+2) && (strget data (16+2)) then set infomessages = 1;
		
		// taichi
		let 0 -> found in
		for i=0;(i<(min 16 len) && !found);i+2 do
		if ((strget data i) == 14) then (
			set infotaichi = strget data i+1;
			set found = 1
		);
		
		// process ears
		if len > 17 then
		let strget data 16 -> newleft in
		let strget data 17 -> newright in
		if (newleft != nil || newright != nil) && ((newleft!=extleft) || (newright!=extright)) then (
			set extleft=newleft;
			set extright=newright;
			if ((!gSleepState) && (!earResetting)) then (
				controlsound midi_communion;
				earsGoToRefPos
			)
		)

	);
	dumpinfo;
	
	0;;


//-------------------



#include wifi.mtl
#include env.mtl

#ifdef NOMINAL

const tab_osc={
	0 0 0 0 0 0 1 1 2 3 3 4 5 6 7 8 
	9 10 12 13 15 16 18 19 21 23 25 27 29 31 33 35 
	37 39 42 44 46 49 51 54 56 59 62 64 67 70 73 76 
	79 81 84 87 90 93 96 99 103 106 109 112 115 118 121 124
};;


fun osc x=
	let (x>>6)&3 -> q in
	let x&255 -> x in
	if q==0 then tab_osc.x
	else if q==1 then 255-tab_osc.(127-x)
	else if q==2 then 255-tab_osc.(x-128)
	else tab_osc.(255-x);;


var pingsrv;;
var broadcasturl;;
var recorddelay=4;;

var sources;;

var gCurrentProgram;; // the list of commands of the current program
var rsctoget;; // list of remaining resources to get for the execution of the current trame
var rscloaded;; // list of resources loaded from current trame
var rsctmp;;	// buffer de chargement des ressources en petits morceaux

// settings, command="IC", managed in eval_IC_msg
var g_streaming_chor_enabled=1;;
var g_cookie="";;
const MASK_BUTTON = 1;;
const MASK_EAR_LEFT = 2;;
const MASK_EAR_RIGHT = 4;;
const MASK_RFID = 8;;
var g_int_mask=0;;
var g_snd_btn_1 = "clonk";;
var g_snd_btn_2 = "chord";;
var g_record_enabled = 1;;
proto reset_IC 0;;

proto _interactiveReqCBhttp 2;;
proto interactivePrgmDone 0;;
proto interactiveSendUpload 0;;
proto interactiveStop 0;;
proto interactiveError 0;;
proto interactiveResetEarsTouched 0;;

var gCurAudioCmdIndex=-1;;
var gCurStreamName=nil;;

const BROADCAST_KEYWORD="broadcast";;
const SIGNCUTSIZE=40000;; // taille max du fichier audio de signature

const MSG_IDLE=0x7fffffff;;
const MSG_ASLEEP=0x7ffffffe;;

const STREAMING_PING=60;;
const STD_NET_TIMEOUT=10000;;

const LED_TIMEOUT=600;; // 10 minutes
const CH_frame_duration=1;;
//var CH_set_color=6;;
const CH_set_led_color=7;;
const CH_set_motor=8;;
const CH_set_leds_color=9;; // v16
const CH_set_led_off=10;; // v17
const CH_set_led_palette=14;;
//var CH_set_palette=15;;
const CH_randmidi=16;;
const CH_avance=17;;
const CH_ifne=18;;
const CH_attend=19;;
const CH_setmotordir=20;; // v16


#include palette.mtl
#include const_data.mtl

var midilist;;

fun getmidilist=
	if midilist==nil then set midilist=
	{midi_1noteA4 midi_1noteB5 midi_1noteBb4 midi_1noteC5 midi_1noteE4 midi_1noteF4
	 midi_1noteF5 midi_1noteG5 midi_2notesC6C4 midi_2notesC6F5 midi_2notesD4A5
	 midi_2notesD4G4 midi_2notesD5G4 midi_2notesE5A5 midi_2notesE5C6 midi_2notesE5E4
	 midi_3notesA4G5G5 midi_3notesB5A5F5 midi_3notesB5D5C6 midi_3notesD4E4G4 midi_3notesE5A5C6
	 midi_3notesE5C6D5 midi_3notesE5D5A5 midi_3notesF5C6G5};
	midilist;;

fun controlsound s=
	wavstartlocal s::nil;
	0;;

#include button.mtl

// Pour le dÃ©veloppement, dÃ©commenter une des lignes ci-dessous.
// fun confGetServerUrl = "r.nabaztag.com/vl";;
// fun confGetServerUrl = "nabdev.violet.net/vl";; // debug
// fun confGetServerUrl = "192.168.1.11/vl";;

// fun confGetServerUrl = "objects-pp.nabaztag.com/vl";;

// URLs normales
fun configurl=strcatlist confGetServerUrl::"/locate.jsp?sn="::(webmac netMac)::"&h="::(itoa HARDWARE)::"&v="::(getBytecodeRevision)::nil;;
#ifdef PING
fun pingurl =strcatlist pingsrv::"/vl/p4.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&st=1&sd="::(itoh senddata)::"&h="::(itoa HARDWARE)::nil;;
#endif
//fun recordurl mode=strcatlist pingsrv::"/vl/record.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&m="::(itoa mode)::nil;;
fun recordurl mode=strcatlist "http://"::confGetServerUrl::"/hooks/record.php"::nil;;
fun rfidurl tag=strcatlist pingsrv::"/vl/rfid.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&t="::(webmac tag)::nil;;
fun interactifurl application = strcatlist pingsrv::"/vl/itmode.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&a="::application::nil;;
#ifdef XMPP
fun sendmailxmppurl xmppdomain data = strcatlist pingsrv::"/vl/sendMailXMPP.jsp?m="::(webmac netMac)::"&d="::xmppdomain::"&r="::data::"&v="::(getBytecodeRevision)::nil;;
fun boshurl ip = strcatlist ip::"/http-bind"::nil;; 
//fun boshurl ip = strcatlist ip::":5281/http-bind"::nil;;  // DEBUG
#endif

// Construction des urls d'interactivité
fun interactifurl_start application= strcatlist (interactifurl application)::"&st=start"::g_cookie::nil;;
fun interactifurl_btn application position cmdindex btn= strcatlist (interactifurl application)::"&st=btn&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&btn="::(itoa btn)::g_cookie::nil;;
fun interactifurl_done application = strcatlist (interactifurl application)::"&st=done"::g_cookie::nil;;
fun interactifurl_ear application position cmdindex earg eard = strcatlist (interactifurl application)::"&st=ear&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&el="::(itoa earg)::"&er="::(itoa eard)::g_cookie::nil;;
fun interactifurl_reco application position cmdindex = strcatlist (interactifurl application)::"&st=reco&pos="::(itoa position)::"&idx="::(itoa cmdindex)::g_cookie::nil;;
fun interactifurl_rfid application tag = strcatlist (interactifurl application)::"&st=rfid&t="::(webmac tag)::g_cookie::nil;;

#ifdef PING
#include ping.mtl
#endif

#ifdef WEBSERVER
#include lang.mtl
#include http_server.mtl
#endif

fun runinit=
	set run=configstartRun;;


fun filterconfig_word s=
	let strstr s " " 0 -> i in
	if i!=nil then [strsub s 0 i strsub s i+1 nil]
	else [s nil];;

fun filterconfig_line s i=
	let strstr s "\10" i-> j in
	if j!=nil then (filterconfig_word strsub s i j-i)::filterconfig_line s j+1
	else if i<strlen s then (filterconfig_word strsub s i nil)::nil;;

fun filterconfig s i0=
	let strreplace s "\13" "" -> s in
	filterconfig_line s i0
;;

fun dump_prgm l=
	Progw "Program:";
	for l=l;l!=nil;tl l do let hd l->[key val] in (
		Progw strcatlist ( key :: " " :: (if (val != nil) then val else "") :: nil)
	);
	Secholn "---";
	l;;

		
fun _configcbhttp http res=
	if (nil != res) then
	(
		Secholn "config=";
		let filterconfig Secholn httpgetcontent res 0-> conf in
		(
			// http urls
			set pingsrv=listswitchstr conf "ping";
			set broadcasturl=listswitchstr conf "broad";

#ifdef PING
			endSleep;
			if pingsrv!=nil && broadcasturl!=nil then set run=pingstartRun;
#endif
#ifdef XMPP
		/****** XMPP ****/
			let listswitchstr conf "xmpp_domain" -> xmpp_domain in
				if xmpp_domain != nil then
					XmppSessionStart xmpp_domain 1; // START 1 XMPP SESSION HERE (1 == Display Leds for connexion Details)

			set run = xmppLoginRun;
#endif
#ifdef SERVERLESS
//			let listswitchstr conf "xmpp_domain" -> xmpp_domain in
//				if xmpp_domain != nil then				
			endSleep;
#endif
			0
		)
	)
	else
	(
		// l'appel à locate.jsp a échoué -> ... rebooter tout ?
		Secholn "call to locate.jsp failed, rebooting";
		///////// reboot 0x0407FE58 0x13fb6754;
		0
	)
;;

var gConfigStart = 0;;
fun runconfigstart=
	if netState==RT2501_S_CONNECTED && wavrunning==0 then (
		set gConfigStart = time_ms;
		leds_set_state LEDS_STATE_CONFIG_WAIT ;
#ifdef SERVERLESS
		get_time_from_timeserver;
		endSleep
#else
		set run=configwaitRun httprequest "GET" Secholn configurl nil #_configcbhttp HTTP_NORMAL
#endif
	);
	0;;

fun runconfigwait http=
	// check timeout and retry : cligne + ou - la led middle body toutes les secondes en bleu
	if ((httpinactive http) > STD_NET_TIMEOUT) then
	(
		Secholn "##timeout on configwait";
		httpabort http;
		set run=configstartRun
	);

	0;;

// Cryptage des trames
fun bintoi3 s x=((strget s x)<<16)+((strget s x+1)<<8)+(strget s x+2);;


/** aide pour la fonction pingextract juste en dessous */
fun pingextract_ s i res=
	if i<strlen s then
	let (strget s i)-> code in
	if code==255 then res
	else if code>=0 && code<=11 then
		let bintoi3 s i+1 -> len in
		if len>=0 then pingextract_ s i+4+len [code strsub s i+4 len]::res;;

/** parse la chaine s et renvoie une liste des commandes contenues dedans */
fun pingextract s=
	if (strget s 0)==0x7f then pingextract_ s 1 nil;;

// replace the prefix string "broadcast" (if present) by broadcasturl
fun rscfilterurl url=
	if 0==strstr url BROADCAST_KEYWORD 0 then strcat broadcasturl strsub url strlen BROADCAST_KEYWORD nil
	else url;;

fun rscFromProgram l=
	if l!=nil then let hd l->[key val] in
	if (!strcmp key "MU") || (!strcmp key "CH") then [val /*nil*/300000]::rscFromProgram tl l
	else if (!strcmp key "MC") then [val SIGNCUTSIZE]::rscFromProgram tl l
	else rscFromProgram tl l;;
	


var paletteselected = 0;;
// v17 (add romain)
// Fonction permettant d'activer la palette pour le programme en cours
// au jour du 31 mai 2007, on recoit le PL apres le son a jouer, la palette associee au son est donc affichee juste apres la fin du programme
// Cette fonction passe prealablement sur le programme reçu pour mettre la bonne palette
// A noter, si il y a plusieurs palettes dans la trame de retour, seule la premiere est prise en compte
fun CheckForPaletteBefore l=
	for l=l;l!=nil;tl l do let hd l->[key val] in
	(
		if (!strcmp key "PL") && (paletteselected==0) then
		(
			set_current_palette_mode atoi val;
			set paletteselected = 1
		)
	);;

fun prgmStart=
	// Starts playing the program
	// setleds RGB_RED;
	
	// Si la palette est definie pour ce programme, alors on ne met pas l'aleatoire
	if(paletteselected==0) then (
		set current_palette=tabnew 0 8; // v17 : c'était inversé
		set_current_palette_mode 8 // random palette par défaut
	);
	// start evaluating first command
	set gCurAudioCmdIndex = -1;
	set run=cmdEvalOne 0;
	0;;


// ********** loading resources

// callback from rscLoadWaitRun : a resource has been loaded
fun _rscLoadCBhttp http res maxsize=
	if recording then
	(
		httpabort http;
		nil
	)
	else if res!=nil then
	(
		// received a result, store it in rsctmp
		// Je ne comprends pas la logique ici (AS sept07) : a quoi sert rsctmp et maxsize, et comment passe-t-il à la suite ?
//		Secholn res;
		set rsctmp=res::rsctmp;
		if maxsize!=nil && (slistlen rsctmp)>maxsize then
		(
			// too big ? (?)
			httpabort http;
			_rscLoadCBhttp http nil nil
		);
		0
	)
	else
	(
		let hd rsctoget ->[url _] in
		// remember rsc loaded
		set rscloaded=[url tl rev rsctmp nil]::rscloaded;
		
		// load next rsc
		set rsctoget=tl rsctoget;
		set run=rscLoadNextRun;
		0
	);;

// Recursive : loads all needed resources of the list 'rsctoget' and then starts current program
fun runRscLoadNext=
	let hd rsctoget -> [url maxsize] in
	if url==nil then
	(
		// nothing (else) to load : start execute msgs now
		Secholn "rsrcs loaded, starting prgm";
		prgmStart;
		0
	)
	else if nil!=listswitchstr rscloaded url then
	(
		// already loaded : load next
		set rsctoget=tl rsctoget;
		runRscLoadNext
	)
	else
	(
		// load resource
		set rsctmp=nil;
		Secho "loading ";
		set run=rscLoadWaitRun httprequest "GET" Secholn (rscfilterurl url) nil (fixarg3 #_rscLoadCBhttp maxsize) HTTP_STREAM;
		0
	);;

fun runRscLoadWait http=
	// wait for loading resource
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout in runRscLoadWait";
		httpabort http;
		// skip, load next
		set rsctoget=tl rsctoget;
		set run=rscLoadNextRun
	);
	0;;


/**
	Called when a program has to end.
	If doNotNotify is set (!=0) then the server is not notified of the end of the program
*/
fun endOfProgram doNotNotify =
	Secholn "endOfProgram";
	set gProcessingState = 0;
	set gProcessingWaitState = 0; // just in case
	set gCurrentProgram = nil;
	if (gItState && !doNotNotify) then (
		// notifier fini
		interactivePrgmDone
	) else (
		// retour normal
		set run = idleRun;
		0
	);
	0;;

var recordtimestart;;
var recordmode;;
var recorddata;;
var recordreq;;
var recordretry;;
var recordplayend;;

fun uploading = recordreq!=nil;;

fun runrecordstart=
	// wait for the end of the starting sound
	if !wavrunning then
	(
	led LED_NOSE RGB_RED;//if time_ms&64 then RGB_RED else 0;
//		setleds RGB_BLACK;
		unforcevol;
		recstart;
		set recordtimestart=time_ms;
		set run=recordRun
	);;

fun _controlrecord mode=
	setleds RGB_BLACK;
	wavstop;
	motorset 0 0;
	motorset 1 0;
	forcevol 64;
	wavstartlocalEx mp3_startrecord::nil 100;
	set recordmode=mode;
	set run=recordStartRun;
	0;;

fun _cbrecordhttp http res=
	// record upload done
	set recorddata=nil;
	set recordreq=nil;
	Secholn res;
	setleds RGB_BLACK;
	if recordplayend!=nil then
	(
		set recordplayend=nil;
		wavstartlocal midi_endrecord::nil
	);
	set run=idleRun;
	0;;

fun uploadtimeout=
	if uploading then
	(
		if recordplayend!=nil && ((recordplayend-time_ms)<0) then
		(
			set recordplayend=nil;
			wavstartlocal midi_endrecord::nil
		);
		if (httpinactive recordreq)>STD_NET_TIMEOUT then
		(
			Secholn "##timeout on upload";
			httpabort recordreq;
			set recordreq=nil;
			if recordretry>0 then
			(
				// retry
				set recordretry=recordretry-1;
				if (!gItState) then (
					set recordreq=httprequest "POST" Secholn recordurl recordmode recorddata #_cbrecordhttp HTTP_NORMAL;0
				) else (
					interactiveSendUpload
				);
				nil
			)
			else
			(
				// abort
				set recorddata=nil;
				if (!gItState) then (
					set run=idleRun;0
				) else (
					interactiveError
				)
			)
		)
	);;

const AskR = 0;; // v18
const RecordingTime = 8000;; // v18

fun runrecord=
//	led LED_NOSE if time_ms&1024 then RGB_RED else RGB_BLACK;
	if !button2 || ((time_ms-recordtimestart)>8000)then
	(
		recstop;
		setleds RGB_BLACK;
		let recriff -> wavfile in
		(
			set recorddata=strcatlist wavfile;
			set recordretry=3;
			set recordplayend=time_ms+400;
			if (!gItState) then (
				set recordreq=httprequest "POST" Secholn recordurl recordmode recorddata #_cbrecordhttp HTTP_NORMAL;
				set run=idleRun;0
			) else (
				interactiveSendUpload
			)
		)
	);;

// ************************* Choregraphies (TaiChi, .chor) ************
var chordata;;
var chorindex;;
var chortimescale;;
var chornexttime;;
var chorrandom;;
var chortaichimotordir;; // le moteur // v16
var chorendcb=nil;; // the callback to call in the end of the chor
var chor_paused_dur;; // can be paused during buffering
var chor_paused;;
var chor_paused_since;;

fun msgchorstart chor cb i0=
	set chorendcb = cb;
	set chordata=strcatlist chor;
	set chorindex=4+1;	// on saute le header et la première attente
	set chortimescale=0;
	set chornexttime=time_ms;
	set chor_paused_dur = 0;
	set chor_paused_since = nil;
	set chor_paused= 0;
	setleds RGB_BLACK; // shut off all leds at start (or should it be in the chor ?)
	set run=chorCmdRun i0;
	0;;

fun msgendchor i0=
	set chornexttime=nil;
	// call the callback
	if (chorendcb != nil) then call chorendcb [i0];
	0;;

fun runChorCmd i0=
	//	Secho "runChorCmd i:";Iecho chorindex; Secho " t:";Iecholn chornexttime;
	// Manage buffering and pauses
	
	if (!chor_paused && wav_buffering) then (
		// start pause
		set chor_paused_since = time_ms;
		set chor_paused = 1
	) else if (chor_paused && !wav_buffering) then (
		// end pause
		set chor_paused = 0;
		// increment paused_dur
		set chor_paused_dur = chor_paused_dur + (time_ms - chor_paused_since)
	);
	
	if (!chor_paused) then
	if time_ms-chor_paused_dur >= chornexttime then
	(
		if chorindex>=strlen chordata then msgendchor i0
		else let strget chordata chorindex -> code in
		set chorindex=chorindex+2+
		if code==CH_frame_duration then
		(
			set chortimescale=10*strget chordata chorindex+1;
			1	//nb de paramètres
		)
		else if code==CH_set_motor then
		(
			earGo (strget chordata chorindex+1) (strget chordata chorindex+2) (strget chordata chorindex+3);
			3
		)
		else if code==CH_set_led_color then
		(
//			Secho "set_led_color ";
			//led 4-strget chordata chorindex+1 ((strget chordata chorindex+2)<<16)+((strget chordata chorindex+3)<<8)+(strget chordata chorindex+4); // v16 start
			let 4-strget chordata chorindex+1 -> iled in
			let strget chordata chorindex+2 -> ired in
			let strget chordata chorindex+3 -> igreen in
			let strget chordata chorindex+4 -> iblue in
			(
				//Iecho iled; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
				led iled (ired<<16)+(igreen<<8)+iblue
			); // v16 end
			6
		)
		else if code==CH_set_leds_color then // v16 start
		(
			//Secho "set_leds_color ";
			let strget chordata chorindex+1 -> ired in
			let strget chordata chorindex+2 -> igreen in
			let strget chordata chorindex+3 -> iblue in
			let (ired<<16)+(igreen<<8)+iblue -> col in
			(
				//Secho "leds "; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
				setleds col
			);
			3
		) // v16 end
		else if code==CH_set_led_palette then
		(
//			Secholn "set_led_palette ";
			led 4-strget chordata chorindex+1 current_palette.(7&strget chordata chorindex+2);
			2
		)
		// v17
		else if code== CH_set_led_off then 
		(
			//Secholn "CH_set_led_off ";
			led 4-strget chordata chorindex+1 0;
			1
		)
		else if code==CH_randmidi then
		(
			//Secholn "randmidi";
			let getmidilist -> t in
			let tablen t -> n in
			if n>0 then
			let ((rand&255)*n)>>8 -> imusic in // v16 start
			let t.(imusic) -> music in
			(
				Secho "randmidi="; Iecholn imusic;
				wavstartlocal music::nil
			); // v16 end
			0
		)
		else if code==CH_avance then
		(
			//Secholn "avance";
			let (strget chordata chorindex+1) -> motor in // v16 start
			let (strget chordata chorindex+2) -> delta in
			let chortaichimotordir.motor -> dir in
			earGo motor (earTarget motor)+if dir then -delta else delta dir;
			2
		)
		else if code==CH_setmotordir then
		(
			//Secholn "setmotordir";
			let (strget chordata chorindex+1) -> motor in
			let (strget chordata chorindex+2) -> dir in
			set chortaichimotordir=
			if  motor == 0 then {dir chortaichimotordir.1} else {chortaichimotordir.0 dir}; // v16 end
			2
		)
		else if code==CH_ifne then
		(
			//Secho "ifne ";Iecholn chorrandom;
			if chorrandom==(Iecholn strget chordata chorindex+1) then 3
			else 3+((strget chordata chorindex+2)<<8)+(strget chordata chorindex+3)
		)
		else if code==CH_attend then
		(
			//Secholn "attend";
			if earFinishedMoving && wavrunning==0 then 0
			else -2
		)
		else
		(
			msgendchor i0;
			0
		);
		if chornexttime!=nil then
		(
			set chornexttime=chornexttime+(strget chordata chorindex-1)*chortimescale;
			runChorCmd i0
		)
	);;

fun _cbtaichiend unused=
	set gProcessingState = 0;
	earSetWaitAndDetectMode;
	set run=idleRun;
	0
	;;
	
fun taichistart=
	Secho "taichistart ";
	
	set chorrandom=((Iecholn rand&255)*30)>>8;
	Secho "chorrandom="; Iecholn chorrandom;
	set chortaichimotordir={0 0};

	earSetWaitOnlyMode;
	set gProcessingState = 1; // block all trames during taichi
	msgchorstart chordef_taichi::nil #_cbtaichiend nil;
	0;;


// **********************
// Interactivity
// **********************

var gInteractiveLastWavBytes = 0;;
type gInteractiveSoundsType = intDefaultStart | intDefaultStop | intNone;;
type gInteractiveChorType = intchorDefaultStart | intchorDefaultStop | intchorStartNone | intchorStopNone;;
var gInteractiveSounds;;
var gInteractiveChors;;

// quand on a reçu une commande "WT", on stocke ici la date jusqu'à laquelle on doit attendre
var interactiveWaitEndTime_ms = 0;;

proto _cbContinueStartInteractive 1;;
proto _cbContinueStopInteractive 1;;
proto _cbContinueErrorInteractive 1;;

// Play a start or stop sound
fun gIntControlSound Type =
	match Type with
	(intDefaultStart ->		controlsound midi_startInteractive )	// On joue le son par defaut
	| (intDefaultStop ->	controlsound midi_endInteractive )		// On joue le son par defaut
	| (intNone -> 			nil)									// On ne joue pas de son
	| (_ -> Secholn "No Sound to Play!!"; nil );					// Si on a indique un mauvais son, on ne joue rien
	0
;;

// Play a start or stop chor
fun gIntControlChor Type =
	match Type with
	(intchorDefaultStart ->		msgchorstart chordef_startInteractive::nil #_cbContinueStartInteractive nil )		// On joue le chor par defaut
	| (intchorDefaultStop ->	msgchorstart chordef_startInteractive::nil #_cbContinueStopInteractive nil )		// On joue le chor par defaut
	| (intchorStartNone -> 		_cbContinueStartInteractive nil )													// On ne joue pas de chor
	| (intchorStopNone ->		_cbContinueStopInteractive nil )													// On ne joue pas de chor
	| (_ -> Secholn "No Chor to Play!!"; nil );					// Si on a indique un mauvais chor, on ne joue rien
	0
;;

// Starts interactivity : sets run mode, remember application and request commands
fun interactiveStart application=

	set gItState = 1;
	set gItApp = application;
	if !gBusyState then XmppSessionRequestResource "itmode";

	reset_IC;
		
	// oreilles vers l'avant
	(earGo 0 3 0; earGo 1 3 0);
	
	// jingle
	let gInteractiveSounds -> [gSoundStart gSoundStop] in
		gIntControlSound gSoundStart;
	
	// chor de debut
	let gInteractiveChors -> [gChorStart gChorStop] in
		gIntControlChor gChorStart;

	0;;

fun _cbContinueStartInteractive unused=
	
	// ask for instructions
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_start gItApp) nil #_interactiveReqCBhttp HTTP_NORMAL);
		
	0;;

fun interactiveError=
	// jingle error
	Secho "interactiveError";
	msgchorstart chordef_interactiveerror::nil #_cbContinueErrorInteractive nil;
	0;;

fun _cbContinueErrorInteractive unused=
	interactiveStop;
	0;;
	
fun interactiveStop=
	Secholn "interactiveStop";
	
	// jingle de fin
	let gInteractiveSounds -> [gSoundStart gSoundStop] in
		gIntControlSound gSoundStop;
	set gInteractiveSounds = [intDefaultStart intDefaultStop]; // on remet le son par default a la fin
	
	// chor de fin
	let gInteractiveChors -> [gChorStart gChorStop] in
		gIntControlChor gChorStop;
	set gInteractiveChors = [intchorDefaultStart intchorDefaultStop]; // on remet le chor par default a la fin
	
	// oreilles
	earsGoToRefPos;

	// clean
	set g_cookie="";
	0;;

fun _cbContinueStopInteractive unused=
	// finalise stopping itMode
	set gItApp = nil;
	set gItState = 0;
	set gProcessingState = 0; // skips all remaining commands anyway, so : not processing
	//if !gBusyState then XmppSessionRequestResource "idle"; // can only be idle now 
	// DEBUG
	XmppSessionRequestResource "idle"; // Obligation de revenir en IDLE
	set gStreamingState = 0; // On ne stream plus rien!
	set run = idleRun;
	0;;

fun interactiveSendBtn btn=
	Xw "Inside interactiveSendBtn";
	wavstop;
	earStop 0;
	let wav_curplayedbytes -> readBytes in ( // controlsound resets wav_curplayedbytes so we cache it
		// sound
		if (btn == BUTTON_CLIC) then (
			if (!strcmp g_snd_btn_1 "clonk") then controlsound midi_abort
			else if (!strcmp g_snd_btn_1"chord") then controlsound midi_ack
			else if (!strcmp g_snd_btn_1 "neutral") then controlsound midi_ministop;
			0
		) else if (btn == BUTTON_DCLIC) then (
			if (!strcmp g_snd_btn_2 "clonk") then controlsound midi_abort
			else if (!strcmp g_snd_btn_2 "chord") then controlsound midi_ack
			else if (!strcmp g_snd_btn_2 "neutral") then controlsound midi_ministop;
			0
		);
		// request instructions
		set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_btn gItApp readBytes gCurAudioCmdIndex btn) nil #_interactiveReqCBhttp HTTP_NORMAL)
	);
	0;;

fun interactivePrgmDone=
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_done gItApp) nil #_interactiveReqCBhttp HTTP_NORMAL);
	0;;

/**
	Calls the server to tell a rfid tag has been seen
*/
fun interactiveSendRfid tag =
	wavstop;
	earStop 0;
	set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_rfid gItApp tag) nil #_interactiveReqCBhttp HTTP_NORMAL);
	0;;

//*******************
// Ears turned
//*******************
type EarTouch=[num_ET refPos_ET moveDir_ET lastDV_ET lastMoveTime_ET turned_ET];;
var earsTouch;;
const EAR_TOUCH_TIMEOUT=1000;;

fun interactiveResetEarsTouched=
	set earsTouch=tabnew nil 2;
	for i=0;i<2 do set earsTouch.i=[num_ET:i];
	for i=0;i<2 do let earsTouch.i -> et in
	(
		set et.refPos_ET = -1;
		set et.moveDir_ET = -1;
		set et.lastDV_ET = -1;
		set et.lastMoveTime_ET = -1;
		set et.turned_ET = 0
	);
	0;;

fun earDeltaPosNormalized deltaPos=
	// between -EARS_HOLES>>1 and EARS_HOLES>>1
	if (deltaPos > EARS_HOLES>>1) then deltaPos - EARS_HOLES
	else if (deltaPos < -EARS_HOLES>>1) then deltaPos + EARS_HOLES
	else deltaPos;;
	
fun itNoteEarTouched eari curPos deltaPos=
	// right = 0, left = 1
	if (eari == 0 && (g_int_mask & MASK_EAR_RIGHT == 0)) || (eari == 1 && (g_int_mask & MASK_EAR_LEFT == 0)) then // active
	let earsTouch.eari -> et in
	(
		set et.lastMoveTime_ET = time_ms;
		if (et.refPos_ET == -1) then (
			// first move : remember position and direction of movement
			set et.refPos_ET = curPos;
			if ((earDeltaPosNormalized deltaPos) > 0) then set et.moveDir_ET = 0 else set et.moveDir_ET = 1;
			set et.lastDV_ET = 0
			
		) else if !et.turned_ET then
		// was already moving and not turned yet : test turned
		let (earDeltaPosNormalized (curPos - et.refPos_ET)) -> normalizedDV in (
			Secho "NDV="; Iecho normalizedDV; Secho ",";
			
			// Test 1 tour or stopped
			if (et.moveDir_ET == 0 && normalizedDV >= 0 && et.lastDV_ET < 0) then
				// if more than one tour forward : ok
				set et.turned_ET = 1
			else if (et.moveDir_ET == 1 && normalizedDV <= 0 && et.lastDV_ET > 0) then
				// if more than one tour backward : ok
				set et.turned_ET = 1;
	
			Secho "TOUCH="; Iecho et.turned_ET; Secho ",";
				
			set et.lastDV_ET = normalizedDV
		)
	);;

fun touchedP i=
	let earsTouch.i -> et in (et.turned_ET || ((et.lastMoveTime_ET != -1) && ((/*Secho "DLAST="; Iecho */(time_ms - et.lastMoveTime_ET))> EAR_TOUCH_TIMEOUT)))
;;

fun interactiveSendEarTouched lefttouch righttouch=
	// right = 0, left = 1
	wavstop;
	earStop 0;
	let wav_curplayedbytes -> readBytes in  // controlsound resets wav_curplayedbytes so we cache it
	(
		if (lefttouch) then controlsound midi_precedent;
		if (righttouch) then controlsound midi_suivant;		
		set run=interactiveReqWaitRun (httprequest "GET" (interactifurl_ear gItApp readBytes gCurAudioCmdIndex righttouch lefttouch) nil #_interactiveReqCBhttp HTTP_NORMAL)
	);
	0;;

fun interactiveEarProcessTouched=
	if (gItState) then
	let touchedP 0 -> lefttouch in
	let touchedP 1 -> righttouch in
	if (lefttouch || righttouch) then (
		interactiveSendEarTouched lefttouch righttouch;
		interactiveResetEarsTouched
	);;

fun interactiveSendUpload=
	set recordreq = httprequest "POST" (interactifurl_reco gItApp gInteractiveLastWavBytes gCurAudioCmdIndex) recorddata #_interactiveReqCBhttp HTTP_NORMAL;
	set run=interactiveReqWaitRun recordreq;
	0;;


proto zeroRFIDchek 0;;

// Interactive request answer
fun _interactiveReqCBhttp http res=
	Secholn "_interactiveReqCBhttp=";

	if (uploading) then (
		// mode upload / record
		set recorddata=nil;
		set recordreq=nil;
		Secholn res;
		setleds RGB_BLACK
	);

	// if the request was a rfid one...
	zeroRFIDchek;

	if !recording then
	let httpgetcontent res -> ping_trame in
		evalTrame ping_trame;

	0;;

// Interactive request wait : timeout
fun runInteractiveReqWait http=
	// Waiting for interactive request
	// check timeout
	if (!uploading) then // upload record mode : timeout managed by uploadtimeout
	if (httpinactive http)>STD_NET_TIMEOUT then
	(
		Secholn "##timeout on runInteractiveReqWait";
		httpabort http;
		
		// error
		interactiveError
	);

	0;;

// ********************************
// interactive settings
// ********************************

/**
	Called when entering interactive state (command "IC" in a program)
*/
fun reset_IC=
	set g_streaming_chor_enabled=1;
	set g_int_mask=0;
	set g_snd_btn_1 = "clonk";
	set g_snd_btn_2 = "chord";
	set g_record_enabled = 1;
	0;;

fun eval_IC_msg val=
	// parse val : ickey=icval
	let strstr val "=" 0 -> icpos in
	if icpos != nil && icpos > 0 && icpos < (strlen val) - 1 then
	 // present, not first, not last
		let strsub val 0 icpos -> ickey in
		let strsub val icpos+1 ((strlen val) -1-icpos) -> icval in
		(
			if !strcmp ickey "snd.btn.1" then (
				// snd.btn.1                -> son du bouton en cas de pression courte.
				set g_snd_btn_1 = icval;
				0
			) else if !strcmp ickey "snd.btn.2" then (
				// snd.btn.2                -> son du bouton en cas de double click.
				set g_snd_btn_2 = icval;
				0
			) else if !strcmp ickey "snd.itmode" then (
				// snd.itmode                -> son debut et fin du mode interactif.
				if		!strcmp icval "default"		then set gInteractiveSounds = [intDefaultStart intDefaultStop]
				else if !strcmp icval "none"		then set gInteractiveSounds = [intNone intNone];
				0
			) else if !strcmp ickey "chor.itmode" then (
				// chor.itmode                -> chor debut et fin du mode interactif.
				if		!strcmp icval "default"		then set gInteractiveChors = [intchorDefaultStart intchorDefaultStop]
				else if !strcmp icval "none"		then set gInteractiveChors = [intchorStartNone intchorStopNone];
				0
			) else if !strcmp ickey "record.enabled" then (
				// record.enabled   -> activation de l'enregistrement
				if (!strcmp icval "true") then set g_record_enabled = 1
				else set g_record_enabled = 0;
				0
			) else if !strcmp ickey "streaming.chor.enabled" then (
				// streaming.chor.enabled   -> chorégraphie de streaming (oreilles)
				if (!strcmp icval "true") then set g_streaming_chor_enabled = 1
				else set g_streaming_chor_enabled = 0;
				0
			
			) else if !strcmp ickey "int.mask" then (
				// int.mask -> masque d'interruption pour le mode interactif
				set g_int_mask = (atoi icval);
				0
			
			) else if !strcmp ickey "cookie" then (
				// cookie -> cookie envoyé au serveur
				set g_cookie = strcatlist "&c="::icval::nil;
				0
			) else (
				0
			)
		);;


// ****************************************
// Exécution des chorégraphies de streaming
// v17 - AS 25may07

// - 4 pas de danse fournis (dans chorstream_chorslist)
// - une séquence :
// 	- une fois sur chorst_oreille_chance, bouger les oreilles :
// 		- pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 4, 8, 12 dents) et, si elle est différente de la position courante, y aller, dans le sens 'vers l'avant'.
// 	- tirer un pas de danse au hasard (parmi les 4 fournis)
// 	- tirer un nombre de boucles N au hasard entre 3 et 20 (inclus)
// 	- tirer un frame_duration au hasard entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
// or les pas durent de 44 à 71 frames, donc le pas dure de 7 à 17 secs,
// donc la séquence dure de 21s à 5m40s
// 	-> jouer le pas de danse N fois à ce tempo, puis nouvelle séquence
// A chaque pas de danse : tirer 3 couleurs au hazard dans la palette courante : tete, ventre, pied
// Si palette aléatoire : la changer à toutes les séquences
// sinon, fixée par le serveur.
// 
var chorst_pasdedanse;;
var chorst_index;;
var chorst_tempo;;
var chorst_loops;;
var chorst_nexttime;;
var chorst_palettecolors = {0 0 0};;

// v17 AS 25may07 : ratio entre changt de séquence et mvt d'oreille. Plus c'est grand moins souvent les moteurs joueront.
// = 0 : à chaque chgt de seq (en myenne toutes les 2,5 minutes)
// = 1 : une fois sur 2 (soit en moyenne ttes les 5 minutes)
// = 2 : une fois sur 3 (soit en moyenne ttes les 7,5 minutes), etc...
var chorst_oreille_chance;; 

// mouvement des leds et oreilles
fun dochorstream=
	if chorst_pasdedanse==nil || ((chorst_index>=strlen chorst_pasdedanse)&&(chorst_loops<1)) then
	(
		// nouvelle séquence
		// Secho "Sequence suivante ";

		// ears enabled ?
		if (g_streaming_chor_enabled) then 
		(
		// movements moteur
		// toutes les chorst_oreille_chance fois en moyenne
		// et aussi la première fois forcément histoire de montrer qu'on commence
		if (chorst_pasdedanse == nil) then
		(
			// une des oreilles en haut, une autre en bas : radio...
			if ((random 2) == 1) then (earGo 0 0 0; earGo 1 10 0) else (earGo 0 10 0; earGo 1 0 0);
			
			// initialisation chorst_oreille_chance
			set chorst_oreille_chance = 0

		) else if ((random chorst_oreille_chance) == 0) then
		(
			// pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 5, 10, 14 dents) et, si elle est différente de la position courante, y aller, dans le sens 'vers l'avant'.
			let 0::5::10::14::nil -> ear4Positions in
			(
				let listnth ear4Positions rand&3 -> p in earGo 0 p 0;
				let listnth ear4Positions rand&3 -> p in earGo 1 p 0
			);
			
			// de moins en moins souvent, puis de nouveau souvent, etc..
			if ((set chorst_oreille_chance = chorst_oreille_chance + 1) > 4) then set chorst_oreille_chance = 0
		)
		);
		
		// choix d'une séquence = pas de danse (chorst_pasdedanse), tempo et nb de boucles
		set chorst_pasdedanse = listnth chorstream_chorslist Iecholn rand&3;

		set chorst_index=4+1; // on saute le header (4 bytes)
		set chorst_tempo=160+random 90; // entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
		//Secho "tempo "; Iecholn chorst_tempo;
		set chorst_loops=3+random 18; // entre 3 et 20 (inclus)
		//Secho "loops "; Iecholn chorst_loops;
		
		if (current_palette_is_random) then
			// changer palette courante
			set_current_palette random 7;
		
		// choisir 3 couleurs au hasard dans la palette
		set chorst_palettecolors={(random 7) (random 7) (random 7)};
		
		set chorst_nexttime=time_ms
		
	);
	
	// continuer à jouer
	while (chorst_index < strlen chorst_pasdedanse) && time_ms >= chorst_nexttime do
	(
		// interprète la choragraphie. Uniquement des set_led_palette et des set_led_off et des set_led_color
		
		let strget chorst_pasdedanse chorst_index -> cmd in		
			// avance l'index de...
			set chorst_index=chorst_index+2+
				if (cmd == CH_set_led_palette) then
				(
					// palette index
					let strget chorst_pasdedanse chorst_index+1 -> iled in
					let strget chorst_pasdedanse chorst_index+2 -> icol in
					let chorst_palettecolors.(3&icol) -> palcol in
						// jouer la LED						
						led iled current_palette.palcol;

					// 2 bytes : led, color
					2
				)
				else if (cmd == CH_set_led_off) then
				(
					// off
					let strget chorst_pasdedanse chorst_index+1 -> iled in
						led iled 0;
						
					// 1 byte : led
					1
				)
				else if (cmd == CH_set_led_color) then
				(
					led strget chorst_pasdedanse chorst_index+1
						((strget chorst_pasdedanse chorst_index+2)<<16) + 
						((strget chorst_pasdedanse chorst_index+3)<<8) + 
						((strget chorst_pasdedanse chorst_index+4));
						
						// 6 bytes : 2 qui ne servent à rien
						6
				)
				else if (cmd==CH_frame_duration) then
				(
					// on ne le prend pas en compte : c'est chorst_tempo qui gère le tempo
					// 1 byte : duree
					1
				)

				else (
					// problème : commande inconnue : forcer à recommencer au début en incrémentant beaucoup trop
					Streamw strcatlist "dochorstream : unknown command, restarting dance" :: (itoa cmd) :: nil;
					strlen chorst_pasdedanse
				);			
		
		// pas de danse fini ?
		if (chorst_index>=strlen chorst_pasdedanse) then
		(
			// on est arrivés au bout du pas de danse
			// next repeat
			set chorst_loops=chorst_loops-1;
			//Secho "loops "; Iecholn chorst_loops;
			if (chorst_loops > 0) then
			(
				// recommencer pas de danse
				set chorst_index=4+1;  // on saute le header (4 bytes)
				// tout de suite
				set chorst_nexttime=time_ms;				
				
				0 // pour avoir le même type de return value que les autres branches du if...

			) // sinon on laisse chorst_loops = 0 et chorst_index trop loin, ce qui force un passage à la séq suivante
			
		) else 
			// date de la prochaine commande
			// note : on repart de time_ms, histoire de se caler sur le temps présent et non pas sur le temps de
			// la chorégraphie, sinon, on a des coups de speed car cette fonction n'est pas toujours appelée de manière régulière.
			let strget chorst_pasdedanse chorst_index-1 -> delay in
				set chorst_nexttime = time_ms+delay*chorst_tempo
		
	);
	
	0;;

// boucle principale de la chorégraphie de streaming
fun stopStream=
  Streamw "stopStream";
	// oreilles
	earsGoToRefPos;

	set gStreamingState = 0;
	// which resource now ? Can only be interactive or idle
	if (!gBusyState) then ( // don't get a resource if we're busy
    Streamw strcatlist "not busy. gItState : " :: (if (gItState) then "true" else "false") :: nil ;
		if (gItState) then XmppSessionRequestResource "itmode"
		else XmppSessionRequestResource "idle"
	)
	
	;;

fun runStreamingCmd i0=
	if wavrunning==0 then (
		// Fin du stream
		stopStream;
		// next command
		set run=cmdEvalOne i0+1;
			
		nil
	) else (
		// execute streaming choreography
		if !wav_buffering then dochorstream;

		0
	);;


fun _cbGotoNextCmd i0=
	set run=cmdEvalOne i0+1;
	0;;

fun _cbWavError=
	Streamw "_cbWavError";
	if (gItState) then interactiveError;
	0;;


/**
	quand on a rencontre une instruction "WT" dans un programme, qui demandait
  d'attendre <n> millisecondes avant de continuer le programme
*/
fun runWaitCmd i0 =
	if (time_ms > interactiveWaitEndTime_ms) then
	(
		Xw "runWaitCmd";
		set gProcessingWaitState = 1;
		set run=cmdEvalOne i0+1
	)
;;

//********************************************************
// Executes the i0'th command in the 'gCurrentProgram' program
// a command is a list [key val]
fun runEvalOneCommand i0=
//	Secho "runEvalOneCommand ";Iecholn i0;
	interactiveResetEarsTouched;
		
	let listnth gCurrentProgram i0 -> [key val] in
	if (/* Secho "eval cmd:";Secholn */ key)==nil then
	(
		// toutes commandes jouées : demander la suite
		endOfProgram 0;
		0
	)
	else if (!strcmp key "MU") || (!strcmp key "MC") then
	(
		Secho "exec "; Secho key; Secholn " : start music";
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		let listswitchstr rscloaded Secholn val -> music in
			if music==nil then Secholn "###nilmusic";
		wavstartlocal listswitchstr rscloaded val;
		set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "ST" then
	(
		Secholn "exec ST : Start streaming";
		//IPecho netdns 0 1;
		//startdnsclient;
		set gStreamingState = 1;
		setleds 0;
		if !gBusyState then XmppSessionRequestResource "streaming";
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		set gCurStreamName= nil;
		set chorst_pasdedanse=nil;
		let rscfilterurl val -> music in wavstarthttp music #_cbWavError;
		set run=streamCmdRun i0;
		0
	)
	else if !strcmp key "SP" then
	(
		Secholn "exec SP : Start streaming (protected)";
		//IPecho netdns 0 1;
		//startdnsclient;
		set gStreamingState = 1;
		setleds 0;
		if !gBusyState then XmppSessionRequestResource "streaming";
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		set gCurStreamName= nil;
		set chorst_pasdedanse=nil;
		// Romain
		let rscfilterurl val -> music in (
			set music = strcatlist music::"&sn="::(webmac netMac)::nil;
			let music -> tmpval in (
				set tmpval = md5(strcatlist music::"teloiv"::nil);
				set music = strcatlist music::"&cs="::tmpval::nil
			);
			wavstarthttp music #_cbWavError
		);
		set run=streamCmdRun i0;
		0
	)
	else if !strcmp key "SI" then
	(
		Secho "exec SI : "; Secholn val;
		// nomme le stream courant
		if gStreamingState then set gCurStreamName = val;
		// play next
		set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "SE" then
	(
		Secho "exec SE : "; Secholn val;
		// stoppe le stream courant s'il est nommé comme ca
		if gStreamingState && (!strcmp gCurStreamName val) then (
			wavstop;
			earStop 0;		
			stopStream
		);
		// play next
		set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "MS" then
	(
		Secholn "exec MS : "; Secho val;
		// Music Stream : streams the music (like ST), no choregraphy (assumed to be done by CH), not blocking (like MU)
		set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
		// starts the streamed music
		let rscfilterurl val -> music in wavstarthttp music #_cbWavError;
		// play next
		set run=cmdEvalOne i0+1;

		0
	)
	else if !strcmp key "MW" then
	(
		// wait for the end of music
		if wavrunning==0 then set run=cmdEvalOne i0+1;
		0
	)
	else if !strcmp key "CH" then
	(
		Secholn "exec CH : "; Secho val;
		msgchorstart (listswitchstr rscloaded val) #_cbGotoNextCmd i0;
		0
	)
	else if !strcmp key "IS" then
	(
		Secho "exec IS : "; Secholn val;
		// Start Interactive mode
		interactiveStart val;
		0
	)
	else if !strcmp key "IE" then
	(
		Secholn "exec IE : ";
		// Ends Interactive mode
		interactiveStop;
		0
	)
	else if !strcmp key "WT" then
	(
		Xw strcatlist "exec WT : " :: val :: nil ;
	// need to wait for val miliseconds, staying in interactive mode. at the end, program continues.
	// if button pressed, program stops.
	// if rfid detected, send info.
		set gProcessingWaitState = 1;
	  set interactiveWaitEndTime_ms = time_ms + (atoi val);
		set run =	waitCmdRun i0+1;
	  0
	)
	else
	(
		Secho key ; Secholn " : "; Secholn val;
		if !strcmp key "PL" then (set_current_palette_mode atoi val;0)
		else if !strcmp key "CL" then (
				let atoi val -> x in set_current_palette_color (x>>24) x&0xffffff;
				0)
		else if !strcmp key "IC" then (eval_IC_msg val;0)
		else (Secholn "unknown, dropping";0);
		
		// and skip command
		set run=cmdEvalOne i0+1;
		runEvalOneCommand i0+1
	);;

// R=60*((rand&127)+64)) => 64 à 196 mn
// donc si x=30, (x*R)>>7 => 15 à 45 mn
// donc si x=40, (x*R)>>7 => 20 à 61 mn
// donc si x=80, (x*R)>>7 => 40 à 122 mn
// donc si x=216, (x*R)>>7 => 108 à 330 mn
// donc si x=255, (x*R)>>7 => 127 à 390 mn, soit 2 à 6,5h
var nexttaichi;;
fun dotaichinow=
	//Secho "checktaichi ";
	if infotaichi && (infotaichi != nil) && (!gSleepState) then let (if nexttaichi!=nil then (time>nexttaichi) else 0) -> now in (
		if now || nexttaichi==nil then // compute nexttaichi
		let if (infotaichi == 40) then 255 else if (infotaichi == 255) then 40 else 80 -> correctedTaichi in // etait inversé
		let ((correctedTaichi*60*((rand&127)+64))>>7) -> delaye in (
			Secho "taichi in "; Iecho delaye; Secholn "s";
			set nexttaichi=time+delaye
		);
		now
	) else (
		set nexttaichi=nil;
		0
	);;

fun runEarReset cb=
	if (!earResetting) then
		call cb []
	;;

fun _goSleepNow=
	// oreilles arrivées en haut : eteindre tout + oreille basses
	setleds RGB_BLACK;
	earGo 0 10 0; // sur le v2 c'est la position 10 qui est en bas
	earGo 1 10 0;
	set run=sleepRun
	;;
	
fun _wakeupNow=
	//Secholn "_wakeupNow";
	earsGoToRefPos;
	earSetWaitAndDetectMode;
	set run=idleRun
	;;
	
fun startSleep=
	Secholn "startSleep";
	let gSleepState -> sleeping in (
		set gSleepState = 1;
		set gStreamingState = 0; // just to be sure
		set gProcessingState = 0; // just to be sure
		// server resource
		let XmppSessionRequestResource "asleep" -> result in (
			// Starts to sleep
			Secholn "going asleep";
			if sleeping == 0 then (
				setleds RGB_VIOLET;
				earStartReset // oreilles en haut
			);
			set run = earResetWaitRun #_goSleepNow; // attente de fin oreille
			result
		)
	)
	;;

fun endSleep=
	Secholn "endSleep";
	if (gSleepState) then (
		// was asleep or initial booting (gSleepState = 1 at start)
		set gSleepState = 0;
		set gStreamingState = 0; // just to be sure
		set gProcessingState = 0; // just to be sure
		let XmppSessionRequestResource "idle" -> result in (
			setleds RGB_VIOLET; // violet
			earStartReset; // reset oreilles
			set run = earResetWaitRun #_wakeupNow; // attente de fin oreille
			result
		)
	) else (
		// was not asleep (after a reconnect for example)
		let (
			if (gStreamingState) then XmppSessionRequestResource "streaming"
			else if (gItState) then XmppSessionRequestResource "itmode"
			else XmppSessionRequestResource "idle") -> result in (
			set run=idleRun;
			result
		)
	)
	;;

// ******************************************
// Main function : evaluate trame
// trames are sent back from ping and itmode
// a trame contains frames
// a frame can:
// - change the ping delay (type 3)
// - order 'reboot' (type 9)
// - contain new service values and ear positions (type 4)
// - contain a program (type 10)
// In program frames, programs can contain url resources: resources are loaded and stored and then program is executed
// Return the XMPP packet(s) to send or nil.

fun evalTrame ping_trame=
	Secholn "evalTrame >>";
	Secholn ping_trame;
	Secholn "<<";
	let pingextract dump ping_trame -> frame_list in
	if frame_list==nil then (
		// error, bad trame
		Secholn "bad trame";
		dump ping_trame;
		Secholn "dropping";
		if (gItState) then (
			// display error
			interactiveError;
			nil
		) else (
			// drop, and ping again later
			set run=idleRun;
			nil
		)
	) else (
		// frame_list ok
		let nil->xmpp_packets in
		let nil->program in
		(
			for l=frame_list;l!=nil;tl l do let hd l-> [code val] in
			(
				let (if code == 3 then (
					// ping delay
#ifdef PING
					set pingdelay = strget val 0;
#else
					Secholn "dropping ping delay";
#endif
					nil
				) else if code == 4 then (
					// update sources, messages number and ears
					let ((strget val 3) == 0xFF) -> fromHttp in
					if fromHttp then (
						// old format
						infoUpdate strsub val 4 nil;
						dumpStatus;
						nil
					) else (
						// new format
						newInfoUpdate strsub val 4 nil;
						dumpStatus;
						nil
					)
				) else if code == 9 then (
					// reboot
					//////// reboot 0x0407FE58 0x13fb6754;
					nil
				) else if code == 10 then (
					// programs (or IDLE or SLEEP)
					uncrypt val 1 nil 0x47 47;
					set program=dump_prgm filterconfig val 1;
					nil
				) else if code == 11 then (
					// change mode
					let strget val 0 -> mode in (
						Secho "changemode = "; Iecholn mode;
						if (mode == 0) then endSleep
						else if (mode == 1) then startSleep
						else nil
					)
				) else (Secho "Unknown code "; Iecho code; Secholn ""; nil)) -> xmpp_packet_list in
				if (xmpp_packet_list != nil) then
					set xmpp_packets = xmpp_packet_list::xmpp_packets
				else
					xmpp_packets
			); // for l=frame_list

			// post process : a program ?
			if program!=nil then (
				// Initialize Program
				set paletteselected = 0;
				set gCurrentProgram = program;
				set gProcessingState = 1;
				set gProcessingWaitState = 0;
				CheckForPaletteBefore program; // Permet de mettre la palette correspondante au programme, v17 (add romain)
				// resources
				set rsctoget=rscFromProgram program;
				// empties the rsc cache
				set rscloaded=nil;
				let hd rsctoget -> [url _] in
				if url==nil then (
					// no resources to load : start the program now
					prgmStart;
					0
				) else (
					// will load rsctoget and then start the program 'gCurrentProgram'
					Secho "loading rsrcs...";
					set run = rscLoadNextRun;
					0
				)
			);
			xmpp_packets
		) // nil->program
	) // frame_list != nil
	;;


//*******************
// Trames queue
var gTramesQueue = nil;;
const TRAME_QUEUE_MAXLEN = 10;;

fun _isResourceValid rsrcName=
	// les règles d'adéquation entre resource et etats
	if (!strcmp rsrcName "urgent") then 1 // tjrs
	else if (!strcmp rsrcName "sources") then 1 // tjrs
	else if (!strcmp rsrcName "boot") then 1 // tjrs
	else if (gStreamingState) then (if (!strcmp rsrcName "streaming") then 1 else 0)
	else if (gItState) then (if (!strcmp rsrcName "itmode") then 1 else 0)
	else if (gSleepState) then (if (!strcmp rsrcName "asleep") then 1 else 0)
	else if (gProcessingState) then 0
	else 1;;

fun _queueTrameRemoveEntry binome=
	// dépile
	set gTramesQueue = remfromlist gTramesQueue binome;
	
	// was full ?
	let listlen gTramesQueue -> queueLen in
	if queueLen == TRAME_QUEUE_MAXLEN-1 then (
		Secholn "trame queue not full anymore, warning server";
		set gBusyState = 0;
		// which resource now ? Can be in this order asleep, streaming, itmode or idle
		if (gSleepState) then XmppSessionRequestResource "asleep"
		else if (gStreamingState) then XmppSessionRequestResource "streaming"
		else if (gItState) then XmppSessionRequestResource "itmode"
		else XmppSessionRequestResource "idle"
	);
	0;;

fun getNextValidPendingTrame=
	let gTramesQueue -> ptr in
	let nil -> theTrame in (
		while ((theTrame == nil) && ((hd ptr) != nil)) do (
			let hd ptr -> binome in
			let binome -> [rsrc expiration_time ping_trame] in
			if ((expiration_time != nil) && (time >= expiration_time)) then (
				Secholn "trame expired, removing";
				_queueTrameRemoveEntry binome
				
			) else if (_isResourceValid rsrc) then (
				// ok
				set theTrame = ping_trame;
			
				_queueTrameRemoveEntry binome
			);
			
			// next
			set ptr = tl ptr
		);
		theTrame
	)
	;;



fun processIncomingTrame ping_trame rsrc ttl=
	Secho "processIncomingTrame for "; Secholn rsrc;
	if (_isResourceValid rsrc) then (
		evalTrame ping_trame
	) else (
		Secholn "enqueueing trame";
		let if (ttl == nil) then nil else (time + (atoi ttl)) -> expiration_time in
			set gTramesQueue = conc gTramesQueue [rsrc expiration_time ping_trame]::nil;
		
		// full ?
		let listlen gTramesQueue -> queueLen in
		if queueLen >= TRAME_QUEUE_MAXLEN then (
			Secholn "trame queue full, warning server";
			set gBusyState = 1;
			(XmppSessionRequestResource "busy")::nil
		) else (
			nil
		)
	)
	;;


fun runLogin=
	// if trame waiting, execute it
	let getNextValidPendingTrame -> trame in 
	if trame != nil then
		evalTrame trame;;

fun runIdle=
	// if trame waiting, execute it
	let getNextValidPendingTrame -> trame in 
	if trame != nil then (
		evalTrame trame;
		0
	) else (
		set gProcessingState = 0;
#ifdef SERVERLESS
		if check_surprise then (
			surprise;
			0
		)
#endif 
		else if dotaichinow then (
			taichistart;
			0
		) else (
#ifdef PING
		       runpingstart;
#endif
		       0
		)		
	);
	0
;;


var gWasNetActivity = 0;;
fun noseled=
	if !earDetecting then
	// led tete clignote if netactivity or wav_buffering // 
	let uploading || (match run with (rscLoadWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
	if (netactivity || wav_buffering) then (
		let if netactivity then 256 else if wav_buffering then 128 else 0 -> speed in
		if speed > 0 then led LED_NOSE (if time_ms&speed then RGB_RED else 0);
		set gWasNetActivity = 1
	) else if (gWasNetActivity) then (
		// show off the light
		led LED_NOSE RGB_BLACK;
		set gWasNetActivity = 0
	);
	0;;

fun bottomled=
	if gSleepState == 0 then 
	if !earDetecting then
		(let osc time_ms>>4 -> v in led LED_BASE v*0x10001); // pulse violet
	0;;
	

// ********** RFID **********************
// v19 Amélioration de la lecteure RFID
// v19 Les fonction ParseRfid servent à tester les caractères de l'identifiant RFID
var lastrfid;;
var RFIDchar = 2;; // v19
var RFIDint = 6;; // v19
var RFIDchek = 0;; // v19
var RFIDlast = 0;; // v19

var tmptps = 0;;
	
fun _cbrfidhttp http res=
	Secholn "Recv rfid:"; Secho res;
	set gProcessingState = 0;
	set RFIDchek = 0;
	let httpgetcontent res -> ping_trame in
		evalTrame ping_trame;
	0;;

fun dumprfid l0=
	for l=l0;l!=nil;tl l do let hd l->x in Secholn webmac x;
	l0;;

fun ParseRfidChar id index= // v19
	set RFIDchar = strget id index;
	RFIDchar;;

fun ParseRfid id = // v19
	set RFIDint = 6;
	for i=0;i<6 do ( if(ParseRfidChar id i) == 0 then set RFIDint = RFIDint - 1);
	RFIDint;;

/**
	Sets RFIDchek = 0
*/
fun zeroRFIDchek =
	set RFIDchek = 0;;


// *************** CONTROLS *************

fun _cbrfidendchor unused=
	// continue idle
	set run=idleRun;
	0
	;;


/**
	Controls if a stamp is shown to the rabbit.
	Does not control wether we _should_ control or not (according to the interactive state, ...)

	Returns the rfid or nil.
*/
fun checkRfidPresence=
	let rfidGet -> rfid in
	if (strcmp rfid lastrfid) && (time_ms - RFIDlast > 750) then
		rfid
	else
		nil	
;;

fun controlrfid=
//	let hd dumprfid rfidGetList -> rfid in
//	if ((!gItState) // disabled when interactive except ...
//      || (gItState && ((g_int_mask & MASK_RFID == 0) || (gProcessingState && gProcessingWaitState)))) then // enabled when mask set or executing a waiting command
(
	if ((time_ms - RFIDlast) > 1000) then
	(
		set lastrfid = "0000000"
	);
	let checkRfidPresence -> rfid in
	if rfid!=nil then
	(
		if (ParseRfid rfid) !=0 then
		(
			set lastrfid=rfid;
			set RFIDlast = time_ms;
			controlsound midi_RFIDok;

			// lancer l'animation (v19)
			msgchorstart chor_RFIDok::nil #_cbrfidendchor nil;
			//set chortimescale=10; // recopié d'avant, mas pourquoi ? Nécessaire ? [AS 24oct07]				
			
			hookRfid rfid
		)
	)
	)
;
	0;;

fun controlplay=
	let buttongetevent -> ev in
	if ev!=nil then (
		Secholn "controlplay";
		wavstop;
		earStop 0;
		let atoi listswitchstr gCurrentProgram "ID" -> id in
			if ev==BUTTON_CLIC then	(controlsound midi_abort; if (gStreamingState) then stopStream; endOfProgram 0; XmppSessionSendButtonMsg ev 1 id) //pause  
			else if ev==BUTTON_DCLIC then (controlsound midi_ack;if (gStreamingState) then stopStream; endOfProgram 0; XmppSessionSendButtonMsg ev 1 id) //ackall
			else if ev==BUTTON_LCLIC then nil //pause ou record ? callPingRequest 5
	)
	;;

fun controlwait=
	let buttongetevent -> ev in
	let if ev==nil then eargetevent else ev -> ev in
	if ev!=nil then
	(
		Secho "controlwait ev="; Iecholn ev; 
		wavstop;
		earStop 0;
		if ev==BUTTON_CLIC then (hookClick time_ms;0) // click
		else if ev==BUTTON_DCLIC then (controlsound midi_ack; hookDblClick time_ms;0) //ackall
		else if ev==BUTTON_LCLIC then _controlrecord 0	//  //back ou record
		else if ev==BUTTON_DLCLIC then _controlrecord 1	// //back ou record
		else if ev&0x8000 then (
			// oreilles
			controlsound midi_acquired;
			let (ev-0x8000)&0xFF00>>8 -> leftpos in
			let (ev-0x8000)&0xFF -> rightPos in (
				// remember for after sleep, etc...
				set extleft=leftpos;
				set extright=rightPos;
				hookEars leftpos rightPos
			);
			0
		)
	);
	controlrfid
	;;

fun controlinteractif=
	let buttongetevent -> ev in
	if ev!=nil then
	(
		Secholn "controlinteractif";
		if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then	(
			if (g_int_mask&MASK_BUTTON == 0) then interactiveSendBtn ev
		) else if ev==BUTTON_LCLIC then (
			if (g_record_enabled) then (
				// remember wav position and start record
				set gInteractiveLastWavBytes = wav_curplayedbytes ;
				_controlrecord 0
			) else (
				// like BUTTON_CLIC
				set ev = BUTTON_CLIC;
				if (g_int_mask&MASK_BUTTON == 0) then interactiveSendBtn ev	
			)
		)
	);
	controlrfid
	;;

/*
	Utilise dans le cas ou on execute un programme et qu'on est en train
  d'executer une commande "WT". En gros on a un comportement normal
  sauf qu'on lit les rfid en plus
*/
fun controlprogramwait =
	(if (!gItState) then controlplay else controlinteractif) ;
 	controlrfid
;;

fun dumpStatus=
	Secholn "//--- status ---";
	Secho "earsmode="; Iecholn earsmode;
	Secho "earDetecting="; Iecholn earDetecting;
	Secho "gSleepState="; Iecholn gSleepState;
	Secho "gStreamingState="; Iecholn gStreamingState;
	Secho "gProcessingState="; Iecholn gProcessingState;
	Secho "gBusyState="; Iecholn gBusyState;
	Secho "gItState="; Iecholn gItState;
	Secho "gItApp="; Secholn gItApp;
	Secholn "//--- end status ---"
	;;

const CONTROL_WAIT=1;;
const CONTROL_PLAY=2;;
const CONTROL_INTERACTIF=3;;
const CONTROL_PROGRAMWAIT=4;;


fun getRunState =
	run;;

fun setRunState runState =
	let run -> oldRun in (
		set run = runState;
		oldRun
	);;


/**
	Stop everything we can be doing and resets to either idle or asleep
 */
fun stopEverythingAndResetToIdle =
	wavstop;
	stopStream;
	earStartReset;
	set gItState = 0;
	set g_cookie = "";
	set gItApp = nil;
	set gProcessingState = 0;
	set gStreamingState = 0;
	set gCurrentProgram = nil;
	set run = if (!gSleepState) then idleRun else sleepRun;
	0
;;


fun loop=
//Secho "l";
	wifiRun;

    if netState==RT2501_S_IDLE then
	match wifi with
	(initW -> nil)
	|(_ ->
		Secholn "######### wifi lost";
		set wifi=reconnectW;
		earStop 1; // make sure that ears are not moving while we're reconnecting.
		0
	);

	buttonloop;
//	buttongetevent;
	let match run with
	( configstartRun -> earRun;runconfigstart;0 )|
	( configwaitRun http -> earRun;runconfigwait http ; 0)|
#ifdef PING
	( pingstartRun -> earRun;if currentTrameID!=MSG_ASLEEP then bottomled;runpingstart;0)|
	( pingwaitRun http -> earRun; if currentTrameID!=MSG_ASLEEP then (infoRun;bottomled;noseled);runpingwait http;if currentTrameID!=MSG_ASLEEP then CONTROL_WAIT)|
	( pingRequestWaitRun http->bottomled;noseled;runPingRequestWait http;0)|
	( stdWaitRun t -> earRun;if currentTrameID!=MSG_ASLEEP then (infoRun;bottomled;noseled);runStdWait t; CONTROL_WAIT) |
#endif
#ifdef XMPP
	( xmppLoginRun ->
	if (earResetting && earsInited) then earRun else earStop 1;
	runLogin;
	CONTROL_WAIT) |
	( xmppReconnectRun params ->
	if (earResetting && earsInited) then earRun else earStop 1;
	if gSleepState == 0 then (
		// Affichage des sources.
		infoRun;
		// On fige la base en violet
		led LED_BASE RGB_VIOLET	
	);
	let params -> [waitTime xSession oldRun] in 
		match xSession.sStatus with
			(sOpened -> set run = oldRun; 0)
			|(sClosed -> 
				if time_ms > waitTime then (
					XmppGateReconnect xSession 0
				);
				0)
			|(_ -> 0);
	CONTROL_WAIT)|
#endif
	( idleRun -> earRun;infoRun;bottomled;noseled;runIdle;CONTROL_WAIT) |
	( sleepRun -> earRun;runIdle;0) |
	
	( rscLoadNextRun -> earRun;infoRun;bottomled;noseled;runRscLoadNext; CONTROL_WAIT)|
	( rscLoadWaitRun http-> earRun;infoRun;bottomled;noseled;runRscLoadWait http;CONTROL_WAIT)|
	( cmdEvalOne i-> earRun;runEvalOneCommand i;CONTROL_PLAY)|
	( chorCmdRun i-> earRun;noseled;runChorCmd i;CONTROL_PLAY)|
	( streamCmdRun i0-> earRun;noseled;runStreamingCmd i0;CONTROL_PLAY)|
	( waitCmdRun i -> earRun;noseled;runWaitCmd i;CONTROL_PROGRAMWAIT)|

	( earResetWaitRun cb -> earRun; runEarReset cb; 0) |

	( recordRun -> runrecord; 0)|
	( recordStartRun -> runrecordstart; 0) |

	( interactiveReqWaitRun http-> earRun;infoRun;bottomled;noseled;runInteractiveReqWait http;CONTROL_WAIT)
	 -> keymanager in
	if keymanager==CONTROL_WAIT then
		controlwait
	else if keymanager==CONTROL_PLAY then
		(if (!gItState) then controlplay else controlinteractif)
	else if keymanager==CONTROL_PROGRAMWAIT then
		controlprogramwait
	else
		buttongetevent
	;

	XmppSessionRun; // On envois éventuellement les packets en attente	
	XmppSessionIdle;
	uploadtimeout;
#ifdef SERVERLESS
	run_icmp_ping;
	set infotaichi = 80;
#endif
	checkdhcp 0;

	// if ears touched while interactive : process it
	interactiveEarProcessTouched;

	update_time_internal;
	wavtime;

	updatevol;	
	0;;

fun main=
	leds_set_state LEDS_STATE_START ;
	//ResetXmppPassword; // DEBUG
	MACecho netMac 0 1;
	set master=0;
	Secholn ":started";
	confInit;
	wifiInit 0;
	loopcb	#loop;
	infoInit;
	netstart;
	startdnsclient;
	startdhcp;
	Secholn ":done";
	srand time_ms;
	updatevol;
//	wavstartlocal midi_endrecord::nil;
	dumpscan wifiscans;
#ifdef WEBSERVER
#ifdef SIMU
	startwebserver 8080;
#else
	startwebserver 80;
#endif
#endif
	runinit;
	set gInteractiveSounds = [intDefaultStart intDefaultStop]; // Default Sounds of InteractiveMode
	set gInteractiveChors = [intchorDefaultStart intchorDefaultStop]; // Default Sounds of InteractiveMode
	0;;

#endif // ifdef NOMINAL
