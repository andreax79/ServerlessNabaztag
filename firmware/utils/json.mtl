#include protos/ascii_protos.mtl
#include protos/json_protos.mtl

//--------------------------------------------------------------------------------------------------
// JSON output
//--------------------------------------------------------------------------------------------------

/**
 * Check if a character is a special character that needs to be escaped in JSON.
 */
fun _json_is_special_char c =
    (c == ASCII_TAB) ||
    (c == ASCII_NEWLINE) ||
    (c == ASCII_DOUBLE_QUOTE) ||
    (c == ASCII_SLASH) ||
    (c == ASCII_BACKSLASH);;

/**
 * Count the number of special characters in a string that need to be escaped for JSON.
 */
fun _json_count_special_char s =
    let 0 -> count in
    let strlen s -> length in (
        for i=0; i<length do if _json_is_special_char strget s i then set count = count + 1;
        count
    );;

/**
 * Quote a string for JSON output, escaping special characters.
 * If the input string is nil, returns an empty quoted string "".
 */
fun json_quote_str str=
    if str == nil then "\"\"" else
    let strlen str -> len in
    let _json_count_special_char str -> nquote in
	let strnew (len + nquote + 2) -> s in (
        strset s 0 34; // opening quote
        let 1 -> j in
        for i=0; i<len do (
            let strget str i -> ch in (
                if ch == ASCII_TAB then (strset s j 92; set j = j + 1; set ch = 116) // 't'
                else if ch == ASCII_NEWLINE then (strset s j 92; set j = j + 1; set ch = 110) // 'n'
                else if ch == ASCII_DOUBLE_QUOTE then (strset s j 92; set j = j + 1; set ch = 34) // '"'
                else if ch == ASCII_SLASH then (strset s j 92; set j = j + 1; set ch = 47) // '/'
                else if ch == ASCII_BACKSLASH then (strset s j 92; set j = j + 1; set ch = 92); // '\'
                strset s j ch;
                set j = j + 1
            )
        );
        strset s (len + nquote + 1) 34; // closing quote
        s
    )
;;

/**
 * Create a JSON integer key-value pair string.
 */
fun json_int k v=
    strcatlist "\"" :: k :: "\": " :: (itoa v) :: nil
;;

/**
 * Create a JSON string key-value pair string, quoting the value.
 */
fun json_str k v=
    strcatlist "\"" :: k :: "\": " :: (json_quote_str v) :: nil
;;

/**
 * Create a JSON object key-value pair string.
 */
fun json_obj k v=
    strcatlist "\"" :: k :: "\": " :: v :: nil
;;

//--------------------------------------------------------------------------------------------------
// Parse JSON
//--------------------------------------------------------------------------------------------------

proto _json_parse_object 1;;
proto _json_parse_array 1;;
proto _json_is_whitespace 1;;
proto _json_peek_char 1;;
proto _json_parse_string 1;;
proto _json_parse_number 1;;
proto _json_skip_whitespace 1;;
proto _json_parse_value 1;;

/**
 * Check if character is whitespace
 * ch: character to check
 */
fun _json_is_whitespace ch=
    (ch == ASCII_SPACE) || (ch == ASCII_NEWLINE) || (ch == ASCII_TAB);;

/**
 * Peek at the current character without advancing the index
 * j: JsonParserState
 */
fun _json_peek_char j=
    if j.json_index < j.json_length then
        strget j.json_string j.json_index
    else
        nil;;

/**
 * Parse a JSON string and return the parsed string
 * j: JsonParserState
 */
fun _json_parse_string j=
    // Consume the opening quote
    if (_json_peek_char j) != ASCII_DOUBLE_QUOTE then (
        Secholn "Error: Expected opening double quote for string";
        nil
    ) else (
        let j.json_index + 1 -> start in  // skip opening quote
        let 0 -> end in
        let 0 -> done in (
            while (j.json_index < j.json_length) && (!done) do (
                set j.json_index = j.json_index + 1;
                let _json_peek_char j -> ch in (
                    // TODO escape sequences
                    if ch == ASCII_DOUBLE_QUOTE then (
                        set end = j.json_index;
                        set j.json_index = j.json_index + 1;
                        set done = 1
                    )
                )
            );
            [json_value_str: strsub j.json_string start (end - start)]
        )
    );;

/**
 * Parse a JSON number and return the parsed number
 * j: JsonParserState
 */
fun _json_parse_number j=
    let j.json_index -> start in
    let 0 -> end in
    let 0 -> done in (
        // TODO handle negative numbers, decimals
        while (j.json_index < j.json_length) && (!done) do (
            let _json_peek_char j -> ch in
                if (ch < 48 || ch > 57) && ch != ASCII_MINUS && ch != ASCII_DOT then (
                    set end = j.json_index;
                    set done = 1
                )
                else
                (
                    set j.json_index = j.json_index + 1
                )
        );
        let strsub j.json_string start (end - start) -> str in
            [json_value_str:str json_value_int:atoi str]
    );;

/**
 * Move the index past any spaces, tabs, or newlines
 * j: JsonParserState
 */
fun _json_skip_whitespace j=
    let strget j.json_string j.json_index -> ch in (
        while (j.json_index < j.json_length) && _json_is_whitespace ch do (
            set j.json_index = j.json_index + 1;
            let strget j.json_string j.json_index -> ch in 0
        );
        0
    );;

/**
 * Parse a JSON value (object, array, string, number, boolean, null)
 * j: JsonParserState
 */
fun _json_parse_value j=
    // Skip whitespace
    _json_skip_whitespace j;
    let _json_peek_char j -> ch in (
        if ch == ASCII_LEFT_BRACE then _json_parse_object j
        else if ch == ASCII_LEFT_BRACKET then _json_parse_array j
        else if ch == ASCII_DOUBLE_QUOTE then _json_parse_string j
        else if (ch == ASCII_MINUS) || (ch == ASCII_DOT) || ((ch >= 48) && (ch <= 57)) then _json_parse_number j
        else if (ch == 116) then [json_value_int:1] // true
        else if (ch == 102) then [json_value_int:0] // false
        else if (ch == 110) then [json_value_int:nil] // null
        else nil // Unexpected character, could handle error here
    );;

/**
 * Parse a JSON array and return the parsed array
 * j: JsonParserState
 */
fun _json_parse_array j=
    // Consume the opening bracket
    set j.json_index = j.json_index + 1;
    let 0 -> done in
    let [json_value_arr: nil] -> arr in (
        while (j.json_index < j.json_length) && (!done) do (
            // Skip whitespace
            _json_skip_whitespace j;
            let _json_peek_char j -> ch in (
                if ch == ASCII_RIGHT_BRACKET then ( // End of array
                    set j.json_index = j.json_index + 1; // Consume closing bracket
                    set arr.json_value_arr = rev arr.json_value_arr nil;
                    set done = 1
                ) else if ch == ASCII_COMMA then (
                    set j.json_index = j.json_index + 1  // Consume comma
                ) else (
                    // Parse value
                    let _json_parse_value j -> value in (
                        // Secho "Array value: "; Secholn value.json_value_str;
                        set arr.json_value_arr = value::arr.json_value_arr;
                        nil
                    )
                )
            )
        );
        arr
    );;

/**
 * Parse a JSON object and return the parsed object
 * j: JsonParserState
 */
fun _json_parse_object j=
    // Consume the opening brace
    set j.json_index = j.json_index + 1;
    let 0 -> done in
    let [json_value_obj: nil] -> obj in (
        while (j.json_index < j.json_length) && (!done) do (
            // Skip whitespace
            _json_skip_whitespace j;
            let _json_peek_char j -> ch in (
                if ch == ASCII_RIGHT_BRACE then ( // End of object
                    set j.json_index = j.json_index + 1; // Consume closing brace
                    set done = 1
                ) else if ch == ASCII_COMMA then (
                    set j.json_index = j.json_index + 1  // Consume comma
                ) else if ch != ASCII_DOUBLE_QUOTE then (
                    Secholn "Error: Expected string key in object";
                    set done = 1
                ) else (
                    let _json_parse_string j -> key in (
                        // Skip whitespace before colon
                        _json_skip_whitespace j;
                        if (key == nil) then (
                            Secholn "Error: Invalid key in object";
                            set done = 1;
                            nil
                        ) else if (_json_peek_char j) != ASCII_COLON then (
                            Secholn "Error: Expected colon after key in object";
                            set done = 1;
                            nil
                        ) else (
                            // Consume the colon
                            set j.json_index = j.json_index + 1;
                            // Get the value
                            let _json_parse_value j -> value in (
                                // Secho key.json_value_str; Secho "="; Secholn value.json_value_str;
                                set obj.json_value_obj = [key value]::obj.json_value_obj;
                                nil
                            )
                        );
                        nil
                    )
                )
            )
        );
        obj
    );;

/**
 * Parse a JSON string and return the parsed value as JsonValue
 * json_str: JSON string to parse
 */
fun json_parse json_str=
    let [json_string:json_str json_index:0 json_length:strlen json_str] -> j in (
        _json_skip_whitespace j;
        let _json_peek_char j -> ch in (
            if ch == ASCII_LEFT_BRACE then _json_parse_object j
            else if ch == ASCII_LEFT_BRACKET then _json_parse_array j
            else nil
        )
    );;

/**
 * Get value from JSON object by key
 * j: JSON object
 * key: key to search
 */
fun json_obj_get_value j key=
    let nil -> res in (
        for p=j.json_value_obj;p!=nil&&res==nil;tl p do
            let hd p -> pair in
            let pair -> [k v] in
            if !strcmp k.json_value_str key then set res = v;
        res
    );;

/**
 * Get value from JSON array by index
 * j: JSON array
 * index: index to search
 */
fun json_arr_get_value j index=
    let 0 -> i in
    let nil -> res in (
        for p=j.json_value_arr;p!=nil&&res==nil;tl p do (
            if i==index then set res = hd p;
            set i = i + 1
        );
        res
    );;

/**
 * Get string value from JSON array by index
 * j: JSON array
 * index: index to search
 */
fun json_arr_get_str j index=
    let json_arr_get_value j index -> v in v.json_value_str;;

/**
 * Get integer value from JSON array by index
 * j: JSON array
 * index: index to search
 */
fun json_arr_get_int j index=
    let json_arr_get_value j index -> v in v.json_value_int;;

/**
 * Split JSON key into parts
 * k: JSON key (e.g., "daily.weathercode[0]")
 */
fun _json_split_key k=
    let nil -> next in
    let (strstr k "." 1) -> start in (
        if start==nil then (
            set start = (strstr k "[" 1);
            set next = start
        ) else
            set next = start + 1;
        if start==nil then
            k::nil
        else
            let strsub k 0 start -> key in
            let strsub k next nil -> rest in
                key::_json_split_key rest
    );;

/**
 * Get value from JSON by key
 * j: JSON object
 * k: JSON key to search (e.g., "daily.weathercode[0]")
 */
fun json_get j k=
    let j -> res in (
        for p=_json_split_key k; p!=nil; tl p do
            let hd p -> key in
                set res = (
                    if (strget key 0) == ASCII_LEFT_BRACKET then
                        json_arr_get_value res atoi (strsub key 1 ((strlen key)-2))
                    else
                        json_obj_get_value res key
                );
        res
    );;

/**
 * Get string value from JSON by key
 * j: JSON object
 * k: JSON key to search
 */
fun json_get_str j k=
    let json_get j k -> v in v.json_value_str;;

/**
 * Get integer value from JSON by key
 * j: JSON object
 * k: JSON key to search
 */
fun json_get_int j k=
    let json_get j k -> v in v.json_value_int;;

/**
 * Get array value from JSON by key
 * j: JSON object
 * k: JSON key to search
 */
fun json_get_arr j k=
    let json_get j k -> v in v.json_value_arr;;
