#include protos/jobs_protos.mtl

//--------------------------------------------------------------------------------------------------
// Jobs
//--------------------------------------------------------------------------------------------------

var _jobs = nil;; // list of Job
var _job_next_id = 1;; // next job ID

fun job_status_fmt job=
    match job.job_status with
        (JobRun -> "run") |
        (JobSuspend -> "suspend") |
        (JobStop -> "stop") |
        (_ -> nil)
    ;;

/**
 * Add a job at the end of jobs list
 */
fun _job_add e l=
    if l==nil then
        e::nil
    else
        (hd l)::_job_add e tl l
    ;;

/**
 * Execute a job
 * job: job to execute
 */
fun _job_execute job=
    if job.job_period_ms != nil then
        let time_ms -> now in (
            // Initialize next run time
            if job.job_next_run_ms == nil then
                set job.job_next_run_ms = now + job.job_period_ms;
            // Check if it's time to run the job
            if (job.job_next_run_ms - now) <= 0 then (
                set job.job_next_run_ms = now + job.job_period_ms;
                call job.job_f []
            ) else
                job.job_status
        )
    else
        call job.job_f [];;

/**
 * Initialize a job
 * name: job name
 * period_ms: how often to run (in milliseconds) (nil = execute every time job_loop is called)
 * f: function to call
 */
fun job_start_ex name period_ms f=
    let [job_id:_job_next_id job_name:name job_f:f job_status:JobRun job_period_ms:period_ms] -> job in (
        set _job_next_id = _job_next_id + 1;
        set _jobs = _job_add job _jobs
    )
    ;;

fun job_start name f=
    job_start_ex name nil f;;

/**
 * Get a job by name
 * name: job name
 */
fun job_get name=
    let nil -> result in (
        for l=_jobs;l!=nil; tl l do
            let hd l -> job in
                if !strcmp name job.job_name then
                    set result = job;
        result
    );;

/**
 * Temporarily stop execution of a job
 * name: job name
 */
fun job_suspend name=
    let job_get name -> job in
        if job != nil then
            set job.job_status = JobSuspend;
    0;;

/**
 * Resume execution of a suspended job
 * name: job name
 */
fun job_resume name=
    let job_get name -> job in
        if job != nil then
            set job.job_status = JobRun;
    0;;

/**
 * Stop a job
 * name: job name
 */
fun job_stop name=
    let job_get name -> job in
        if job != nil then
            set job.job_status = JobStop;
    0;;

/**
 * Jobs loop
 */
fun job_loop=
    for l=_jobs;l!=nil; tl l do
        let hd l -> job in (
            set job.job_status = match job.job_status with
                (JobRun -> _job_execute job) | // Execute running jobs
                (JobSuspend -> JobSuspend) | // Keep suspended jobs suspended
                (_ -> set _jobs = remfromlist _jobs job; JobStop) // Remove stopped jobs
            );
    0;;

/**
 * Format a job in JSON format
 * job: job to format
 */
fun job_format_json job=
    strcatlist
        "{ "::
            (json_int "id" job.job_id) :: ", " ::
            (json_str "name" job.job_name) :: ", " ::
            (json_str "status" job_status_fmt job) ::
            (
                if job.job_period_ms != nil then
                    (strcat ", " json_int "period_ms" job.job_period_ms)
            ) ::
        " }" :: nil;;

/**
 * Return the jobs list in JSON format
 */
fun job_json=
    let "[\n" -> result in
    let listlen _jobs -> n in (
        for l=_jobs;l!=nil; tl l do
            let hd l -> job in
            let if nil!=tl l then ",\n" else "\n]" -> sep in
            set result = strcatlist result::(job_format_json job)::sep::nil;
        result
    );;
