#include protos/jobs_protos.mtl

var _jobs = nil;; // list of Job

fun job_status job=
    match job.status with
        (JobRun -> "run") |
        (JobSuspend -> "suspend") |
        (_ -> nil)
    ;;

/**
 * Add a job at the end of jobs list
 */
fun _job_add e l=
    if l==nil then
        e::nil
    else
        (hd l)::_job_add e tl l
    ;;

/**
 * Execute a job
 */
fun _job_execute job=
    call job.f [];;

/**
 * Initialize a job
 */
fun job_start name f=
    let listlen _jobs -> n in
    let [n:n name:name f:f status:JobRun] -> job in (
        set _jobs = _job_add job _jobs
    )
    ;;

/**
 * Temporarily stop execution of a job
 */
fun job_suspend name=
    for l=_jobs;l!=nil; tl l do
        let hd l -> job in
            if !strcmp name job.name then
                set job.status = JobSuspend;
    0;;

/**
 * Resume execution of a suspended job
 */
fun job_resume name=
    for l=_jobs;l!=nil; tl l do
        let hd l -> job in
            if !strcmp name job.name then
                set job.status = JobRun;
    0;;

/**
 * Jobs loop
 */
fun job_loop=
    for l=_jobs;l!=nil; tl l do
        let hd l -> job in (
            match job.status with
                (JobRun -> _job_execute job) |
                (_ -> nil)
            );
    0;;

/**
 * Format a job in JSON format
 */
fun job_format_json job=
    strcatlist
        "{ "::
            (json_str "name" job.name) :: ", " ::
            (json_str "status" job_status job) ::
        " }" :: nil;;

/**
 * Return the jobs list in JSON format
 */
fun job_json=
    let "[\n" -> result in
    let listlen _jobs -> n in (
        for l=_jobs;l!=nil; tl l do
            let hd l -> job in
            let if nil!=tl l then ",\n" else "\n]" -> sep in
            set result = strcatlist result::(job_format_json job)::sep::nil;
        result
    );;
