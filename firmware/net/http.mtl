#include protos/http_protos.mtl

// debug
#ifdef HTTP_DEBUG
fun _http_debug str = Secholn strcatlist "[http] " :: str :: nil; nil;;
#endif

// type Httpreq contenant l'état d'une requête
//  - sonH : requête fille s'il y a (cas des 302 où on a fait une redirection via une nouvelle requête)
type Httpreq=[cnxH inputH outputH indexH http_req_cb typeH stateH aliveH sonH http_req_redir_depth];;

//## retourne le code réponse HTTP d'une réponse
//  - s est une chaine, le début de la réponse http
fun _http_get_code s =
	// le code est sur la première ligne, de type "HTTP/1.? XXX etc..." où XXX est le code
	let strstr s " " 0 -> i in
		let strstr s " " i -> j in
			atoi strsub s i+1 j ;;


//## gère le cas où on a reçu une 302 ("moved temporarly") en réponse
//  - cnx la socket de connection de _http_tcp_read
//  - httpreq la request qui nous dit qu'il faut forwarder
// On cherche la nouvelle Location, et on crée un fils à la requête courante.
fun _http_handle_tmp_redirect cnx httpreq =
	http_abort httpreq;
#ifdef HTTP_DEBUG
	_http_debug "HTTP - redirection temporaire";
#endif
	if (httpreq.http_req_redir_depth > 2) then // on arrive à la 3eme redirection, c'est trop
	(
#ifdef HTTP_DEBUG
        _http_debug "HTTP - trop de niveaux de redirection : stop";
#endif
        call httpreq.http_req_cb [httpreq nil];
        nil
    )
	else
		// reconstruire toute la chaine de réponse, elle ne doit pas être bien longue
		let strcatlist rev httpreq.inputH nil -> reponse in
		(
			let strstr reponse "\13\nLocation: " 0 -> i in
				if nil == i then // pas de location -> erreur
					(
#ifdef HTTP_DEBUG
						_http_debug "HTTP - Could not follow redirection, no 'Location:' found.";
#endif
						call httpreq.http_req_cb [httpreq nil] ;
						nil
					)
				else
					let strstr reponse "\13\n" (i+2) -> finloc in
					(
					let strsub reponse (i+12) (finloc-i-11) -> newurl in
					// ici on a l'url vers laquelle on veut rediriger dans newurl.
					(
#ifdef HTTP_DEBUG
						_http_debug "HTTP - Following redirection. new url [" ; _http_debug newurl; _http_debug "]";
#endif
						let http_request "GET" newurl nil httpreq.http_req_cb httpreq.typeH -> newReq in
						(
							set newReq.http_req_redir_depth = httpreq.http_req_redir_depth + 1;
							set httpreq.sonH = newReq;
							set httpreq.http_req_cb = nil
						);
					nil
					)
					)
		);
nil;;

proto time_parse_date 1;;
proto time_set 1;;
proto time_is_valid 0;;

/**
 * Extract the Date header from a HTTP response
 * res: the full HTTP response
 */
fun _http_get_date_from_header res=
    let to_lower http_get_header res -> header in
    let strstr header HTTP_DATE 0 -> i in
    let if i!=nil then (strlen HTTP_DATE) + (strstr header HTTP_DATE i) -> j in
    if i==nil then nil
    else strsub header j 25;;

// callback de lecture sur la socket d'une requête
fun _http_tcp_read cnx input httpreq=
	if input==nil ||0==strlen input then	// erreur ou fin
	(
        tcp_close cnx;	// on ferme la socket
		if httpreq.typeH==HTTP_NORMAL then
		(
			let rev httpreq.inputH nil -> l in
			let strcatlist l -> s in
			let _http_get_code s -> code in
				if code == 200 then
					let strcatlist rev httpreq.inputH nil -> res in	( // on retourne ce qui a été reçu
                        // if !time_is_valid then (
                        // Secholn _http_get_date_from_header res;
                        // time_set time_parse_date _http_get_date_from_header res
                        // );

					    call httpreq.http_req_cb [httpreq res]
                    )
				else if code == 302 then
					_http_handle_tmp_redirect nil httpreq
				else // 404 ? autre ?
					call httpreq.http_req_cb [httpreq nil]
		)
		else
			call httpreq.http_req_cb [httpreq nil] // HTTP_STREAM or HTTP_DIRECT
	)
	else
	(
//		dump input;
		set httpreq.aliveH=time_ms;
		if httpreq.typeH==HTTP_NORMAL then
			set httpreq.inputH=input::httpreq.inputH	// on bufferise ce qui a été reçu
		else if httpreq.typeH==HTTP_DIRECT then
		(
			call httpreq.http_req_cb [httpreq input];
			nil
		)
		else
		(
			let strcat hd httpreq.inputH input -> s in
			let strstr s "\13\10\13\10" 0 -> i in
			if i==nil then
				set httpreq.inputH=s::nil
			else
			(
				let _http_get_code s -> code in
				if code == 200 then
				(
					set httpreq.inputH=nil;
					set httpreq.typeH=HTTP_DIRECT;
					call httpreq.http_req_cb [httpreq strsub s 0 i];
					if i+4<strlen s then call httpreq.http_req_cb [httpreq strsub s i+4 nil];
					nil
				)
				else if code == 302 then
				(
					set httpreq.inputH = s::nil;
					_http_handle_tmp_redirect cnx httpreq;
					nil
				)
				else // 404 ? autre ?
				( call httpreq.http_req_cb [httpreq input]; nil )
			);
			nil
		);
		nil
	);;


// callback d'écriture sur la socket d'une requête
fun _http_tcp_write cnx httpreq=
	set httpreq.stateH=HTTP_STATE_CONNECTED;
	set httpreq.aliveH=time_ms;
	if httpreq.outputH!=nil then	// s'il y a des choses à envoyer (notamment la première fois)
	(
#ifdef HTTP_DEBUG
		_http_debug "_http_tcp_write";
#endif
		set httpreq.indexH=tcp_write cnx httpreq.outputH httpreq.indexH;	// envoyer ce qui peut l'être
		if httpreq.indexH==nil then	// si erreur lors de l'envoi
		(
            tcp_close cnx;	// on ferme la socket
			call httpreq.http_req_cb [httpreq nil]
        )	// on retourne nil
		else if httpreq.indexH>=strlen httpreq.outputH then	// sinon si tout a été envoyé
		(
            set httpreq.indexH=nil;	// purger les données d'émission
			set httpreq.outputH=nil;
			nil
		)
	);;


// découper une url en [host port path].
// host est de la forme ip:port
// path ne commence pas par /
fun _http_split_url url =
	if !strcmp (strsub url 0 strlen HTTP_DEF_PROTO) HTTP_DEF_PROTO then
        _http_split_url strsub url strlen HTTP_DEF_PROTO strlen url
	else let strstr url "/" 0 -> i in
		let if i==nil then url else strsub url 0 i -> addr in
		let strstr addr ":" 0 -> j in
		let if j==nil then [addr 80]
			else [strsub addr 0 j atoi strsub addr j+1 strlen addr] -> [host port] in
		let if i==nil then "/" else strsub url i strlen url -> path in
		[host port path];;


fun _http_tcp_event t val msg sock=
	if val==TCPWRITE then _http_tcp_write t sock
	else if val==TCPCLOSE then _http_tcp_read t nil sock
	else _http_tcp_read t msg sock;
	0;;


/**
 * Send an HTTP request to the given IP address
 * ip: target IP address
 * x: [port httpreq]
 */
fun _http_send_req ip x=
#ifdef HTTP_DEBUG
	_http_debug strcatlist "found ip=" :: ip :: nil;
#endif
	let x->[port httpreq] in
	if ip==nil then
    (
        call httpreq.http_req_cb [httpreq nil];
        nil
    )
	else
	(
		set httpreq.cnxH=tcp_open netip nil str_to_ip ip port fixarg4 #_http_tcp_event httpreq;
		set httpreq.stateH=HTTP_STATE_REACH;
		nil
	);
	0;;

/**
 * Create and send an HTTP request
 * verb: the HTTP verb to use (GET, POST, HEAD, etc.)
 * url: the URL to request (only http:// is supported)
 * postdata: additional data to send (nil if none)
 * cb: callback function to call when the request is done
 * type: type of request (HTTP_NORMAL, HTTP_STREAM, HTTP_DIRECT)
 */
fun http_request verb url postdata cb type=
#ifdef HTTP_DEBUG
	_http_debug strcatlist "HTTPREQUEST url=" :: url :: nil;
#endif
	let _http_split_url url ->[host port path] in	// décodage de l'url de la requête
	let if config_get_proxy then strcatlist "http://"::host::":"::(itoa port)::path::nil else path -> path in //Icy-MetaData:1\13\n
	let strcatlist verb :: " " :: path :: " HTTP/1.0\13\n" ::
            "User-Agent: Mozilla/5.0\13\n" ::
            "Accept: */*\13\n" ::
            "Host: "::host::"\13\n"::
            "Connection: close\13\n" ::
			if postdata==nil then "\13\n"::nil
			else "Content-length: "::(itoa strlen postdata)::"\13\n\13\n"::postdata::nil
		-> request in	// création de la chaîne requête
	let if config_get_proxy then ip_to_str config_get_proxy_ip else host -> host in
	let if config_get_proxy then config_get_proxy_port else port -> port in
	let [outputH:request indexH:0 http_req_cb:cb typeH:type stateH:HTTP_STATE_SOLVE aliveH:time_ms sonH:nil http_req_redir_depth:0] -> httpreq in	// création de la structure requête
	(
		if isip host 0 then _http_send_req host [port httpreq]
		else
		(
			dnsreq host fixarg2 #_http_send_req [port httpreq];
			nil
		);
		httpreq	// on retourne la structure requête pour pouvoir éventuellement l'interrompre en cours de route
	);;

//##> interruption d'une requête en cours
// on interromp la requête et son fils (si elle en a un)
fun http_abort httpreq=
	if (nil != httpreq.sonH) then http_abort httpreq.sonH;
	tcp_close httpreq.cnxH;;	// on ferme la socket de la requête

fun http_enable httpreq v=
	tcp_set_enabled httpreq.cnxH v;;

fun http_is_enabled httpreq=
	tcp_is_enabled httpreq.cnxH;;

fun http_state httpreq=
    httpreq.stateH;;

fun http_inactive httpreq=
    time_ms-httpreq.aliveH;;

/**
 * Return the header of a HTTP response
 * res: the full HTTP response
 */
fun http_get_header res=
	let strstr res HTTP_HEADER_SEP 0 -> i in
	if i==nil then res
	else strsub res 0 i+strlen HTTP_HEADER_SEP;;

/**
 * Return the content of a HTTP response (after the header)
 * res: the full HTTP response
 */
fun http_get_content res=
	let strstr res HTTP_HEADER_SEP 0 -> i in
	if i==nil then nil
	else strsub res i+strlen HTTP_HEADER_SEP strlen res;;

/**
 * Split a HTTP response into header and content
 * res: [header content]
 */
fun http_split_header_content res=
    let strstr res HTTP_HEADER_SEP 0 -> i in
    if i==nil then [res nil]
    else [strsub res 0 i+strlen HTTP_HEADER_SEP strsub res i+strlen HTTP_HEADER_SEP strlen res];;
