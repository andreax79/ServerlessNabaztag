#include protos/dhcp_protos.mtl
#include protos/dns_protos.mtl

const DHCP_DISCOVER=1;;
const DHCP_OFFER=2;;
const DHCP_REQUEST=3;;
const DHCP_DECLINE=4;;
const DHCP_ACK=5;;
const DHCP_NACK=6;;


/* 1 if the dhcp client is running */
var dhcp_client_started=0;;

/* the time when we received the lease */
var dhcp_lease_start=0;;

/* if 1, then the dhcp has been granted for an infinite time */
var dhcp_infinite_lease=0;;

/***
    According to the DHCP RFC (1541 and 2132), the leases are timed from
    the time of the request sending, and one should try to renew the lease
    with the previous host from t1 = (start_time+lease_duration*0.5) to t2 =
    (start_time+lease_duration*0.875). After t2, the dhcp request is to be
    asked to every reachable server (broadcasting).

    TODO for the moment only t1 is used and all messages are broadcasted
*/
var dhcp_lease_t1=0;;

// debug
#ifdef DHCP_DEBUG
fun _dhcp_debug str= Secholn strcatlist "[dhcp] " :: str :: nil; nil;;
#else
fun _dhcp_debug str= nil;;
#endif

//--------------------------------------------------------------------------------------------------
// DHCP CLient
//--------------------------------------------------------------------------------------------------

/**
 * Updates the var dhcp_lease_t1, that contains the time of the dhcp renewal time
 */
fun _dhcp_client_update_lease_time leaselen =
    if (leaselen == -1) then
    (
         set dhcp_infinite_lease = 1;
#ifdef DHCP_DEBUG
         _dhcp_debug "Infinite DHCP lease !";
#endif
        0
    )
    else
    (
        set dhcp_lease_t1 = dhcp_lease_start + leaselen/2;
#ifdef DHCP_DEBUG
        _dhcp_debug strcatlist "Next dhcp renewal in " :: (itoa (dhcp_lease_t1 -time )) :: "seconds"::nil;
#endif
        0
    );;

fun _dhcp_mk op netip hostip newip =
    let 236+16+14->n in
    let strnew n -> b in
    (
        for i=0;i<n do strset b  i 0;
        strcpy b 0 "\1\1\6" 0 3;
        strcpy b 12 netip 0 4;
        strcpy b 12+16 mymac 0 6;
        strcpy b 236 "\99\130\83\99\53\1" 0 6; // magic cookie + champ op
        strset b 236+6 op; // op
        strcpy b 236+7 "\61\7\1" 0 3; // id unique.
        strcpy b 236+10 mymac 0 6;    // id unique
        strcpy b 236+16 "\12\7Pabcdef\55\3\1\3\6" 0 14; // nom d'hote : Pabcdef. Options demandÃ©es en retour: 1 (masque de sous-reseau), 3 (addr routeur), 6 (addr dns)
        if op==DHCP_REQUEST then
            (strcatlist b:: ((if nil != hostip then strcatlist "\54\4"::hostip::nil else "")::(if nil != newip then strcatlist "\50\4"::newip::nil else "")::"\255"::nil))
        else
            (strcat b "\255")
    );;

/**
 * returns a list of the ip adresses contained in src from start to start + len
 */
fun _dhcp_extract_helper_dns_list src start len =
    if (len < 4) then
        nil
    else
        (strsub src start 4) :: (_dhcp_extract_helper_dns_list src (start+4) (len-4))
    ;;

fun _dhcp_extract src i type lease submask dnslist gateway mac=
    if i<strlen src then
    let strget src i -> c in
    if c==255 then [type lease submask dnslist gateway mac]
    else let strget src i+1 -> len in
    let i+2->i in
    if c==53 then _dhcp_extract src i+len (strget src i) lease submask dnslist gateway mac
    else if c==51 then _dhcp_extract src i+len type (strgetnum src i len) submask dnslist gateway mac
    else if c==1 then _dhcp_extract src i+len type lease (strsub src i 4) dnslist gateway mac
    else if c==6 then _dhcp_extract src i+len type lease submask (_dhcp_extract_helper_dns_list src i len) gateway mac
    else if c==3 then _dhcp_extract src i+len type lease submask dnslist (strsub src i 4) mac
    else if c==61 then _dhcp_extract src i+len type lease submask dnslist gateway (strsub src i+1 6)
    else _dhcp_extract src i+len type lease submask dnslist gateway mac;;

fun _dhcp_client_cb src macfrom hostip=
#ifdef DHCP_DEBUG
    Secholn "<dhcp"; MACecho macfrom 0 1;
#endif
    let strget src 0 -> x in
    let MACecho (strsub src 28 6)0 1 -> mac in
    if x==2 && !strcmp mac mymac then
    (
        let IPecho (strsub src 16 4) 0 1-> newip in
        let _dhcp_extract src 240 0 nil nil nil nil nil->[type lease submask dnslist gateway _] in
        if type==DHCP_OFFER then
        (
#ifdef DHCP_DEBUG
            _dhcp_debug ">>>>>>>>>>>>>>>OFFER";
#endif
            udp_send netip 68 ipbroadcast 67 (_dhcp_mk DHCP_REQUEST netip hostip newip) macbroadcast;
            nil
        )
        else if type==DHCP_ACK then
        (
#ifdef DHCP_DEBUG
            _dhcp_debug ">>>>>>>>>>>>>>>ACK";
            Secho "server    "; IPecho hostip 0 1;
            Secho "ip        "; IPecho set netip=newip 0 1;
            Secho "type      "; Iecholn type;
            Secho "leasetime "; Iecholn lease; _dhcp_client_update_lease_time lease;
            Secho "submask   "; IPecho set netmask=submask 0 1;
            Secho "dns       "; dns_list_from_dhcp dnslist; Secholn dns_list_to_str;
            Secho "gateway   "; IPecho set netgateway=gateway 0 1;
#endif
            nil
        )
        else if type==DHCP_NACK then
        (
            // TODO
#ifdef DHCP_DEBUG
            _dhcp_debug "DHCP_NACK";
#endif
            nil
        )
    );;

/**
 * Ask to renew the lease
 */
#ifndef SIMU
fun dhcp_client_renew=
    udp_send netip 68 ipbroadcast 67 (_dhcp_mk DHCP_REQUEST netip nil nil) macbroadcast;
    set dhcp_lease_start=time;
    if (0 != dhcp_lease_t1) then
        // if the request fails, try again in 10 seconds
        set dhcp_lease_t1=dhcp_lease_t1+10;
    nil;;
#endif

/**
 * Checks if the dhcp lease is about to expire and checks if the rabbit
 * should ask for a renewal
 */
#ifndef SIMU
fun _dhcp_client_job=
    if ((dhcp_client_started && dhcp_lease_t1 != 0 && time > dhcp_lease_t1 && !dhcp_infinite_lease)) then
        dhcp_client_renew;
    JobRun;;
#endif

/**
 * Starts a dhcp client if needed, sending a DHCP_DISCOVER request.
 * As the boot will have ran before, we should always already have done
 * a dhcp request during the boot and therefore already have a ip.
 */
fun dhcp_start_client=
#ifndef SIMU
#ifdef DHCP_DEBUG
    _dhcp_debug "dhcp_start_client";
#endif
    if (config_get_dhcp && !dhcp_client_started) then
    (
#ifdef DHCP_DEBUG
        _dhcp_debug "really do dhcp_start_client";
#endif
        regudp 68 #_dhcp_client_cb;
        if (!strcmp netip netip_empty) then
            udp_send netip 68 ipbroadcast 67 (_dhcp_mk DHCP_DISCOVER netip nil nil) macbroadcast
        else
            dhcp_client_renew;
        set dhcp_client_started=1;
        // Start the DHCP client job
        job_start "dhcp_client" #_dhcp_client_job
    );
#endif
    0;;

//--------------------------------------------------------------------------------------------------
// DHCP Server
//--------------------------------------------------------------------------------------------------

#ifdef WIFI_MASTER_MODE

fun _dhcp_server_make_ip mac=
    let strnew 4 -> s in
    (
        strcpy s 0 netip 0 4;
        strset s 3 ((strget mac 5)&0x7f)+100;
        s
    );;

fun _dhcp_server_make_ans op tid newip dmac=
    let 236+7->n in
    let strnew n -> b in
    (
        for i=0;i<n do strset b  i 0;
        strcpy b 0 "\2\1\6" 0 3;
        strcpy b 4 tid 0 4;
        strcpy b 16 newip 0 4;
        strcpy b 12+16 dmac 0 6;
        strcpy b 236 "\99\130\83\99\53\1" 0 6;
        strset b 236+6 op;
        strcatlist b::"\54\4"::newip::"\51\4\0\1\$51\$80\1\4"::netmask::"\3\4"::netip::"\6\4"::netip::"\15\4home\255"::nil
    );;

/**
 * DHCP server callback
 */
fun _dhcp_server_cb src macfrom hostip=
    Secholn "<dhcp"; MACecho macfrom 0 1;
    let strget src 0 -> x in
    let MACecho (strsub src 28 6)0 1 -> mac in
    if x==1 /*&& !strcmp mac mymac*/ then
    (
        let _dhcp_extract src 240 0 nil nil nil nil nil ->[type _ _ _ _ dmac] in
        let strsub src 4 4 -> tid in
        let _dhcp_server_make_ip macfrom -> newip in
        if type==DHCP_DISCOVER then
        (
            Secholn ">>>>>>>>>>>>>>>DISCOVER";
//          dump src;
            udp_send netip 67 ipbroadcast 68 (_dhcp_server_make_ans DHCP_OFFER tid newip dmac) macbroadcast;
            nil
        )
        else if type==DHCP_REQUEST then
        (
            Secholn ">>>>>>>>>>>>>>>REQUEST";
//          dump src;
            udp_send netip 67 ipbroadcast 68 (_dhcp_server_make_ans DHCP_ACK tid newip dmac) macbroadcast;
            nil
        )
    );;

/**
 * Starts a DHCP server
 */
fun dhcp_start_srv=
    regudp 67 #_dhcp_server_cb;
    0;;

#endif  // WIFI_MASTER_MODE
