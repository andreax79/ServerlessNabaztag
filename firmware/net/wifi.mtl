type Wifi=initW | gomasterW | masterW | gostationW _ | dhcpW _| stationW | reconnectW;;

// debug
#ifdef WIFI_DEBUG
fun _wifi_debug str= Secholn strcatlist "[wifi] " :: str :: nil; nil;;
#else
fun _wifi_debug str= nil;;
#endif

const RT2501_S_BROKEN=0;; // Device state: broken
const RT2501_S_IDLE=1;; // Device state: idle
const RT2501_S_SCAN=2;; // Device state: scanning for networks
const RT2501_S_CONNECTING=3;; // Device state: connecting to a network
const RT2501_S_CONNECTED=4;; // Device state: connected
const RT2501_S_MASTER=5;; // Device state: acting as master (access point)

const IEEE80211_M_MANAGED=0;; // Operation mode: managed (client)
const IEEE80211_M_MASTER=1;; // Operation mode: master (access point)

const IEEE80211_CRYPT_NONE=0;; // Encryption: none
const IEEE80211_CRYPT_WEP64=1;; // Encryption: WEP 64-bit
const IEEE80211_CRYPT_WEP128=2;; // Encryption: WEP 128-bit
const IEEE80211_CRYPT_WPA=3;; // Encryption: WPA
const IEEE80211_CRYPT_WPA_UNSUPPORTED=4;; // Encryption: WPA unsupported

const IEEE80211_AUTH_OPEN=0;; // Authentication type: open
const IEEE80211_AUTH_SHARED=1;; // Authentication type: shared key

var wifi;;
var _wifi_scans;;
var _wifi_master=0;; // 1 = master mode (access point), 0 = client mode (station)
var _wifi_retry_time;;
var _wifi_last_state;;

#include utils/utils.mtl
#include protos/dhcp_protos.mtl
#include protos/udp_protos.mtl
#include protos/dns_protos.mtl
#include protos/net_protos.mtl
#include protos/leds_protos.mtl
#include protos/config_protos.mtl
#include protos/json_protos.mtl

/**
 * Return true if the wifi is connected
 */
fun wifi_connected=
    netState == RT2501_S_CONNECTED;;

fun _wifi_scan_serialize l=
    if l!=nil then
    let hd l->[ssid mac bssid rssi channel rateset encryption] in
    ssid::"\0"::mac::bssid::(itoh4 rssi)::(itoh4 channel)::(itoh4 rateset)::(itoh4 encryption)::
    _wifi_scan_serialize tl l;;

fun wifi_scan_serialize l=
    (itoh4 listlen l)::_wifi_scan_serialize l;;

fun _wifi_dump_scan l0=
    _wifi_debug "## DUMPSCAN >>>>";
    for l=l0;l!=nil;tl l do
    let hd l->[ssid mac bssid rssi channel rateset encryption] in
    (
        _wifi_debug strcatlist "## SCAN " :: ssid :: nil;
        _wifi_debug strcatlist "mac: " :: (MAC_to_str mac 0 1) :: nil;
        _wifi_debug strcatlist "bssid: " :: (MAC_to_str bssid 0 1) :: nil;
        _wifi_debug strcatlist "rssi: " :: (itoa rssi) :: nil;
        _wifi_debug strcatlist "channel: " :: (itoa channel) :: nil;
        _wifi_debug strcatlist "rateset: " :: (itoa rateset) :: nil;
        _wifi_debug strcatlist "encryption: " :: (itoa encryption) :: nil;
        0
    );
    l0;;

fun _wifi_ssid_len s i=
    if i>=strlen s then i
    else if !strget s i then i
    else _wifi_ssid_len s i+1;;

fun _wifi_scan_unserialize s n i0=
    if n>0 then
    let _wifi_ssid_len s i0 -> j in
    let j+1->i in
    [
        strsub s i0 j-i0
        strsub s i 6
        strsub s i+6 6
        htoi strsub s i+12 8
        htoi strsub s i+20 8
        htoi strsub s i+28 8
        htoi strsub s i+36 8
    ]::_wifi_scan_unserialize s n-1 i+44;;

fun _wifi_scan_cmp_ssid a b=
    let a->[sa _ _ _ _ _ _] in
    let b->[sb _ _ _ _ _ _] in
    strcmp sa sb;;

fun wifi_init rescan=
    set _wifi_master = 0;
    let envget -> env in
    if env != nil then
    (
        leds_set_all RGB_GREEN;
        set mymac = netMac;
        set wifi = stationW;
		set netip = strsub env 0 4;
		set netmask = strsub env 4 4;
		set netgateway = strsub env 8 4;
		set netdnslist = nil; dns_add_new_srv (strsub env 12 4) 0;
		let htoi strsub env 16 8 -> nscan in
		set _wifi_scans = _wifi_scan_unserialize env nscan 24;

        envset nil;
        nil

    ) else (
        leds_set_all RGB_VIOLET;
        set wifi=initW;
        if rescan then set _wifi_scans=nil;
        if _wifi_master then
        (
            set netip=netip_master;
            set netmask=netmask_master;
            set netgateway=netgateway_master;
            0
        )
        else
        (
            if config_get_dhcp then set netip=netip_empty
            else
            (
                set netmask=config_get_netmask;
                set netgateway=config_get_net_gw;
                dns_add_new_srv config_get_net_dns 1;
                set netip=config_get_net_ip
            );
            0
        )
    );
    0;;


fun _wifi_by_ssid x v=
    let x->[s _ _ _ _ _ _] in (s!=nil)&& !strcmp v s;;

fun _wifi_wep_key val i len=
    if i<len then
    (htoi strsub val i 2)::_wifi_wep_key val i+2 len;;

fun wifi_wep_key val=
    let strlen val -> len in
    if len==5 || len==13 then val
    else let strreplace val ":" "" -> val in
    let if len<10 then 0 else if len<26 then 5 else 13 -> len in
    listtostr _wifi_wep_key val 0 len<<1;;

fun _wifi_crypt_type crypt key=
    if crypt==1 then if 5==strlen key then IEEE80211_CRYPT_WEP64 else IEEE80211_CRYPT_WEP128
    else if crypt==2 then IEEE80211_CRYPT_WPA
    else IEEE80211_CRYPT_NONE;;

fun _wifi_auth=
    leds_set_all RGB_AMBER;
    if _wifi_scans==nil then 0
    else
        let config_get_wifi_crypt -> crypt in
        let config_get_wifi_auth -> auth in
        let if crypt==1 then wifi_wep_key config_get_wifi_key0
            else if crypt==2 then config_get_wifi_pmk -> key in
            (
                dump key;
                netAuth hd _wifi_scans auth (_wifi_crypt_type crypt key) key;    //## ajouter les paramÃ¨tres de crypto
                1
            );;

fun wifi_check =
    if netState==RT2501_S_IDLE then
    match wifi with
    (initW -> nil)
    |(_ ->
        _wifi_debug "######### wifi lost";
        set wifi=reconnectW;
        ears_stop 1; // make sure that ears are not moving while we're reconnecting.
#ifdef WIFI_REBOOT_ON_LOST
        _wifi_debug "######### rebooting";
        reboot 0x0407FE58 0x13fb6754;
#endif
        0
    )
    ;;

fun wifi_job=
    let netState -> state in
    (
        if state!=_wifi_last_state then (
            _wifi_debug strcatlist "wifi state: " :: (itoa state) :: nil
        );
        let match wifi with
        (stationW -> nil)
        |(initW -> if state==RT2501_S_IDLE then
                (
                    set mymac=MAC_to_str netMac 0 1;
                    leds_set_all RGB_AMBER;
                    if _wifi_master then
                    (
                        _wifi_dump_scan set _wifi_scans=sort netScan nil #_wifi_scan_cmp_ssid;
                        netSetmode IEEE80211_M_MASTER (strcat "Nabaztag" ctoh strget mymac 5) 1;
                        _wifi_debug strcatlist mymac :: " -------------gomaster" :: nil;
                        gomasterW
                    )
                    else
                    (
                        if _wifi_scans==nil then
                        (
                            let config_get_wifi_ssid -> ssid in
                            let if strlen ssid then ssid else nil -> ssid in
                            let netScan ssid -> lscan in
                            let sort lscan #_wifi_scan_cmp_ssid -> l in
                            let if ssid==nil then l else select l ssid #_wifi_by_ssid-> l in
                            _wifi_dump_scan set _wifi_scans=l
                        );
                        if _wifi_auth then
                        (
                            _wifi_debug strcatlist config_get_wifi_ssid :: ":-------------gostation" :: nil;
                            gostationW [0 time]
                        )
                    )
                )
            )
        |(gomasterW -> if state==RT2501_S_MASTER then
                (
                    leds_set_all RGB_BLUE;
                    _wifi_debug "-------------master";
                    dhcp_start_srv;
                    masterW)
            )
        |(masterW -> if !_wifi_master then
                    (
                        wifi_init 1;
                        resetudp;
                        netSetmode IEEE80211_M_MANAGED nil 11;
                        nil)
            )
        |(gostationW x-> if wifi_connected then
                (
                    _wifi_debug "-------------dhcp";
                    if config_get_dhcp then dhcp_start_client;
                    dns_start_client;
                    dhcpW time
                )
            )
        |(dhcpW t-> if netip!=netip_empty then
                (
                    _wifi_debug "-------------station";
                    stationW
                )
                else if (time-t)>3 then // retry dhcp client
                (
                    dhcp_start_client;
                    dhcpW time
                )
            )
        |(reconnectW ->
            netSetmode IEEE80211_M_MANAGED nil 11;
            if _wifi_auth then
            (
                _wifi_debug strcatlist config_get_wifi_ssid :: ":-------------gostation" :: nil;
                gostationW [0 time]
            )
         )
        -> nwifi in
        if nwifi!=nil then set wifi=nwifi;
        set _wifi_last_state=state
    );
    if _wifi_retry_time!=time then
    (
        set _wifi_retry_time=time;
        nettime;
        dns_time;
        0
    );
    wifi_check;
    JobRun;;

/**
 * Return WIFI status as JSON
 */
fun wifi_json=
    strcatlist
        "{\n"::
            (json_str "mac" webmac netMac) :: ",\n" ::
            (json_int "master" _wifi_master) :: ",\n" ::
            (json_int "retry_time" _wifi_retry_time) :: ",\n" ::
            (json_int "last_state" _wifi_last_state) :: ",\n" ::
            (json_str "ssid" config_get_wifi_ssid) :: "\n" ::
        "}" :: nil
;;

#include net/dhcp.mtl
#include ipv4/udp.mtl
#include net/dns.mtl
#include net/net.mtl
#include hw/leds.mtl
#include utils/config.mtl
