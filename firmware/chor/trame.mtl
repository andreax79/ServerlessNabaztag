#include protos/trame_protos.mtl
#include protos/palette_protos.mtl
#include protos/info_protos.mtl
#include protos/ping_protos.mtl
#ifdef XMPP
#include protos/xmpp_protos.mtl
#endif

//--------------------------------------------------------------------------------------------------
// Trame
//--------------------------------------------------------------------------------------------------

// A trame contains frames
// Trame format:
//
// +------+-------+-------+-------+------+
// | 0x7F | frame | frame |  ...  | 0xFF |
// +------+-------+-------+-------+------+
//
// Frame format:
//
// +---------------+------------------+---------------------+
// | code (1 byte) | length (3 bytes) | data (length bytes) |
// +---------------+------------------+---------------------+
//
// Codes:
// 0-11: data blocks
// 0x03: change ping delay
// 0x04: update info (sources, messages, ears)
// 0x09: reboot
// 0x0A: program
// 0x0B: change mode (sleep/idle/interactive)
// 0xFF: end of trame
//
// Set ping delay
// +------+---------------------+
// | 0x03 | ping delay (1 byte) |
// +------+---------------------+

// Ambient info update

// Reboot
// +------+
// | 0x09 |
// +------+

// Program

// Change mode
// +------+------------------+
// | 0x0B | mode (1 byte)    |
// +------+------------------+
// mode: 0 = wake up, 1 = sleep

const TRAME_PREFIX = 0x7F;;
const TRAME_END = 0xFF;;
const TRAME_CODE_PING_DELAY = 0x03;;
const TRAME_CODE_INFO_UPDATE = 0x04;;
const TRAME_CODE_REBOOT = 0x09;;
const TRAME_CODE_PROGRAM = 0x0A;;
const TRAME_CODE_CHANGE_MODE = 0x0B;;

// debug
#ifdef TRAME_DEBUG
fun _trame_debug str= Secholn strcatlist "[program] " :: str :: nil; nil;;

fun _trame_dump_prgm l=
    _trame_debug "Program:";
    for l=l;l!=nil;tl l do let hd l->[key val] in (
        _trame_debug strcatlist ( key :: " " :: (if (val != nil) then val else "") :: nil)
    );
    _trame_debug "---";
    l;;
#endif

fun _trame_filter_config_word s=
    let strstr s " " 0 -> i in
    if i!=nil then [strsub s 0 i strsub s i+1 nil]
    else [s nil];;

fun _trame_filter_config_line s i=
    let strstr s "\10" i-> j in
    if j!=nil then (_trame_filter_config_word strsub s i j-i)::_trame_filter_config_line s j+1
    else if i<strlen s then (_trame_filter_config_word strsub s i nil)::nil;;

fun trame_filter_config s i0=
    let strreplace s "\13" "" -> s in
    _trame_filter_config_line s i0
;;

// ---------------------------------------------------------------------------

/**
 * Extract the frame length (3 bytes) from string s at position x
 */
fun _trame_extract_frame_length s x=
    ((strget s x)<<16)+((strget s x+1)<<8)+(strget s x+2);;


// aide pour la fonction _trame_extract_frames juste en dessous
fun _trame_extract_frame s i res=
    if i<strlen s then
        let (strget s i)-> trame_code in
        if trame_code == TRAME_END
            then res
        else
            if trame_code>=0 && trame_code<=11 then
                let _trame_extract_frame_length s i+1 -> len in
                if len>=0 then
                    _trame_extract_frame s i+4+len [trame_code strsub s i+4 len]::res;;


// parse la chaine s et renvoie une liste des commandes contenues dedans
fun _trame_extract_frames s=
    if (strget s 0)==TRAME_PREFIX then
        _trame_extract_frame s 1 nil;;


fun _trame_rsc_from_program l=
    if l!=nil then let hd l->[key val] in
    if (!strcmp key "MU") || (!strcmp key "CH") then [val /*nil*/300000]::_trame_rsc_from_program tl l
    else if (!strcmp key "MC") then [val TRAME_SIGN_CUT_SIZE]::_trame_rsc_from_program tl l
    else _trame_rsc_from_program tl l;;



var _trame_palette_selected = 0;;
// v17 (add romain)
// Fonction permettant d'activer la palette pour le programme en cours
// au jour du 31 mai 2007, on recoit le PL apres le son a jouer, la palette associee au son est donc affichee juste apres la fin du programme
// Cette fonction passe prealablement sur le programme reçu pour mettre la bonne palette
// A noter, si il y a plusieurs palettes dans la trame de retour, seule la premiere est prise en compte
fun _trame_check_for_palette_before l=
    for l=l;l!=nil;tl l do let hd l->[key val] in
    (
        if (!strcmp key "PL") && (_trame_palette_selected==0) then
        (
            palette_set_current_mode atoi val;
            set _trame_palette_selected = 1
        )
    );;

fun trame_program_start=
    // Starts playing the program

    // Si la palette est definie pour ce programme, alors on ne met pas l'aleatoire
    if(_trame_palette_selected==0) then (
        set palette_current=tabnew 0 8; // v17 : c'était inversé
        palette_set_current_mode 8 // random palette par défaut
    );
    // start evaluating first command
    set streaming_audio_cmd_index = -1;
    run_set_state cmdEvalOne 0;
    0;;

/**
 * Update sources, messages number and ears (old format)
 */
fun _trame_eval_info_update data=
#ifdef TRAME_DEBUG
    Secho "info_update OLD FORMAT:";
#endif
    let strlen data -> len in (
        // /14/80/0/0/0/0/0/0/0/0/0/0/0/0/0/0/14/13/0/
#ifdef TRAME_DEBUG
        Secho "len="; Iecho len; Secho ":";
        for i=0;i<len do (Iecho strget data i; Secho "/");
#endif
        // sources
        for i=0;i<(min 16 len) do set info_src.i=strget data i;

        // messages
        set info_messages = 0;
        if (len > 16+3) && (strget data (16+3)) then set info_messages = 2
        else if (len > 16+2) && (strget data (16+2)) then set info_messages = 1;

        // taichi
        let 0 -> found in
        for i=0;(i<(min 16 len) && !found);i+2 do
        if ((strget data i) == 14) then (
            set info_taichi = strget data i+1;
            set found = 1
        );

        // process ears
        if len > 17 then
        let strget data 16 -> newleft in
        let strget data 17 -> newright in
        if (newleft != nil || newright != nil) && ((newleft!=ears_left) || (newright!=ears_right)) then (
            set ears_left=newleft;
            set ears_right=newright;
            if ((!sleep_is_sleeping) && (!ears_resetting)) then (
                midi_play MIDI_COMMUNION;
                ears_go_to_ref_pos
            )
        )

    );
    0;;

/**
 * Update sources, messages number and ears (new format)
 */
fun _trame_eval_info_update_v2 data=
#ifdef TRAME_DEBUG
    Secho "info_update_v2:";
#endif
    let 0 -> i in
    let nil -> newleft in
    let nil -> newright in (
        while (i < strlen data) do (
            let strget data i -> key in
            let strget data i+1 -> val in (
#ifdef TRAME_DEBUG
                Secho "key:"; Iecho key; Secho "="; Iecho val; Secho ",";
#endif
                if key == 8 then set info_messages = val
                else if key == 0 then info_src_del val
                else if key == INFO_WEATHER || key == INFO_STOCK || key == INFO_TRAFFIC || key == INFO_MAIL || key == INFO_POLLUTION then info_src_update key val
                else if key == 4 then set newleft = val
                else if key == 5 then set newright = val
                else if key == 14 then set info_taichi = val
                else (
#ifdef TRAME_DEBUG
                    Secho "ERROR info_update_v2 unknown key="; Iecholn key;

#endif
                    0
                )
            );
            set i = i + 2
        );
        // process ears
#ifdef TRAME_DEBUG
        Secho "newleft="; Iecho newleft; Secho "newright="; Iecho newright; Secho "ears_left="; Iecho ears_left; Secho "ears_right="; Iecho ears_right;
        Secho "sleep_is_sleeping="; Iecho sleep_is_sleeping; Secho "ears_resetting="; Iecho ears_resetting;
        Secholn "";
#endif
        if (newleft != nil || newright != nil) && ((newleft!=ears_left) || (newright!=ears_right)) then (
            set ears_left=newleft;
            set ears_right=newright;
            if ((!sleep_is_sleeping) && (!ears_resetting)) then
                ears_go_to_ref_pos
        )
    );
    0;;

/**
 * Initialize a program
 */
fun _trame_initialize_program program=
    set _trame_palette_selected = 0;
    set streaming_current_program = program;
    set chor_processing_status = 1;
    set chor_processing_wait_status = 0;
    _trame_check_for_palette_before program; // Permet de mettre la palette correspondante au programme, v17 (add romain)
    // resources
    set trame_remaining_resources=_trame_rsc_from_program program;
    // empties the rsc cache
    set streaming_rsc_loaded=nil;
    let hd trame_remaining_resources -> [url _] in
    if url==nil then (
        // no resources to load : start the program now
        trame_program_start;
        0
    ) else (
        // will load trame_remaining_resources and then start the program 'streaming_current_program'
#ifdef TRAME_DEBUG
        _trame_debug "loading rsrcs...";
#endif
        run_set_state rscLoadNextRun;
        0
    );;

/**
 * Process ping delay command
 */
fun _trame_cmd_ping_delay val=
#ifdef PING
    set ping_delay = strget val 0;
#endif
    nil;;

/**
 * Process ambient info command
 * Update sources, messages number and ears
 */
fun _trame_cmd_info_update val=
    let ((strget val 3) == 0xFF) -> is_from_http in
    if is_from_http then
        // old format
        _trame_eval_info_update strsub val 4 nil
    else
        // new format
        _trame_eval_info_update_v2 strsub val 4 nil;
    nil;;

/**
 * Process reboot command
 */
fun _trame_cmd_reboot val=
    reboot 0x0407FE58 0x13fb6754;
    nil;;

/**
 * Process program command
 */
fun _trame_cmd_program val=
    uncrypt val 1 nil 0x47 47;
#ifdef TRAME_DEBUG
    _trame_dump_prgm trame_filter_config val 1;;
#else
    trame_filter_config val 1;;
#endif

/**
 * Process change mode command
 */
fun _trame_cmd_change_mode val=
    let strget val 0 -> mode in (
#ifdef TRAME_DEBUG
        Secho "changemode = "; Iecholn mode;
#endif
        if (mode == 0) then
            sleep_wake_up nil
        else if (mode == 1) then
            sleep_start nil
        else
            nil
    );;


// ******************************************
// Main function : evaluate trame
// trames are sent back from ping and itmode
// In program frames, programs can contain url resources: resources are loaded and stored and then program is executed

fun trame_eval ping_trame=
    let _trame_extract_frames dump ping_trame -> frame_list in
    if frame_list==nil then (
        // error, bad trame
#ifdef TRAME_DEBUG;
        _trame_debug "bad trame";
        dump ping_trame;
        _trame_debug "dropping";
#endif
        if (interactive_status) then (
            // display error
            interactive_error;
            nil
        ) else (
            // drop, and ping again later
            run_set_state idleRun;
            nil
        )
    ) else
        // frame_list ok
        let nil->program in
        (
            for l=frame_list;l!=nil;tl l do let hd l-> [code val] in
            (
                if code == TRAME_CODE_PING_DELAY then
                    _trame_cmd_ping_delay val
                else if code == TRAME_CODE_INFO_UPDATE then
                    _trame_cmd_info_update val
                else if code == TRAME_CODE_REBOOT then
                    _trame_cmd_reboot val
                else if code == TRAME_CODE_PROGRAM then (
                    set program=_trame_cmd_program val;
                    nil
                ) else if code == TRAME_CODE_CHANGE_MODE then
                    _trame_cmd_change_mode val
                else (
#ifdef TRAME_DEBUG
                    Secho "Unknown code "; Iecholn code;
#endif
                    nil
                )
            );
            // post process : a program ?
            if program!=nil then
                _trame_initialize_program program
        );;


//*******************
// Trames queue

#ifdef XMPP
fun trame_is_resource_valid rsrcName=
    // les règles d'adéquation entre resource et etats
    if (!strcmp rsrcName "urgent") then 1 // tjrs
    else if (!strcmp rsrcName "sources") then 1 // tjrs
    else if (!strcmp rsrcName "boot") then 1 // tjrs
    else if (streaming_status) then (if (!strcmp rsrcName "streaming") then 1 else 0)
    else if (interactive_status) then (if (!strcmp rsrcName "itmode") then 1 else 0)
    else if (sleep_is_sleeping) then (if (!strcmp rsrcName "asleep") then 1 else 0)
    else if (chor_processing_status) then 0
    else 1;;

fun _trame_queue_remove_entry binome=
    // dépile
    set trame_queue = remfromlist trame_queue binome;

    // was full ?
    let listlen trame_queue -> queueLen in
    if queueLen == TRAME_QUEUE_MAXLEN-1 then (
#ifdef TRAME_DEBUG
        _trame_debug "trame queue not full anymore, warning server";
#endif
        set xmpp_busy_status = 0;
        // which resource now ? Can be in this order asleep, streaming, itmode or idle
        if (sleep_is_sleeping) then XmppSessionRequestResource "asleep"
        else if (streaming_status) then XmppSessionRequestResource "streaming"
        else if (interactive_status) then XmppSessionRequestResource "itmode"
        else XmppSessionRequestResource "idle"
    );
    0;;

fun trame_get_next_pending=
    let trame_queue -> ptr in
    let nil -> theTrame in (
        while ((theTrame == nil) && ((hd ptr) != nil)) do (
            let hd ptr -> binome in
            let binome -> [rsrc expiration_time ping_trame] in
            if ((expiration_time != nil) && (time >= expiration_time)) then (
#ifdef TRAME_DEBUG
                _trame_debug "trame expired, removing";
#endif
                _trame_queue_remove_entry binome

            ) else if (trame_is_resource_valid rsrc) then (
                // ok
                set theTrame = ping_trame;

                _trame_queue_remove_entry binome
            );

            // next
            set ptr = tl ptr
        );
        theTrame
    )
    ;;
#endif
