#include protos/json_protos.mtl
#include protos/sleep_protos.mtl
#include protos/midi_protos.mtl
#include protos/task_protos.mtl
#include protos/info_protos.mtl

// gestion des services

// _info_data : les definitions des animations visuelles des services (meteo, traffic, etc..)
// Table de animations { <animation_service_0> <animation_service_1> ... <animation_service_N> }
// animations = tableau de N animations, une par valeur du service. Animation = tuple = [tempo <couleurs>]
// couleurs = X fois 3 couleurs pour les 3 leds du ventre (led 1, 2, 3)
// couleur = index dans le tableau 'info_palette'
// tempo = 0.5*log2 du nombre d'itérations à durer sur la couleur courante (ex : tempo = 3, durée = 16 itérations)
var _info_data = {
// 0 meteo
{
    [40 {0 3 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3}] // sun
    [125 {0 3 8 0 8 8 8 8 0 8 3 8 0 8 8 8 8 0 8 3 0}] // clouds
    [200 {8 4 4 8 8 4 4 8 8 4 4 8 4 4 4 4 4 4}] // fog
    [20 {0 0 0 0 4 0 4 0 4 0 0 0 0 0 4 4 0 0 0 0 0 0 4 0 0 0 4}] // rain
    [40 {7 0 0 0 0 0 0 0 7 0 0 0 0 6 0 0 0 0 0 0 6 0 0 0 0 7 0 0 0 0 6 0 0 0 0 0}] // snow
    [25 {0 4 3 0 0 0 0 0 0 0 0 0 0 0 0 4 3 0 0 4 3 0 0 0 0 0 0 0 3 4 3 4 0}] // storm
}
// 1 bourse
{
    [7 {0 0 11 0 11 0 11 0 0 0 0 0 0 0 0 0 0 0}]
    [14 {0 0 11 0 11 0 11 0 0 0 0 0}]
    [28 {0 0 11 0 11 0 11 0 0 0 0 0}]
    [28 {0 11 0 0 0 0}]
    [28 {11 0 0 0 11 0 0 0 11 0 0 0}]
    [14 {11 0 0 0 11 0 0 0 11 0 0 0}]
    [7 {11 0 0 0 11 0 0 0 11 0 0 0 0 0 0 0 0 0}]
}
// 2 traffic
{
    [100 {1 0 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0}]
    [100 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [50 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [25 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [12 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [8 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [4 {0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0}]
}
// 3 nil
nil
// 4 nil
nil
// 5 mails
{
    [70 {5 0 0 0 5 0 0 0 5 0 5 0}]
    [56 {0 5 0 0 0 0}]
    [56 {5 0 5 0 0 0}]
    [56 {5 5 5 0 0 0}]
}
// 6 pollution
{
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
    [14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
    [14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
    [14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
    [14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
    [14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
}
};;

// v21 : changé couleur jaune clair (11) de 0xffff80 à 0xffcc00 (bug 197)
var info_palette={
//    0:black  1:red    2:green  3:yellow 4:blue   5:violet 6:cyan   7:white
    0x000000 0xff0000 0x00ff00 0xffff00 0x0000ff 0xff00ff 0x00ffff 0xffffff
//    8:gray   9:rose  10:lt gr 11:lt yel 12:lt bl 13:lt vio 14:lt cy 15:orange
    0x808080 0xff8080 0x80ff80 0xffcc00 0x8080ff 0xff80ff 0x80ffff 0xff8000
};;

// heure de démarrage du service courant
var _info_start_time;;
// index du service courant (dans info_src)
var _info_index=0;;
// type du service courant
var info_type;;
// valeur du service courant
var _info_current_val;;
// index de la couleur dans le tableau des couleurs de l'animation courante
var _info_current_color_index;;
// Date de démarrage de la couleur..
var _info_start_ms;;
// durée de la couleur...
var _info_color_duration;;

// durée d'affichage d'un service, en secondes
const INFO_TIMEOUT=15;;

/**
 * Info task
 */
fun info_task task=
    match run_get_state with
    ( idleRun -> info_run )|
#ifdef PING
    ( pingwaitRun _ -> if ping_current_trame_id != RUN_MSG_ASLEEP then info_run )|
    ( stdWaitRun _ -> if ping_current_trame_id != RUN_MSG_ASLEEP then info_run )|
#endif
#ifdef XMPP
    ( xmppReconnectRun params -> info_run )|
#endif
    ( rscLoadNextRun -> info_run )|
    ( rscLoadWaitRun _ -> info_run )|
    ( interactiveReqWaitRun http -> info_run );
    TaskRun;;

/**
 * Initialize and start the info task
 */
fun info_init=
    set info_src=tabnew 0 16; // 8 services [type,val] x 8
    // Start the info task
    task_start "info" #info_task;;

/**
 * Get animations for info type
 */
fun _info_get_animations info_type=
    _info_data.info_type;;

// retourne le prochain index utile (info_type non nul)
fun _info_next_index i=
    let i+2-> i in
    if i>=16 then 0 else if info_src.i then i else _info_next_index i;;

// le service suivant
fun _info_start_one i=
    set _info_index= i;
    set info_type=(info_src.(_info_index))-1;
    set _info_current_val=info_src.(_info_index+1);
    set _info_start_time=time;
    set _info_current_color_index=0;
    set _info_start_ms=time_ms;
    let _info_get_animations info_type -> anims in
    if anims==nil then set _info_start_time=nil
    else let anims._info_current_val ->[dur _] in set _info_color_duration= dur*10;
    0;;

fun _info_next=
    _info_start_one (_info_next_index _info_index);
    0;;

/**
 * Return _info_src as JSON
 */
fun _info_src_json=
    let nil -> result in (
        for i=0;i<16 do
            let info_src.(i*2) -> key in
            let info_src.(i*2+1) -> val in (
                if key == INFO_WEATHER then set result = (json_int "weather" val) :: ",\n" :: result
                else if key == INFO_STOCK then set result = (json_int "stock" val) :: ",\n" :: result
                else if key == INFO_TRAFFIC then set result = (json_int "traffic" val) :: ",\n" :: result
                else if key == INFO_MAIL then set result = (json_int "emails" val) :: ",\n" :: result
                else if key == INFO_POLLUTION then set result = (json_int "pollution" val) :: ",\n" :: result
            );
        strcatlist result
    );;

/**
 * Return info as JSON
 */
fun info_json=
    strcatlist
        "{\n"::
            _info_src_json ::
            (json_int "messages" info_messages) :: "\n" ::
        "}" :: nil;;

fun info_run=
    if (!sleep_is_sleeping && !interactive_status && !ears_detecting) then // no info while sleeping and while in interactive mode
    (
        // passage au service suivant ?
        set info_type=(info_src.(_info_index))-1;
        if _info_start_time==nil || (time-_info_start_time>INFO_TIMEOUT) || info_type<0 then _info_next;

        // couleurs des 3 leds du ventre (service courant/animation courante/couleur courante)
        set info_type=(info_src.(_info_index))-1;
        set _info_current_val=info_src.(_info_index+1);
        let _info_get_animations info_type -> anims in
        let anims._info_current_val ->[dur anime] in
        if anime!=nil then
        (
            led LED_BODY_LEFT info_palette.(anime._info_current_color_index);
            led LED_BODY_MIDDLE info_palette.(anime.(1+_info_current_color_index));
            led LED_BODY_RIGHT info_palette.(anime.(2+_info_current_color_index));
            if (time_ms-_info_start_ms >= _info_color_duration) then
            (
                // next colors
                set _info_current_color_index=_info_current_color_index+3;
                set _info_start_ms=time_ms;
                set _info_color_duration=dur*10;
                if _info_current_color_index>=tablen anime then set _info_current_color_index=0
            )
        )
        else
        (
            led LED_BODY_LEFT RGB_BLACK;
            led LED_BODY_MIDDLE RGB_BLACK;
            led LED_BODY_RIGHT RGB_BLACK
        )
    );;

// util : slide tableau pour effacer case vide
fun _info_slide i=
    if (i == 16-2) then (
        set info_src.i = 0;
        set info_src.(i+1) = 0
    ) else (
        set info_src.i = info_src.(i+2);
        set info_src.(i+1) = info_src.(i+3);
        // recurse
        if (info_src.i > 0) then _info_slide i+2
    );;

// enlève cette source de la liste
fun __info_src_del key i=
    if (i < 16) then
    if (info_src.i == key) then (
        // delete
        _info_slide i
    ) else __info_src_del key i+2;;

/**
 * Delete info source
 * key: 1=weather, 2=stock, 3=traffic, 6=emails, 7=pollution
 */
fun info_src_del key=
    __info_src_del key 0;;

/**
 * Update info source
 * key: 1=weather, 2=stock, 3=traffic, 6=emails, 7=pollution
 * val: value of the source (or key to delete if key=0)
 */
fun info_src_update key val=
    // allow for deletion
    if key == 0 then
        info_src_del val
    else
        let nil -> res in
            for i=0;(i<16)&&(res==nil);i+2 do
                if (info_src.i == 0 || info_src.i == key) then (
                    set res = i;
                    set info_src.(i+1) = val;
                    if (info_src.i == 0) then (
                        // add
                        set info_src.i = key;
                        // set lapin to play this new one now
                        _info_start_one i
                    )
                );;

/**
 * Get info source value
 * key: 1=weather, 2=stock, 3=traffic, 6=emails, 7=pollution
 */
fun info_src_get key=
    let nil -> res in (
        for i=0;(i<16)&&(res==nil);i+2 do
            if info_src.i == key then
                set res = info_src.(i+1);
        res
    );;
