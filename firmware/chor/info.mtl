#include protos/json_protos.mtl
#include protos/sleep_protos.mtl
#include protos/midi_protos.mtl
#include protos/task_protos.mtl
#include protos/info_protos.mtl

// gestion des services

// _info_data : les definitions des animations visuelles des services (meteo, traffic, etc..)
// Liste de tuples. Un tuple = [<type de service> <animations>]
// animations = tableau de N animations, une par valeur du service. Animation = tuple = [tempo <couleurs>]
// couleurs = X fois 3 couleurs pour les 3 leds du ventre (led 1, 2, 3)
// couleur = index dans le tableau 'INFO_PALETTE'
// tempo = 0.5*log2 du nombre d'itérations à durer sur la couleur courante (ex : tempo = 3, durée = 16 itérations)
var _info_data;;

// info_src : les services courants affichés par ce lapin (envoyé par le serveur et mis à jour par le fonction 'info_update')
// Un tableau de 16 valeurs, pour les services courants. 2 valeurs par service donc 8 services max.
// 2 valeurs par service : la première valeur vaut 1+info_type (ex : 1 pour meteo), la deuxième vaut infoVal, la valeur du service (ex : 0 pour soleil)
var info_src;;

/**
 * Info task
 */
fun info_task task=
    match run_get_state with
    ( idleRun -> info_run )|
#ifdef PING
    ( pingwaitRun http -> if ping_current_trame_id!=RUN_MSG_ASLEEP then info_run )|
    ( stdWaitRun t -> if ping_current_trame_id != RUN_MSG_ASLEEP then info_run )|
#endif
#ifdef XMPP
    ( xmppReconnectRun params -> info_run )|
#endif
    ( rscLoadNextRun -> info_run )|
    ( rscLoadWaitRun http-> info_run )|
    ( interactiveReqWaitRun http -> info_run );
    TaskRun;;

/**
 * Initialize and start the info task
 */
fun info_init=
    set info_src=tabnew 0 16;

    set _info_data=
[0 // meteo
{
    [40 {0 3 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3}] // sun
    [125 {0 3 8 0 8 8 8 8 0 8 3 8 0 8 8 8 8 0 8 3 0}] // clouds
    [200 {8 4 4 8 8 4 4 8 8 4 4 8 4 4 4 4 4 4}] // fog
    [20 {0 0 0 0 4 0 4 0 4 0 0 0 0 0 4 4 0 0 0 0 0 0 4 0 0 0 4}] // rain
    [40 {7 0 0 0 0 0 0 0 7 0 0 0 0 6 0 0 0 0 0 0 6 0 0 0 0 7 0 0 0 0 6 0 0 0 0 0}] // snow
    [25 {0 4 3 0 0 0 0 0 0 0 0 0 0 0 0 4 3 0 0 4 3 0 0 0 0 0 0 0 3 4 3 4 0}] // storm
}
]::
[1 // bourse
{
    [7 {0 0 11 0 11 0 11 0 0 0 0 0 0 0 0 0 0 0}]
    [14 {0 0 11 0 11 0 11 0 0 0 0 0}]
    [28 {0 0 11 0 11 0 11 0 0 0 0 0}]
    [28 {0 11 0 0 0 0}]
    [28 {11 0 0 0 11 0 0 0 11 0 0 0}]
    [14 {11 0 0 0 11 0 0 0 11 0 0 0}]
    [7 {11 0 0 0 11 0 0 0 11 0 0 0 0 0 0 0 0 0}]
}
]::
[2 // traffic
{
    [100 {1 0 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0}]
    [100 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [50 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [25 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [12 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [8 {0 1 0 1 0 1 0 0 0 0 0 0 0 0 0}]
    [4 {0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 0}]
}
]::
[5 // mails
{
    [70 {5 0 0 0 5 0 0 0 5 0 5 0}]
    [56 {0 5 0 0 0 0}]
    [56 {5 0 5 0 0 0}]
    [56 {5 5 5 0 0 0}]
}
]::
[6 // pollution
{
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [42 {6 6 6 6 6 6 6 6 6 0 0 0}]
    [14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
    [14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
    [14 {0 6 6 6 6 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 0 6 0 0 0 0 6 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 6 6}]
    [14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
    [14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
    [14 {0 6 0 0 6 6 6 6 6 6 0 0 0 0 0 0 6 0 0 6 6 0 0 0 6 6 0 6 6 6 0 0 6 6 0 0 0 6 0 0 0 0 6 0 6 0 6 0}]
}
]::
nil;
    // Start the info task
    task_start "info" #info_task;;


// v21 : changé couleur jaune clair (11) de 0xffff80 à 0xffcc00 (bug 197)
const INFO_PALETTE={
//    0:black  1:red    2:green  3:yellow 4:blue   5:violet 6:cyan   7:white
    0x000000 0xff0000 0x00ff00 0xffff00 0x0000ff 0xff00ff 0x00ffff 0xffffff
//    8:gray   9:rose  10:lt gr 11:lt yel 12:lt bl 13:lt vio 14:lt cy 15:orange
    0x808080 0xff8080 0x80ff80 0xffcc00 0x8080ff 0xff80ff 0x80ffff 0xff8000
};;


// heure de démarrage du service courant
var _info_start_time;;
// index du service courant (dans info_src)
var _info_index=0;;
// type du service courant
var info_type;;
// valeur du service courant
var infoVal;;
// index de la couleur dans le tableau des couleurs de l'animation courante
var infoAnimColori;;
// Date de démarrage de la couleur..
var infoAnimColorStart;;
// durée de la couleur...
var infoAnimColorDur;;

// durée d'affichage d'un service, en secondes
const INFO_TIMEOUT=15;;

fun _info_get_animations info_type=
    listswitch _info_data info_type;;

// retourne le prochain index utile (info_type non nul)
fun _info_next_index i=
    let i+2-> i in
    if i>=16 then 0 else if info_src.i then i else _info_next_index i;;

// le service suivant
fun _info_start_one i=
    set _info_index= i;
    set info_type=(info_src.(_info_index))-1;
    set infoVal=info_src.(_info_index+1);
    set _info_start_time=time;
    set infoAnimColori=0;
    set infoAnimColorStart=time_ms;
    let _info_get_animations info_type -> anims in
    if anims==nil then set _info_start_time=nil
    else let anims.infoVal ->[dur _] in set infoAnimColorDur= dur*10;
    0;;

fun _info_next=
    _info_start_one (_info_next_index _info_index);
    0;;

/**
 * Return _info_src as JSON
 */
fun _info_src_json=
    let nil -> result in (
        for i=0;i<16 do
            let info_src.(i*2) -> key in
            let info_src.(i*2+1) -> val in (
                if key == INFO_WEATHER then set result = (json_int "weather" val) :: ",\n" :: result
                else if key == INFO_STOCK then set result = (json_int "stock" val) :: ",\n" :: result
                else if key == INFO_TRAFFIC then set result = (json_int "traffic" val) :: ",\n" :: result
                else if key == INFO_MAIL then set result = (json_int "emails" val) :: ",\n" :: result
                else if key == INFO_POLLUTION then set result = (json_int "pollution" val) :: ",\n" :: result
            );
        strcatlist result
    );;

/**
 * Return info as JSON
 */
fun info_json=
    strcatlist
        "{\n"::
            _info_src_json ::
            (json_int "messages" info_messages) :: ",\n" ::
            (json_int "taichi" info_taichi) :: "\n" ::
        "}" :: nil;;

fun info_run=
    if (!sleep_is_sleeping && !interactive_status && !ears_detecting) then // no info while sleeping and while in interactive mode
    (
        // passage au service suivant ?
        set info_type=(info_src.(_info_index))-1;
        if _info_start_time==nil || (time-_info_start_time>INFO_TIMEOUT) || info_type<0 then _info_next;

        // Allumage de la tête en verde si message(s) en attente (info_messages)
        let (time_ms>>8)&7 -> t in
        let if (((info_messages>3) && (t==7)) ||
                ((info_messages>2) && (t==5)) ||
                ((info_messages>1) && (t==3)) ||
                ((info_messages>0) && (t==1))) then RGB_GREEN else RGB_BLACK -> color in
            led LED_NOSE color;

        // couleurs des 3 leds du ventre (service courant/animation courante/couleur courante)
        set info_type=(info_src.(_info_index))-1;
        set infoVal=info_src.(_info_index+1);
        let _info_get_animations info_type -> anims in
        let anims.infoVal ->[dur anime] in
        if anime!=nil then
        (
            led LED_BODY_LEFT INFO_PALETTE.(anime.infoAnimColori);
            led LED_BODY_MIDDLE INFO_PALETTE.(anime.(1+infoAnimColori));
            led LED_BODY_RIGHT INFO_PALETTE.(anime.(2+infoAnimColori));
            if (time_ms-infoAnimColorStart >= infoAnimColorDur) then
            (
                // next colors
                set infoAnimColori=infoAnimColori+3;
                set infoAnimColorStart=time_ms;
                set infoAnimColorDur= dur*10;
                if infoAnimColori>=tablen anime then set infoAnimColori=0
            )
        )
        else
        (
            led LED_BODY_LEFT RGB_BLACK;
            led LED_BODY_MIDDLE RGB_BLACK;
            led LED_BODY_RIGHT RGB_BLACK
        )
    );;

// util : slide tableau pour effacer case vide
fun _info_slide i=
    if (i == 16-2) then (
        set info_src.i = 0;
        set info_src.(i+1) = 0
    ) else (
        set info_src.i = info_src.(i+2);
        set info_src.(i+1) = info_src.(i+3);
        // recurse
        if (info_src.i > 0) then _info_slide i+2
    );;

// enlève cette source de la liste
fun __info_src_del key i=
    if (i < 16) then
    if (info_src.i == key) then (
        // delete
        _info_slide i
    ) else __info_src_del key i+2;;

fun _info_src_del key=
    __info_src_del key 0;;

// met à jour ou rajoute cette source
fun _info_src_update key val i=
    if (i < 16) then
    if (info_src.i == 0 || info_src.i == key) then (
        // add or update
        set info_src.(i+1) = val;
        if (info_src.i == 0) then (
            // add
            set info_src.i = key;
            // set lapin to play this new one now
            _info_start_one i
        )
    ) else _info_src_update key val i+2;; // recurse

/**
 * Update info source
 * key: 1=weather, 2=stock, 3=traffic, 6=emails, 7=pollution
 * val: value of the source (or key to delete if key=0)
 */
fun info_src_update key val=
    Secho "info_src_update key: "; Iecho key; Secho " val: "; Iecholn val;
    // allow for deletion
    if key == 0 then _info_src_del val
    else _info_src_update key val 0;;


/**
 * Update sources, messages number and ears (old format)
 */
fun info_update data=
    Secho "info_update OLD FORMAT:";
    let strlen data -> len in (
        // /14/80/0/0/0/0/0/0/0/0/0/0/0/0/0/0/14/13/0/
        Secho "len="; Iecho len; Secho ":";
        for i=0;i<len do (Iecho strget data i; Secho "/");

        // sources
        for i=0;i<(min 16 len) do set info_src.i=strget data i;

        // messages
        set info_messages = 0;
        if (len > 16+3) && (strget data (16+3)) then set info_messages = 2
        else if (len > 16+2) && (strget data (16+2)) then set info_messages = 1;

        // taichi
        let 0 -> found in
        for i=0;(i<(min 16 len) && !found);i+2 do
        if ((strget data i) == 14) then (
            set info_taichi = strget data i+1;
            set found = 1
        );

        // process ears
        if len > 17 then
        let strget data 16 -> newleft in
        let strget data 17 -> newright in
        if (newleft != nil || newright != nil) && ((newleft!=ears_left) || (newright!=ears_right)) then (
            set ears_left=newleft;
            set ears_right=newright;
            if ((!sleep_is_sleeping) && (!ears_resetting)) then (
                midi_play MIDI_COMMUNION;
                ears_go_to_ref_pos
            )
        )

    );
    0;;

/**
 * Update sources, messages number and ears (new format)
 */
fun info_update_v2 data=
    Secho "info_update_v2:";
    let 0 -> i in
    let nil -> newleft in
    let nil -> newright in (
        while (i < strlen data) do (
            let strget data i -> key in
            let strget data i+1 -> val in (
                Secho "key:"; Iecho key; Secho "="; Iecho val; Secho ",";
                if key == 8 then set info_messages = val
                else if key == 0 then _info_src_del val
                else if key == 1 || key == 2 || key == 3 || key == 6 || key == 7 then info_src_update key val
                else if key == 4 then set newleft = val
                else if key == 5 then set newright = val
                else if key == 14 then set info_taichi = val
                else (
                    Secho "ERROR info_update_v2 unknown key="; Iecholn key;0
                )
            );
            set i = i + 2
        );
        // process ears
        Secho "newleft="; Iecho newleft; Secho "newright="; Iecho newright; Secho "ears_left="; Iecho ears_left; Secho "ears_right="; Iecho ears_right;
        Secho "sleep_is_sleeping="; Iecho sleep_is_sleeping; Secho "ears_resetting="; Iecho ears_resetting;
        if (newleft != nil || newright != nil) && ((newleft!=ears_left) || (newright!=ears_right)) then (
            set ears_left=newleft;
            set ears_right=newright;
            if ((!sleep_is_sleeping) && (!ears_resetting)) then (
//              midi_play MIDI_COMMUNION;
                ears_go_to_ref_pos
            )
        )
    );
    Secholn ""
    ;;
