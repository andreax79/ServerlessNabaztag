#include protos/chor_protos.mtl
#include protos/palette_protos.mtl
#include protos/info_protos.mtl
#include protos/sleep_protos.mtl

//--------------------------------------------------------------------------------------------------
// Choregraphies
//--------------------------------------------------------------------------------------------------

var chor_data;;
var chor_index;;
var chor_timescale;;
var chor_next_time;;
var chor_random;;  // for taichi
var chor_motor_dir;; // tuple (left_dir right_dir)
var chor_end_cb=nil;; // the callback to call in the end of the chor
var chor_paused_dur;; // can be paused during buffering
var chor_paused;;
var chor_paused_since;;
// R=60*((rand&127)+64)) => 64 à 196 mn
// donc si x=30, (x*R)>>7 => 15 à 45 mn
// donc si x=40, (x*R)>>7 => 20 à 61 mn
// donc si x=80, (x*R)>>7 => 40 à 122 mn
// donc si x=216, (x*R)>>7 => 108 à 330 mn
// donc si x=255, (x*R)>>7 => 127 à 390 mn, soit 2 à 6,5h
var chor_next_taichi;;

fun chor_start_msg chor cb i0=
    set chor_end_cb = cb;
    set chor_data=strcatlist chor;
    set chor_index=4+1;  // on saute le header et la première attente
    set chor_timescale=0;
    set chor_next_time=time_ms;
    set chor_paused_dur = 0;
    set chor_paused_since = nil;
    set chor_paused= 0;
    leds_set_all RGB_BLACK; // shut off all leds at start (or should it be in the chor ?)
    run_set_state chorCmdRun i0;
    0;;

fun chor_end_msg i0=
    set chor_next_time=nil;
    // call the callback
    if (chor_end_cb != nil) then call chor_end_cb [i0];
    0;;

fun chor_run_cmd i0=
    //  Secho "chor_run_cmd i:";Iecho chor_index; Secho " t:";Iecholn chor_next_time;
    // Manage buffering and pauses

    if (!chor_paused && audiolib_wav_buffering) then (
        // start pause
        set chor_paused_since = time_ms;
        set chor_paused = 1
    ) else if (chor_paused && !audiolib_wav_buffering) then (
        // end pause
        set chor_paused = 0;
        // increment paused_dur
        set chor_paused_dur = chor_paused_dur + (time_ms - chor_paused_since)
    );

    if (!chor_paused) then
    if time_ms-chor_paused_dur >= chor_next_time then
    (
        if chor_index>=strlen chor_data then chor_end_msg i0
        else let strget chor_data chor_index -> code in
        set chor_index=chor_index+2+
        if code==CH_FRAME_DURATION then
        (
            set chor_timescale=10*strget chor_data chor_index+1;
            1   //nb de paramètres
        )
        else if code==CH_SET_MOTOR then
        (
            ears_go (strget chor_data chor_index+1) (strget chor_data chor_index+2) (strget chor_data chor_index+3);
            3
        )
        else if code==CH_SET_LED_COLOR then
        (
//          Secho "set_led_color ";
            //led 4-strget chor_data chor_index+1 ((strget chor_data chor_index+2)<<16)+((strget chor_data chor_index+3)<<8)+(strget chor_data chor_index+4); // v16 start
            let 4-strget chor_data chor_index+1 -> iled in
            let strget chor_data chor_index+2 -> ired in
            let strget chor_data chor_index+3 -> igreen in
            let strget chor_data chor_index+4 -> iblue in
            (
                //Iecho iled; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
                led iled (ired<<16)+(igreen<<8)+iblue
            ); // v16 end
            6
        )
        else if code==CH_SET_LEDS_COLOR then // v16 start
        (
            //Secho "set_leds_color ";
            let strget chor_data chor_index+1 -> ired in
            let strget chor_data chor_index+2 -> igreen in
            let strget chor_data chor_index+3 -> iblue in
            let (ired<<16)+(igreen<<8)+iblue -> col in
            (
                //Secho "leds "; Secho ",r=";Iecho ired; Secho ",g=";Iecho igreen; Secho ",b=";Iecho iblue; Secholn ".";
                leds_set_all col
            );
            3
        ) // v16 end
        else if code==CH_SET_LED_PALETTE then
        (
//          Secholn "set_led_palette ";
            led 4-strget chor_data chor_index+1 palette_current.(7&strget chor_data chor_index+2);
            2
        )
        // v17
        else if code== CH_SET_LED_OFF then
        (
            //Secholn "CH_SET_LED_OFF ";
            led 4-strget chor_data chor_index+1 0;
            1
        )
        else if code==CH_RAND_MIDI then
        (
            //Secholn "randmidi";
            midi_play_random_note;
            0
        )
        else if code==CH_AVANCE then
        (
            //Secholn "avance";
            let (strget chor_data chor_index+1) -> motor in // v16 start
            let (strget chor_data chor_index+2) -> delta in
            let chor_motor_dir.motor -> dir in
            ears_go motor (ears_target motor)+if dir then -delta else delta dir;
            2
        )
        else if code==CH_SET_MOTOR_DIR then
        (
            //Secholn "setmotordir";
            let (strget chor_data chor_index+1) -> motor in
            let (strget chor_data chor_index+2) -> dir in
            set chor_motor_dir=
            if  motor == 0 then {dir chor_motor_dir.1} else {chor_motor_dir.0 dir}; // v16 end
            2
        )
        else if code==CH_IFNE then
        (
            //Secho "ifne ";Iecholn chor_random;
            if chor_random==(Iecholn strget chor_data chor_index+1) then 3
            else 3+((strget chor_data chor_index+2)<<8)+(strget chor_data chor_index+3)
        )
        else if code==CH_ATTEND then
        (
            //Secholn "attend";
            if ears_finished_moving && audiolib_wav_running==0 then 0
            else -2
        )
        else
        (
            chor_end_msg i0;
            0
        );
        if chor_next_time!=nil then
        (
            set chor_next_time=chor_next_time+(strget chor_data chor_index-1)*chor_timescale;
            chor_run_cmd i0
        )
    );;

/**
 * Callback called at the end of a TaiChi choreography
 * cb: the callback to call at the end of the choreography (can be nil)
 */
fun chor_taichi_end_cb unused cb=
    set chor_processing_status = 0;
    ears_set_wait_and_detect_mode;
    run_set_state idleRun;
#ifdef CHOR_DEBUG
    Secholn "taichi end";
#endif
    if cb != nil then call cb [];
    0;;

/**
 * Start a TaiChi choreography
 */
fun chor_taichi_start cb=
    set chor_random=((rand & 255) * 30) >> 8;
    set chor_motor_dir={0 0};
    ears_set_wait_only_mode;
    set chor_processing_status = 1; // block all trames during taichi
    chor_start_msg CHOR_TAICHI::nil (fixarg2 #chor_taichi_end_cb cb) nil;
    0;;

fun chor_do_taichi_now=
    if info_taichi && (info_taichi != nil) && (!sleep_status) then let (if chor_next_taichi!=nil then (time>chor_next_taichi) else 0) -> now in (
        if now || chor_next_taichi==nil then // compute chor_next_taichi
        let if (info_taichi == 40) then 255 else if (info_taichi == 255) then 40 else 80 -> correctedTaichi in // etait inversé
        let ((correctedTaichi*60*((rand&127)+64))>>7) -> delaye in (
#ifdef CHOR_DEBUG
            Secho "taichi in "; Iecho delaye; Secholn "s";
#endif
            set chor_next_taichi=time+delaye
        );
        now
    ) else (
        set chor_next_taichi=nil;
        0
    );;
