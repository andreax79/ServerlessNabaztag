#include protos/palette_protos.mtl
#include protos/streaming_protos.mtl
#ifdef XMPP
#include protos/xmpp_protos.mtl
#endif

// ********** loading resources

const BROADCAST_KEYWORD="broadcast";;

var _streaming_current=nil;;
var _streaming_rsc_tmp;; // buffer de chargement des ressources en petits morceaux
var streaming_rsc_loaded;; // list of resources loaded from current trame
var streaming_current_program;; // the list of commands of the current program

// replace the prefix string "broadcast" (if present) by url_broadcast
fun _streaming_prepare_url url=
    if 0==strstr url BROADCAST_KEYWORD 0 then strcat url_broadcast strsub url strlen BROADCAST_KEYWORD nil
    else url;;


// callback from rscLoadWaitRun : a resource has been loaded
fun _streaming_load_cb http res maxsize=
    if record_recording then
    (
        httpabort http;
        nil
    )
    else if res!=nil then
    (
        // received a result, store it in _streaming_rsc_tmp
        // Je ne comprends pas la logique ici (AS sept07) : a quoi sert _streaming_rsc_tmp et maxsize, et comment passe-t-il à la suite ?
//      Secholn res;
        set _streaming_rsc_tmp=res::_streaming_rsc_tmp;
        if maxsize!=nil && (slistlen _streaming_rsc_tmp)>maxsize then
        (
            // too big ? (?)
            httpabort http;
            _streaming_load_cb http nil nil
        );
        0
    )
    else
    (
        let hd trame_remaining_resources ->[url _] in
        // remember rsc loaded
        set streaming_rsc_loaded=[url tl rev _streaming_rsc_tmp nil]::streaming_rsc_loaded;

        // load next rsc
        set trame_remaining_resources=tl trame_remaining_resources;
        run_set_state rscLoadNextRun;
        0
    );;

// Recursive : loads all needed resources of the list 'trame_remaining_resources' and then starts current program
fun streaming_run_rsc_load_next_cmd=
    let hd trame_remaining_resources -> [url maxsize] in
    if url==nil then
    (
        // nothing (else) to load : start execute msgs now
        Secholn "rsrcs loaded, starting prgm";
        trame_program_start;
        0
    )
    else if nil!=listswitchstr streaming_rsc_loaded url then
    (
        // already loaded : load next
        set trame_remaining_resources=tl trame_remaining_resources;
        streaming_run_rsc_load_next_cmd
    )
    else
    (
        // load resource
        set _streaming_rsc_tmp=nil;
        Secho "loading ";
        run_set_state rscLoadWaitRun httprequest "GET" Secholn (_streaming_prepare_url url) nil (fixarg3 #_streaming_load_cb maxsize) HTTP_STREAM;
        0
    );;

fun streaming_run_rsc_load_wait_cmd http=
    // wait for loading resource
    if (httpinactive http)>STD_NET_TIMEOUT then
    (
        Secholn "##timeout in streaming_run_rsc_load_wait_cmd";
        httpabort http;
        // skip, load next
        set trame_remaining_resources=tl trame_remaining_resources;
        run_set_state rscLoadNextRun
    );
    0;;

/**
    Called when a program has to end.
    If doNotNotify is set (!=0) then the server is not notified of the end of the program
*/
fun endOfProgram doNotNotify =
    Secholn "endOfProgram";
    set chor_processing_status = 0;
    set chor_processing_wait_status = 0; // just in case
    set streaming_current_program = nil;
    if (interactive_status && !doNotNotify) then (
        // notifier fini
        interactive_program_done
    ) else (
        // retour normal
        run_set_state idleRun;
        0
    );
    0;;


// ****************************************
// Exécution des chorégraphies de streaming
// v17 - AS 25may07

// - 4 pas de danse fournis (dans chorstream_chorslist)
// - une séquence :
//  - une fois sur _streaming_oreille_chance, bouger les oreilles :
//      - pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 4, 8, 12 dents) et, si elle est différente de la position courante, y aller, dans le sens 'vers l'avant'.
//  - tirer un pas de danse au hasard (parmi les 4 fournis)
//  - tirer un nombre de boucles N au hasard entre 3 et 20 (inclus)
//  - tirer un frame_duration au hasard entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
// or les pas durent de 44 à 71 frames, donc le pas dure de 7 à 17 secs,
// donc la séquence dure de 21s à 5m40s
//  -> jouer le pas de danse N fois à ce tempo, puis nouvelle séquence
// A chaque pas de danse : tirer 3 couleurs au hazard dans la palette courante : tete, ventre, pied
// Si palette aléatoire : la changer à toutes les séquences
// sinon, fixée par le serveur.
//
var _streaming_pasdedanse;;
var _streaming_index;;
var _streaming_tempo;;
var _streaming_loops;;
var _streaming_nexttime;;
var _streaming_palettecolors = {0 0 0};;

// v17 AS 25may07 : ratio entre changt de séquence et mvt d'oreille. Plus c'est grand moins souvent les moteurs joueront.
// = 0 : à chaque chgt de seq (en myenne toutes les 2,5 minutes)
// = 1 : une fois sur 2 (soit en moyenne ttes les 5 minutes)
// = 2 : une fois sur 3 (soit en moyenne ttes les 7,5 minutes), etc...
var _streaming_oreille_chance;;

// mouvement des leds et oreilles
fun _streaming_do_chor_stream=
    if _streaming_pasdedanse==nil || ((_streaming_index>=strlen _streaming_pasdedanse)&&(_streaming_loops<1)) then
    (
        // nouvelle séquence
        // Secho "Sequence suivante ";

        // ears enabled ?
        if (streaming_chor_enabled) then
        (
        // movements moteur
        // toutes les _streaming_oreille_chance fois en moyenne
        // et aussi la première fois forcément histoire de montrer qu'on commence
        if (_streaming_pasdedanse == nil) then
        (
            // une des oreilles en haut, une autre en bas : radio...
            if ((random 2) == 1) then (ears_go 0 0 0; ears_go 1 10 0) else (ears_go 0 10 0; ears_go 1 0 0);

            // initialisation _streaming_oreille_chance
            set _streaming_oreille_chance = 0

        ) else if ((random _streaming_oreille_chance) == 0) then
        (
            // pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 5, 10, 14 dents) et, si elle est différente de la position courante, y aller, dans le sens 'vers l'avant'.
            let 0::5::10::14::nil -> ear4Positions in
            (
                let listnth ear4Positions rand&3 -> p in ears_go 0 p 0;
                let listnth ear4Positions rand&3 -> p in ears_go 1 p 0
            );

            // de moins en moins souvent, puis de nouveau souvent, etc..
            if ((set _streaming_oreille_chance = _streaming_oreille_chance + 1) > 4) then set _streaming_oreille_chance = 0
        )
        );

        // choix d'une séquence = pas de danse (_streaming_pasdedanse), tempo et nb de boucles
        set _streaming_pasdedanse = listnth CHORS_LIST rand&3;

        set _streaming_index=4+1; // on saute le header (4 bytes)
        set _streaming_tempo=160+random 90; // entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
        //Secho "tempo "; Iecholn _streaming_tempo;
        set _streaming_loops=3+random 18; // entre 3 et 20 (inclus)
        //Secho "loops "; Iecholn _streaming_loops;

        if (palette_current_is_random) then
            // changer palette courante
            palette_set_current random 7;

        // choisir 3 couleurs au hasard dans la palette
        set _streaming_palettecolors={(random 7) (random 7) (random 7)};

        set _streaming_nexttime=time_ms

    );

    // continuer à jouer
    while (_streaming_index < strlen _streaming_pasdedanse) && time_ms >= _streaming_nexttime do
    (
        // interprète la choragraphie. Uniquement des set_led_palette et des set_led_off et des set_led_color

        let strget _streaming_pasdedanse _streaming_index -> cmd in
            // avance l'index de...
            set _streaming_index=_streaming_index+2+
                if (cmd == CH_SET_LED_PALETTE) then
                (
                    // palette index
                    let strget _streaming_pasdedanse _streaming_index+1 -> iled in
                    let strget _streaming_pasdedanse _streaming_index+2 -> icol in
                    let _streaming_palettecolors.(3&icol) -> palcol in
                        // jouer la LED
                        led iled palette_current.palcol;

                    // 2 bytes : led, color
                    2
                )
                else if (cmd == CH_SET_LED_OFF) then
                (
                    // off
                    let strget _streaming_pasdedanse _streaming_index+1 -> iled in
                        led iled 0;

                    // 1 byte : led
                    1
                )
                else if (cmd == CH_SET_LED_COLOR) then
                (
                    led strget _streaming_pasdedanse _streaming_index+1
                        ((strget _streaming_pasdedanse _streaming_index+2)<<16) +
                        ((strget _streaming_pasdedanse _streaming_index+3)<<8) +
                        ((strget _streaming_pasdedanse _streaming_index+4));

                        // 6 bytes : 2 qui ne servent à rien
                        6
                )
                else if (cmd==CH_FRAME_DURATION) then
                (
                    // on ne le prend pas en compte : c'est _streaming_tempo qui gère le tempo
                    // 1 byte : duree
                    1
                )

                else (
                    // problème : commande inconnue : forcer à recommencer au début en incrémentant beaucoup trop
                    strlen _streaming_pasdedanse
                );

        // pas de danse fini ?
        if (_streaming_index>=strlen _streaming_pasdedanse) then
        (
            // on est arrivés au bout du pas de danse
            // next repeat
            set _streaming_loops=_streaming_loops-1;
            //Secho "loops "; Iecholn _streaming_loops;
            if (_streaming_loops > 0) then
            (
                // recommencer pas de danse
                set _streaming_index=4+1;  // on saute le header (4 bytes)
                // tout de suite
                set _streaming_nexttime=time_ms;

                0 // pour avoir le même type de return value que les autres branches du if...

            ) // sinon on laisse _streaming_loops = 0 et _streaming_index trop loin, ce qui force un passage à la séq suivante

        ) else
            // date de la prochaine commande
            // note : on repart de time_ms, histoire de se caler sur le temps présent et non pas sur le temps de
            // la chorégraphie, sinon, on a des coups de speed car cette fonction n'est pas toujours appelée de manière régulière.
            let strget _streaming_pasdedanse _streaming_index-1 -> delay in
                set _streaming_nexttime = time_ms+delay*_streaming_tempo

    );

    0;;

// boucle principale de la chorégraphie de streaming
fun streaming_stop=
    // oreilles
    ears_go_to_ref_pos;
    set streaming_status = 0;
    // which resource now ? Can only be interactive or idle
#ifdef XMPP
    if (!xmpp_busy_status) then ( // don't get a resource if we're busy
        if (interactive_status) then XmppSessionRequestResource "itmode"
        else XmppSessionRequestResource "idle"
    )
#else
    0
#endif
    ;;

fun streaming_run_cmd i0=
    if audiolib_wav_running==0 then (
        // Fin du stream
        streaming_stop;
        // next command
        run_set_state cmdEvalOne i0+1;

        nil
    ) else (
        // execute streaming choreography
        if !audiolib_wav_buffering then _streaming_do_chor_stream;

        0
    );;


fun _streaming_go_next_cmd i0=
    run_set_state cmdEvalOne i0+1;
    0;;

fun streaming_wav_error=
    if (interactive_status) then interactive_error;
    0;;

var _streaming_wait_end_time = 0;;

fun _streaming_wait_end_time_ms =
    _streaming_wait_end_time;;

fun _streaming_set_wait_end_time_ms t =
    set _streaming_wait_end_time = t;;

/**
 * quand on a rencontre une instruction "WT" dans un programme, qui demandait
 * d'attendre <n> millisecondes avant de continuer le programme
 */
fun streaming_run_wait_cmd i0 =
    if (time_ms > _streaming_wait_end_time_ms) then
    (
        set chor_processing_wait_status = 1;
        run_set_state cmdEvalOne i0+1
    )
;;


/**
 * Executes the i0'th command in the 'streaming_current_program' program
 * a command is a list [key val]
 */
fun streaming_run_eval_one_cmd i0=
//  Secho "streaming_run_eval_one_cmd ";Iecholn i0;
    interactive_reset_ears_touched;

    let listnth streaming_current_program i0 -> [key val] in
    if (/* Secho "eval cmd:";Secholn */ key)==nil then
    (
        // toutes commandes jouées : demander la suite
        endOfProgram 0;
        0
    )
    else if (!strcmp key "MU") || (!strcmp key "MC") then
    (
        Secho "exec "; Secho key; Secholn " : start music";
        set streaming_audio_cmd_index=streaming_audio_cmd_index+1;
        let listswitchstr streaming_rsc_loaded Secholn val -> music in
            if music==nil then Secholn "###nilmusic";
        audiolib_wav_start_local listswitchstr streaming_rsc_loaded val;
        run_set_state cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "ST" then
    (
        Secholn "exec ST : Start streaming";
        //IPecho netdns 0 1;
        //dns_start_client;
        set streaming_status = 1;
        leds_set_all RGB_BLACK;
#ifdef XMPP
        if !xmpp_busy_status then XmppSessionRequestResource "streaming";
#endif
        set streaming_audio_cmd_index=streaming_audio_cmd_index+1;
        set _streaming_current= nil;
        set _streaming_pasdedanse=nil;
        let _streaming_prepare_url val -> music in audiolib_start_http music #streaming_wav_error;
        run_set_state streamCmdRun i0;
        0
    )
    else if !strcmp key "SP" then
    (
        Secholn "exec SP : Start streaming (protected)";
        //IPecho netdns 0 1;
        //dns_start_client;
        set streaming_status = 1;
        leds_set_all RGB_BLACK;
#ifdef XMPP
        if !xmpp_busy_status then XmppSessionRequestResource "streaming";
#endif
        set streaming_audio_cmd_index=streaming_audio_cmd_index+1;
        set _streaming_current= nil;
        set _streaming_pasdedanse=nil;
        // Romain
        let _streaming_prepare_url val -> music in (
            set music = strcatlist music::"&sn="::(webmac netMac)::nil;
            let music -> tmpval in (
                set tmpval = md5(strcatlist music::"teloiv"::nil);
                set music = strcatlist music::"&cs="::tmpval::nil
            );
            audiolib_start_http music #streaming_wav_error
        );
        run_set_state streamCmdRun i0;
        0
    )
    else if !strcmp key "SI" then
    (
        Secho "exec SI : "; Secholn val;
        // nomme le stream courant
        if streaming_status then set _streaming_current = val;
        // play next
        run_set_state cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "SE" then
    (
        Secho "exec SE : "; Secholn val;
        // stoppe le stream courant s'il est nommé comme ca
        if streaming_status && (!strcmp _streaming_current val) then (
            audiolib_wav_stop;
            ears_stop 0;
            streaming_stop
        );
        // play next
        run_set_state cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "MS" then
    (
        Secholn "exec MS : "; Secho val;
        // Music Stream : streams the music (like ST), no choregraphy (assumed to be done by CH), not blocking (like MU)
        set streaming_audio_cmd_index=streaming_audio_cmd_index+1;
        // starts the streamed music
        let _streaming_prepare_url val -> music in audiolib_start_http music #streaming_wav_error;
        // play next
        run_set_state cmdEvalOne i0+1;

        0
    )
    else if !strcmp key "MW" then
    (
        // wait for the end of music
        if audiolib_wav_running==0 then run_set_state cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "CH" then
    (
        Secholn "exec CH : "; Secho val;
        chor_start_msg (listswitchstr streaming_rsc_loaded val) #_streaming_go_next_cmd i0;
        0
    )
    else if !strcmp key "IS" then
    (
        Secho "exec IS : "; Secholn val;
        // Start Interactive mode
        interactive_start val;
        0
    )
    else if !strcmp key "IE" then
    (
        Secholn "exec IE : ";
        // Ends Interactive mode
        interactive_stop;
        0
    )
    else if !strcmp key "WT" then
    (
        // need to wait for val miliseconds, staying in interactive mode. at the end, program continues.
        // if button pressed, program stops.
        // if rfid detected, send info.
        set chor_processing_wait_status = 1;

        _streaming_set_wait_end_time_ms time_ms + (atoi val);
        run_set_state waitCmdRun i0+1;
      0
    )
    else
    (
        Secho key ; Secholn " : "; Secholn val;
        if !strcmp key "PL" then (palette_set_current_mode atoi val;0)
        else if !strcmp key "CL" then (
                let atoi val -> x in palette_set_current_color (x>>24) x&0xffffff;
                0)
        else if !strcmp key "IC" then (interactive_eval_IC_msg val;0)
        else (Secholn "unknown, dropping";0);

        // and skip command
        run_set_state cmdEvalOne i0+1;
        streaming_run_eval_one_cmd i0+1
    );;
