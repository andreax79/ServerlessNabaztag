#include protos/trame_protos.mtl
#include protos/dns_protos.mtl
#include protos/jobs_protos.mtl
#include protos/streaming_protos.mtl
#include protos/http_protos.mtl
#include protos/xmpp_protos.mtl

#ifdef XMPP_DEBUG
fun _xmpp_debug str = Secholn str; nil ;;
#else
fun _xmpp_debug str = nil;;
#endif

// activate ping
// #define XMPP_DO_PING

//------------------- MOT DE PASSE POUR LE PROTOCOLE XMPP
const XMPP_PASSWORD_CHECK = 1;;
const XMPP_PASSWORD_LENGTH = 12;;

fun __xmpp_full_web_mac key i=
	if i<strlen key then (ctoh strget key i)::if i+1<strlen key then ":"::__xmpp_full_web_mac key i+1 else __xmpp_full_web_mac key i+1;;

fun _xmpp_full_web_mac key=strcatlist __xmpp_full_web_mac key 0;;

// get the password which is in the configuration of the nabaztag
fun _xmpp_get_password =
    let "n" -> PasswordSet in
    let "d" -> PasswordCheck in
    let load PasswordSet 0 "conf.bin" (CONF_LENGTH) XMPP_PASSWORD_CHECK -> tmp1 in
    (
        if (strstr PasswordSet PasswordCheck 0) == 0 then (
            let strnew XMPP_PASSWORD_LENGTH -> PasswordGet in
            let load PasswordGet 0 "conf.bin" (CONF_LENGTH+XMPP_PASSWORD_CHECK) XMPP_PASSWORD_LENGTH -> tmp1 in
                PasswordGet
        )
        else
            nil
    )
;;

// Set a new random password in the configuration of the nabaztag
fun _xmpp_generate_password =
    srand time_ms;
    let strsub (md5 strcatlist (itoa rand)::(_xmpp_full_web_mac netMac)::(itoa time_ms)::nil) 1 XMPP_PASSWORD_LENGTH -> NewPassword in
        NewPassword
;;

// Set a new random password in the configuration of the nabaztag
fun _xmpp_set_password NewPassword=
    let strcatlist "d"::NewPassword::nil -> PasswordAndDone in
        save PasswordAndDone 0 "conf.bin" (CONF_LENGTH) (XMPP_PASSWORD_LENGTH+XMPP_PASSWORD_CHECK)
;;

// Set a new random password in the configuration of the nabaztag
fun _xmpp_reset_password =
    let "zeyzjsuzjsu" -> PasswordAndDone in
        save PasswordAndDone 0 "conf.bin" (CONF_LENGTH) (XMPP_PASSWORD_LENGTH+XMPP_PASSWORD_CHECK)
;;


//DEBUG

var NOWREGISTER = 0;;


fun boshurl ip=
    strcatlist ip::"/http-bind"::nil;;

proto sendmailxmppurl 2;;


/**
    Returns a string representation of the run variable
*/
fun runToStr run =
    match run with
    ( configstartRun -> "configStartRun")
    | (configwaitRun _ -> "configWaitRun")
    | (interactiveReqWaitRun _ -> "interactiveReqWaitRun")
    | (rscLoadNextRun -> "rscLoadNextRun" )
    | (rscLoadWaitRun _ -> "rscLoadWaitRun" )
    | (chorCmdRun _ -> "chorCmdRun" )
    | (streamCmdRun _ -> "streamCmdRun" )
    | (waitCmdRun _ -> "waitCmdRun" )
    | (cmdEvalOne _ -> "cmdEvalOne" )
    | (idleRun -> "idleRun" )
    | (sleepRun -> "sleepRun" )
    | (recordRun -> "recordRun" )
    | (recordStartRun -> "recordStartRun" )
    | (earResetWaitRun _ -> "earResetWaitRun" )
    | (xmppLoginRun -> "xmppLoginRun" )
    | (xmppReconnectRun _ -> "xmppReconnectRun" )
;;


fun xmpp_run_login=
    // if trame waiting, execute it
    let trame_get_next_pending -> trame in
    if trame != nil then
        trame_eval trame;;


fun _xmpp_process_incoming_trame ping_trame rsrc ttl=
    Secho "_xmpp_process_incoming_trame for "; Secholn rsrc;
    if (trame_is_resource_valid rsrc) then (
        trame_eval ping_trame
    ) else (
        Secholn "enqueueing trame";
        let if (ttl == nil) then nil else (time + (atoi ttl)) -> expiration_time in
            set trame_queue = conc trame_queue [rsrc expiration_time ping_trame]::nil;

        // full ?
        let listlen trame_queue -> queueLen in
        if queueLen >= TRAME_QUEUE_MAXLEN then (
            Secholn "trame queue full, warning server";
            set xmpp_busy_status = 1;
            (XmppSessionRequestResource "busy")::nil
        ) else (
            nil
        )
    )
    ;;

// ---------------------------------------------------------
// XMPP Configuration
// ---------------------------------------------------------
const XmppTcpIdleTime = 8;;                         // Si il ne se passe rien pendant 8 secondes sur le flux, on le maintient ouvert en envoyant un " "
var XmppGlobalSession = nil;;                           // La session Xmpp

const XmppVioletPlatformComponent = "xmpp.platform.violet.net";;
const XmppVioletObjectsComponent = "xmpp.objects.violet.net";;
const XmppVioletAppletComponent = "xmpp.applet.violet.net";;
const XmppVioletPlatformClient = "net.violet.platform";;

const TcpServerNoResponseTimeOut = 2;;  // When opentcp don't response after x sec, try another server

const XmppTcpOpenStream1 = "<?xml version='1.0' encoding='UTF-8'?>\n<stream:stream to='";;
const XmppTcpOpenStream2 = "' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' version='1.0'>\n";;
var XmppTcpCloseStream = "</stream:stream>";;


const XmppBoshHttpTimeOut = 30;;

// the delay between two 'ping' packets
const XmppPingDelay = 60;;
// the maximum number of seconds that we can wait between sending a ping request and getting the response
const XmppPingMaxReponseDelay = 5;;



const XmppBoshEncapsulation1 = "<body rid='";;
const XmppBoshEncapsulation2 = "' sid='";;
const XmppBoshEncapsulation3= "' xmlns='http://jabber.org/protocol/httpbind'>";;
const XmppBoshEncapsulation4 = "</body>";;

const XmppBoshOpenStream1 = "<body content='text/xml; charset=utf-8' hold='15' rid='";;
const XmppBoshOpenStream2 = "' to='";;
const XmppBoshOpenStream3 = "' route='xmpp:";;
const XmppBoshOpenStream4 = "' secure='true' wait='7' xml:lang='en' xmpp:version='1.0' xmlns='http://jabber.org/protocol/httpbind' xmlns:xmpp='urn:xmpp:xbosh'/>";;

const XmppBoshReOpenStream1 = "<body rid='";;
const XmppBoshReOpenStream2 = "' sid='";;
const XmppBoshReOpenStream3 = "' to='";;
const XmppBoshReOpenStream4 = "' xml:lang='en' xmpp:restart='true' xmlns='http://jabber.org/protocol/httpbind' xmlns:xmpp='urn:xmpp:xbosh'/>";;


// Variables diverses
var SendTry = 0;;   // Permet de compter le nombre de tentative d'envoie d'une requete defectueuse

// ---------------------------------------------------------
// XMPP SESSION
// ---------------------------------------------------------

type tXmppSessionStreamState = ssRegister1 | ssRegister2 | ssBind | ssUnBind | ssStartSession | ssGetSource | ssFree | ssLogging | ssPresence ;;
// ss >> Stream State
// Register1 > Première phase de l'enregistrement
// Register2 > Seconde phase de l'enregistrement
// Bind > Acquisition de la Ressource
// UnBind > Rendre la Ressource
// Session > Creation d'une session
// Source > Recupération des sources
// Free > Libre pour des actions
// ssLogging > On est en train de se connecter
// ssPresence > Juste apres un session idle sinon bloquant en tcp si on a nextressource != nil
type tXmppSessionStanzaTypes = stanzaIQGet | stanzaIQSet | stanzaIQResult _ | stanzaMessage | stanzaPresence | stanzaIQError _;;
type tXmmpSessionClient = [clINT clASR clPPT clRFID clITMODE clSOURCES];;
// Etats de la session:
// sOpening: état initial.
// sLogging: on essaye de se connecter (on a bien un compte ou on pense qu'on a bien un compte)
// sLoggedin: on a passé l'identification (succès sur le mot de passe)
// sOpened: connecté (i.e., on a passé la phase identification & l'ouverture de session)
// sClosed: la sessions est fermée (on ne passe jamais dans cet état)
// sRegistrationError: état final, le lapin est en rouge (jusqu'au reboot)
type tXmppSession_Status = sOpening | sLogging  | sLoggedin | sOpened | sClosed | sRegistrationError;;
type tXmppSession = [/*GATE*/ sGate sStatus /*SASL*/ sNonce sCnonce sRealm sUsername sPassword sQop sAlgo sCharset sDomain /* Stream State */ sJID sPreviousResource sNextResource sNextResourceBinding sResource sState sInQueue sOutQueue sStanzaID /* Divers */ sClients sDisplayLeds sLastIOTime sLastReadTime sLastStreamState sNextRestart sPacketQueue sDataToSend sLastPingTime sLastPingIqId];;
// NextResourceBinding sert que si on est en train de faire un bind et qu'on souhaite rechanger vers un autre après

// ---------------------------------------------------------
// XMPP GATE > CONNECT, SEND, IDLE in TCP or BOSH
// ---------------------------------------------------------
proto XmppGateConnect 1;;   // Try to connect to the server (will we don't get a <stream:stream>
proto XmppGateSend 2;;      // Try to send something to the server
proto XmppGateRead 2;;      // Receive something from the server
proto XmppGateIdle 1;;      // Observe Xmpp stream
proto XmppGateOpenStream 1;;// Send the data to open stream with server
proto XmppGateStreamOpened 1;;  // le stream a bien été ouvert
proto XmppGateStreamClosed 2;; // if the stream has been closed

type tXmppGate_Mode = pTcp | pBosh;;        // 2 Mode : BOSH (port 80) or Normal Tcp (port 5222)
type tXmppGate_Status = pOpening | pOpen | pInStream | pClosing | pClose;;  // Opening (try to open port), Open (try to send <stream:stream>)
type tXmppGate = [pParent pMode pStatus pTry pTcpV pBoshV pBuffer pSId pActualMode];;
// pParent > xSession
// pMode (pTcp / pBosh)
// pStatus (pOpening, pOpen...)
// pTry (3 to 1 > Normal TCP, 0 > Bosh)
// pTcpV = struct for tcp
// pBoshV = struct for Bosh

// ---------------------------------------------------------
// XMPP TCP > SEND, READ_CB, IDLE
// ---------------------------------------------------------
proto XmppTcpOpen 3;;   // Try to open the tcp (opentcp...)
proto XmppTcpSend 2;;
proto XmppTcpRead 4;;
proto XmppTcpIdle 1;;   // Check if the stream works
proto XmppTcpOpenStream 1;; // Send the data to open the stream

type tXmppTcp = [xParent xSocket xHost xPort];;

// ---------------------------------------------------------
// XMPP BOSH > SEND, READ_CB, IDLE
// ---------------------------------------------------------
proto XmppBoshSend 2;;
proto XmppBoshRead 3;;
proto XmppBoshIdle 1;;
proto XmppBoshOpenStream 1;; // Send the data to open the stream in BOSH
proto XmppBoshReOpenStream 1;; // Send the data to reopen the stream in BOSH
proto XmppBoshSetUp 2;;     // Configure the ip of the server

type tXmppTcp = [yParent yHttpList yMsgId yServerIp yMaxRequest];;

// ---------------------------------------------------------
// JID utils
// ---------------------------------------------------------
proto xmpps_JIDNode 1 ;;
proto xmpps_JIDResource 1 ;;
proto xmpps_JIDPlatform 1 ;;
proto xmpps_PlatformJID 2 ;;
proto xmpps_ServerJID 1 ;;
proto xmpps_OurJID 1 ;;
proto xmpps_BindJID 2 ;;

// ---------------------------------------------------------
// XMPP utils
// ---------------------------------------------------------
proto xmppStateToStr 1 ;;



// AFAIRE

proto xmpps_createStanza 5;;
















// ---------------------------------------------------------
// XMPP TCP
// ---------------------------------------------------------

/*
 * Appelle XmppTcpOpen sur le port 5222
 */
fun XmppTcpOpen5222 ip xSession =
        XmppTcpOpen ip 5222 xSession
;;

/*
 * Ouvre un port TCP pour une session particuliere
 */
fun XmppTcpOpen ip port xSession =
    _xmpp_debug strcatlist "XmppTcpOpen, back from dnssrvcb "::ip::":"::(itoa port)::nil;
    if ip != nil && port != nil then // Si on a une ip et un port valide, on supprime les anciens et on tente d'ouvrir le port en initialisant le tout
    (
        set xSession.sLastReadTime = time;
        if xSession.sGate.pTcpV != nil then         // On supprime et ferme tout si quelque chose avant existait
        (
            closetcp xSession.sGate.pTcpV.xSocket;  // Fermeture du socket
            set xSession.sGate.pTcpV = nil          // Suppression de la variable
        );

        _xmpp_debug "Open the tcp Socket";
        let [xParent:xSession xSocket:nil xHost:ip xPort:port] -> newTcp in
        (
            set xSession.sGate.pTcpV = newTcp;
            set newTcp.xSocket = opentcp netip nil (useparamip ip) port fixarg4 #XmppTcpRead xSession   // On ouvre le socket
        );
        0
    )
    else(   // on est a la fin des entrees srv et on a pas reussi a se connecter -> on essaie le domaine xmpp tout court, et si ca ne fonctionne pas on retombera en BOSH
        _xmpp_debug ( strcatlist "No more SRV answears. let's try to connect directly to " :: xSession.sDomain :: nil );
        dnsreq xSession.sDomain fixarg2 #XmppTcpOpen5222 xSession;
        0)
    ;;


/*
 * Rouvre un port TCP pour une session
 */
fun XmppTcpReOpen ip port xSession =
    //_xmpp_debug strcatlist "BACK FROM DNS SRV! "::ip::":"::(itoa port)::nil;
    if ip != nil && port != nil then // Si on a une ip et un port valide, on supprime les anciens et on tente d'ouvrir le port en initialisant le tout
        (
        if xSession.sGate.pTcpV != nil then                     // On supprime et ferme tout si quelque chose avant existait
                (
            closetcp xSession.sGate.pTcpV.xSocket;  // Fermeture du socket
                        set xSession.sGate.pTcpV = nil                  // Suppression de la variable
                );

                //_xmpp_debug "Open the tcp Socket";
                let [xParent:xSession xSocket:nil xHost:ip xPort:port] -> newTcp in
                (
                        set xSession.sGate.pTcpV = newTcp;
                        set newTcp.xSocket = opentcp netip nil (useparamip ip) port fixarg4 #XmppTcpRead xSession       // On ouvre le socket
                );
        0
    )
    else
        XmppTcpOpen ip port xSession;;


/*
    Effectue l'envoi effectif les données mises en attente sur la
  connection tcp.
    Regarde s'il y a des données en attente d'être envoyées, et
  si c'est le cas, essaie d'en envoyer le plus possible. La socket
    est peut etre déja occupée, dans ce cas on pourra envoyer 0 donnée
    mais ce n'est pas (encore) une erreur.

    retourne le nombde d'octets envoyés ce coup si, ou nil s'il y a un
    vrai problème sur la socket.
*/
fun XmppTcpActuallySendData xSession =
    let xSession.sDataToSend -> [ data index nbTries ] in
    if (nil == data) then
        (_xmpp_debug "XmppTcpActuallySendData rien a ecrire"; 0)
    else
        (
            let xSession.sGate.pTcpV.xSocket -> socket in
            let writetcp socket data index -> newIndex in
                if (nil != newIndex) then
                    (
                        set xSession.sLastIOTime = time;    // Mise à jour
                        set xSession.sLastReadTime = time;  // Succès de l'écriture.

                        if (newIndex != index) then
                            (
                                set xSession.sDataToSend =
                                        [
                                            (if (newIndex < strlen data) then data else nil)
                                            (if (newIndex < strlen data) then newIndex else 0)
                                            0
                                        ];
                                (newIndex - index)
                            )
                            else
                                (
                                    if (nbTries < 10) then
                                        (set xSession.sDataToSend = [ data index (nbTries + 1) ] ; 0)
                                    else
                                        (set xSession.sDataToSend = [ nil 0 0 ] ; nil)
                                )
                    )
                else
                    (
                        _xmpp_debug "on a un probleme...";
                        set xSession.sDataToSend = [ nil 0 0 ];
                        nil
                    )
        )
;;


/*
    Envoie un élément sur la connexion TCP de la session Xmpp.
    Retourne le nombre de bytes écrit : nil problem, autre "OK"
    Met à jour le xSession.sLastIOTime

    Les donnees ne sont pas forcement envoyees tout de suite, elles
    peuvent etre mises en attente si la file d'envoi tcp n'est pas vide.
    Si la file n'est pas vide, alors c'est qu'un envoi est en cours
    (l'envoi des données actuellement dans la file), et pas terminé.
    XmppTcpRead va donc recevoir des avertissements TCP_WRITE lorsque
    la socket sera de nouveau disponible pour écrire la suite.
 */
fun XmppTcpSend xSession Data =
    let xSession.sDataToSend -> [ oldData oldIndex nbTries ] in
    if (nil != oldData) then
    (
        // ajouter les donnees qu'on veut envoyer aux donnees qu'il va falloir envoyer
            _xmpp_debug "envoi differe";
            set xSession.sDataToSend =
                [
                    ( strcatlist oldData :: Data :: nil )
                    ( oldIndex )
                    nbTries
                ];
        0
    )
    else
    (
        _xmpp_debug "envoi direct";
        set xSession.sDataToSend = [ Data 0 0 ];
        XmppTcpActuallySendData xSession
        // on ne checke pas le retour. Dans tous les cas :
        //  - soit la donnée est bien partie, pas de pb
        //  - soit il y a de l'attente, elle sera envoyée au prochain passage dans XmppTcpRead
        //  - soit il y a un pb définitif, de toutes manières on l'aura encore au prochain passage dans XmppTcpRead
    )
;;


/*
 * Lecture par TCP
 * Met à jour le xSession.sLastIOTime et sLastReadTime
 * Si il y a des Stanzas à lire >   XmppGateRead
 * Si on ouvre la session >         XmppGateStreamOpened
 * Si le flux est fermé >           XmppGateStreamClosed
 */
fun XmppTcpRead t val msg xSession =
    Secholn "XmppTcpRead";
    if xSession.sGate.pTcpV != nil then if xSession.sGate.pTcpV.xSocket == t then // La requete n'est plus valable
    (
        if val == TCPWRITE then (                   // succès de l'ouverture du socket
            Secholn "TCPWRITE";
            match xSession.sGate.pStatus with
              ( pInStream -> Secholn "pInStream"; nil )
            | (_ -> // Si on est pas deja dans le flux...
                // Dans se cas on vient d'ouvrir le tcp!
                set xSession.sGate.pStatus = pOpen;     // on change alors les status
                set xSession.sLastIOTime = time;            // et sinon met à jour pour une action plus rapide
                set xSession.sGate.pTry = 3;
                nil
            );
            // envoi des donnes xmpp en attente d'envoi si on en a
            if (nil == XmppTcpActuallySendData xSession) then
                XmppSessionIsDisconnected xSession;
            0
        )else if val == TCPREAD then (      // Le serveur déclenche une action

            set xSession.sLastIOTime = time;    // Mise à jour
            set xSession.sLastReadTime = time;


            /* DEUX MODE : - ON EST EN TRAIN D'Ouvrir >> on attend le <stream:stream
                           - ON EST DANS <stream:stream> */
            match xSession.sGate.pStatus with
            (pInStream -> // Now we are in the stream so normal parsing
                set xSession.sGate.pBuffer = strcatlist xSession.sGate.pBuffer::msg::nil;   // Mise à jour du buffer d'entrée

                let strstr xSession.sGate.pBuffer "</stream:stream>" 0 -> stream_end in     // Si on a une fermeture du stream
                    if stream_end != nil then
                        XmppGateStreamClosed xSession pTcp;

            0) | ( _ -> // Si on est dans un autre mode

                set xSession.sGate.pBuffer = strcatlist xSession.sGate.pBuffer::msg::nil;

                let strstr msg "<stream:stream" 0 -> stream_pos in  // on détecte la balise stream
                if (stream_pos != nil) then (
                    let strstr msg ">" stream_pos -> stream_close_pos in        // on détecte la fermeture de cette balise
                    let (strstr msg "id='" stream_pos)+4 -> stream_id_pos in    // on cherche l'attribut id
                    let strstr msg "'" stream_id_pos -> stream_idend_pos in     // on cherche l'attribut id
                    if (stream_close_pos != nil) then (                         // si on a bien la fermeture de la balise
                        if stream_id_pos != nil && stream_idend_pos != nil then // on enregistre l'id
                            set xSession.sGate.pSId = strsub msg stream_id_pos (stream_idend_pos-stream_id_pos);
                        set xSession.sGate.pBuffer = strsub msg (stream_close_pos + 1) nil;
                        XmppGateStreamOpened xSession   // le flux est ouvert
                    )
                );
            0);

            while ( if xSession.sGate.pBuffer == nil then 0                     // Si on a rien dans le buffer, il ne se passe rien
                else (
                    let ParseXMLPacket xSession.sGate.pBuffer -> xmlStanza in   // Sinon on parse ce qu'il y a dans le buffer, et on envoie
                    (
                        set xSession.sGate.pBuffer = xmlStanza.EndStrS;         // On met le reste qui n'a pas ete traite dans le buffer
                        if xmlStanza.inXml != nil then (
                            XmppGateRead xSession xmlStanza.inXml;                  // On déclenche l'action
                            1
                        ) else 0
                    )
                )
            ) do nil;

            0
        )else if val == TCPCLOSE then (     // Le Socket est fermé, on est déconnecté
            XmppGateStreamClosed xSession pTcp;
            0
        )else if val == TCPSTART then 0     // JAMAIS UTILISE
        else (_xmpp_debug strcatlist "TCPVAL : "::(itoa val)::nil; 0);
        0
    );
    0
;;

/*
 * Idle pour le TCP
 * Maintien la connexion
 */
fun XmppTcpIdle xSession =
    // Si la derniere action est inferieur au time out : on maintient la connexion avec l'envoie d'un espace
    if time - xSession.sLastIOTime > XmppTcpIdleTime then (
        XmppGateSend xSession " "
    );
0;;


/*
 * On envoie l'ouverture du flux <stream:stream...
 */
fun XmppTcpOpenStream xSession =
    set xSession.sGate.pActualMode = 1; //TCP
    set xSession.sGate.pStatus = pOpening;  // changement d'etat de la connexion
    let strcatlist XmppTcpOpenStream1::xSession.sDomain::XmppTcpOpenStream2::nil -> phrase in
        XmppGateSend xSession phrase;
0;;













// ---------------------------------------------------------
// XMPP BOSH > SEND, READ_CB, IDLE
// ---------------------------------------------------------
/*
 * On lance une requete http vers le serveur jabber
 */
fun XmppBoshSend xSession xData =
    if xSession.sGate.pBoshV.yServerIp != nil then
    (
        set xSession.sLastIOTime = time;                    // Mise à jour
        let xSession.sGate.pBoshV.yServerIp -> ip in    // récupère l'ip
        let xSession.sGate.pBoshV.yMsgId -> id in       // récupère l'id du message
        let http_request "POST" (boshurl ip) (strcatlist XmppBoshEncapsulation1::(itoa id)::XmppBoshEncapsulation2::xSession.sGate.pSId::XmppBoshEncapsulation3::xData::XmppBoshEncapsulation4::nil) fixarg3 #XmppBoshRead xSession HTTP_NORMAL -> lasthttp in
            set xSession.sGate.pBoshV.yHttpList = [lasthttp time xData id]::xSession.sGate.pBoshV.yHttpList; // On ajoute la requete à la liste de requete
        set xSession.sGate.pBoshV.yMsgId = xSession.sGate.pBoshV.yMsgId + 1         // On incremente l'id du message
    );
0;;

/*
 * Lecture a partir du serveur
 * XmppGateRead
 * XmppSessionIsDisconnected
 * XmppGateStreamOpened
 */
fun XmppBoshRead httpreq res xSession =
    match xSession.sGate.pStatus with
    (pOpening -> set xSession.sGate.pStatus = pOpen; 0)
    |(_ -> 0);
    let hd xSession.sGate.pBoshV.yHttpList -> hdhttp in
    let tl xSession.sGate.pBoshV.yHttpList -> tlhttp in
    let 0 -> Process in
    let "" -> DataSent in
    let nil -> UpdatedList in
    (
        while hdhttp != nil do (                            // Mise à jour de la liste de requete
            let hdhttp -> [Req Time xData Id] in
            (
                if Req != httpreq then (
                    set UpdatedList = hdhttp::UpdatedList;  // Ce n'est pas la bonne requete, elle n'est pas encore revenue
                0)else(
                    set DataSent = xData;
                    set Process = 1;
                1)
            );
            set hdhttp = hd tlhttp;
            set tlhttp = tl tlhttp
        );

        set xSession.sGate.pBoshV.yHttpList = UpdatedList;

        set xSession.sLastReadTime = time;
        if Process == 1 then (  // Si on a bien reçu les données

            if (strlen http_get_content res) <= 0 then (
                // Ici on a un resultat vide... pas normal!
                if DataSent != nil then (
                    if (!strcmp DataSent " ") then (
                        XmppSessionIsDisconnected xSession;
                        _xmpp_debug "Mistake in maintening connexion"
                    )
                    else if (strlen DataSent) <= 0 then
                        _xmpp_debug "Nothing sent... nothing in return?"
                    else (
                        _xmpp_debug strcatlist "This request ("::DataSent::") return a empty string, send again..."::nil;

                        set SendTry = SendTry + 1;
                        if SendTry > 15 then
                            XmppSessionIsDisconnected xSession  // On a un probleme, on a tenté trop souvent
                        else
                            XmppGateSend xSession DataSent;
                        _xmpp_debug "_sent"
                    )
                ) else
                    _xmpp_debug "Nothing sent before...";

            0)else (

                set SendTry = 0;    // On a pas de probleme, on met à jour le sendTry

                set xSession.sLastIOTime = time;    // Mise à jour

                let strstr http_get_content res "</stream:stream>" 0 -> stream_end in     // Si on a une fermeture du stream
                    if stream_end != nil then
                        XmppGateStreamClosed xSession pBosh;

                let ParseXMLPacket http_get_content res -> xmlStanza in // On a le paquet dans le <body
                    if (xmlStanza.inXml == nil) then (
                        nil;
                    0) else (
                        match xmlStanza.inXml with  // On recupere le contenu de la balise body
                        (ContentElement Balise ->

                            if !strcmp Balise.nameS "body" then // Si on est bien dans une balise body
                            (
                                let hd Balise.attribute -> tete in              // premier attribut
                                let tl Balise.attribute -> queu in              // reste des attributs
                                (   while tete != nil do
                                    (   if !strcmp tete.tagS "sid" then         // on sauvegarde l'attribut de session
                                            set xSession.sGate.pSId = tete.valueS;
                                        if !strcmp tete.tagS "xmlns:stream" then // On est dans l'ouverture de stream
                                            XmppGateStreamOpened xSession;
                                        if !strcmp tete.tagS "requests" then // le nombre de requete max
                                            set xSession.sGate.pBoshV.yMaxRequest = atoi(tete.valueS);
                                        if !strcmp tete.tagS "type" then ( // le nombre de requete max
                                            if !strcmp tete.valueS "terminate" then
                                            (
                                                _xmpp_debug "Stream TERMINATE! Restart! : ";
                                                _xmpp_debug http_get_content res;
                                                XmppSessionIsDisconnected xSession // la session a ete terminee, on redemarre
                                            )
                                        );
                                        set tete = hd queu;
                                        set queu = tl queu )
                                );

                                let 0 -> i in
                                let hd Balise.content -> tete in            // On parcourt tous les éléments
                                let tl Balise.content -> queu in
                                (
                                    while tete != nil do (
                                        match tete with
                                        (ContentElement Balise -> // Si il s'agit bien d'une balise, on la traite comme une requete normale
                                            set i = i + 1;
                                            XmppGateRead xSession tete;
                                        0)|
                                        (ContentText Texte -> 0) | ( _ -> 0 );
                                        set tete = hd queu;
                                        set queu = tl queu;
                                    0);
                                0)
                            ) else (
                                _xmpp_debug "Not in a balise body";
                                XmppSessionIsDisconnected xSession  // Se n'est pas une balise body, on redemarre
                            )

                        )|(ContentText Texte -> 0) | ( _ -> 0 );
                    0)
            )
        ) else (
            _xmpp_debug http_get_content res;
            if(http_get_content res) == nil then (
                set xSession.sNextRestart = time + 22;
                // TODO FIGER EN VERT
                _xmpp_debug "Send Presence to see if we are connected... (reconnect in 22 sec)";
                set xSession.sState = ssFree;
                xmpps_createStanza xSession
                    xSession.sJID /* FROM */
                    nil /* TO */
                    stanzaPresence /* Type = iq & get */
                    nil
                //XmppSessionIsDisconnected xSession;
            );
            0
        )   // On a un problème, on a tenté trop souvent) // On a des données d'une socket qui ne nous appartient pas (ou le socket a été supprimé)
    );
    if (xSession.sGate.pBoshV.yHttpList == nil) then (
        set xSession.sNextRestart = -1
    );
0;;

// FUNCTION TO OPEN THE STREAM TO THE SERVER
fun XmppBoshOpenStream xSession =
    if xSession.sGate.pBoshV.yServerIp != nil then
    (
        //_xmpp_debug "Open Xmpp Stream (BOSH)";
        set xSession.sGate.pActualMode = 2; //BOSH
        set xSession.sGate.pStatus = pOpening;
        set xSession.sLastIOTime = time;        // Mise à jour
        let xSession.sGate.pBoshV.yServerIp -> ip in
        let xSession.sGate.pBoshV.yMsgId -> id in
        let http_request "POST" (boshurl ip) (strcatlist XmppBoshOpenStream1::(itoa id)::XmppBoshOpenStream2::(xSession.sDomain)::XmppBoshOpenStream3::(boshurl ip)::XmppBoshOpenStream4::nil) fixarg3 #XmppBoshRead xSession HTTP_NORMAL -> lasthttp in
            set xSession.sGate.pBoshV.yHttpList = [lasthttp time nil id]::xSession.sGate.pBoshV.yHttpList; // On ajoute la requete à la liste de requete
        set xSession.sGate.pBoshV.yMsgId = xSession.sGate.pBoshV.yMsgId + 1
    );
0;;

// FUNCTION TO REOPEN THE STREAM TO THE SERVER
fun XmppBoshReOpenStream xSession =
    if xSession.sGate.pBoshV.yServerIp != nil then
    (
        //_xmpp_debug "ReOpen Xmpp Stream (BOSH)";
        set xSession.sGate.pActualMode = 2; //BOSH
        set xSession.sLastIOTime = time;        // Mise à jour
        set xSession.sGate.pStatus = pOpening;
        let xSession.sGate.pBoshV.yServerIp -> ip in
        let xSession.sGate.pBoshV.yMsgId -> id in
        let http_request "POST" (boshurl ip) (strcatlist XmppBoshReOpenStream1::(itoa id)::XmppBoshReOpenStream2::(xSession.sGate.pSId)::XmppBoshReOpenStream3::xSession.sDomain::XmppBoshReOpenStream4::nil) fixarg3 #XmppBoshRead xSession HTTP_NORMAL -> lasthttp in
            set xSession.sGate.pBoshV.yHttpList = [lasthttp time nil id]::xSession.sGate.pBoshV.yHttpList; // On ajoute la requete à la liste de requete
        set xSession.sGate.pBoshV.yMsgId = xSession.sGate.pBoshV.yMsgId + 1
    );
0;;


fun XmppBoshSetUp ip xSession =
    if ip != nil then (
        set xSession.sLastIOTime = time - TcpServerNoResponseTimeOut;
        set xSession.sGate.pBoshV.yServerIp = ip;
    0)else (
        XmppSessionUnreachable 0);
0;;


fun XmppBoshIdle xSession =

    // Suppression des requetes trop longues
    let hd xSession.sGate.pBoshV.yHttpList -> hdhttp in
    let tl xSession.sGate.pBoshV.yHttpList -> tlhttp in
    let nil -> UpdatedList in
    (
        while hdhttp != nil do (                            // Mise à jour de la liste de requete
            let hdhttp -> [Req Time xData Id] in
            (
                if time - Time > XmppBoshHttpTimeOut then // Requete trop longue, on a supprime
                    (http_abort Req; 0)
                else
                    (set UpdatedList = hdhttp::UpdatedList; 0)
            );
            set hdhttp = hd tlhttp;
            set tlhttp = tl tlhttp
        );
        set xSession.sGate.pBoshV.yHttpList = UpdatedList
    );

    // Si la liste est vide, on envoie une espace.
    if xSession.sGate.pBoshV.yHttpList == nil then
            XmppGateSend xSession " ";  // si il n'y a plus rien dans la liste, on maintient la connexion
0;;































// ---------------------------------------------------------
// XMPP > CONNECT, SEND, IDLE in TCP or BOSH
// ---------------------------------------------------------

fun XmppGateInfo xSession =
    _xmpp_debug "***************************************";

    // DEBUG AFFICHAGE DE LA QUEUE
    _xmpp_debug "INQUEUE : ";
    let hd xSession.sInQueue -> hdM in
    let tl xSession.sInQueue -> tlM in
    (
        while hdM != nil do (
            XMLPrintContent hdM 5;
            _xmpp_debug "-------------------------------";
            set hdM = hd tlM;
            set tlM = tl tlM
        )
    );

    // DEBUG AFFICHAGE DE LA QUEUE
    _xmpp_debug "OUTQUEUE : ";
    let hd xSession.sOutQueue -> hdM in
    let tl xSession.sOutQueue -> tlM in
    (
        while hdM != nil do (
            let hdM -> [NextState To Type Content] in
            (
                _xmpp_debug match NextState with (ssLogging -> "Logging") | (ssBind -> "Bind") | (ssStartSession -> "UnBind") | (_ -> "Autre");
                _xmpp_debug strcatlist To::"-"::nil;
                _xmpp_debug Content;
                _xmpp_debug "-------------------------------"
            );
            set hdM = hd tlM;
            set tlM = tl tlM
        )
    );
    _xmpp_debug strcatlist "JID Actuel : "::xSession.sJID::nil;
    _xmpp_debug strcatlist "Previous Resource : "::xSession.sPreviousResource::nil;
    _xmpp_debug strcatlist "Ressource : "::xSession.sResource::nil;
    _xmpp_debug strcatlist "Next Resource : "::xSession.sNextResource::nil;
    _xmpp_debug strcatlist "Stream State : ":: (xmppStateToStr xSession.sState ) :: nil;
    _xmpp_debug strcatlist "gBusy : "::(itoa xmpp_busy_status)::nil;
    _xmpp_debug "***************************************";
    _xmpp_debug " ";_xmpp_debug " "
;;


//## fonction appellée quand on a été déconnecté du serveur xmpp et qu'on veut se reconnecter.
fun XmppGateReconnect xSession displayLeds =
    _xmpp_debug "XmppGateReconnect";
    // On reinitialise la session.
    set xSession.sStatus = sOpening;
    set xSession.sNonce = nil;
    set xSession.sDisplayLeds = displayLeds;
    set xSession.sState = ssLogging;
    set xSession.sLastIOTime = time;
    set xSession.sNextRestart = -1;
    set xSession.sAlgo = nil;
    if xSession.sGate.pActualMode == nil then
    (
        if xSession.sGate.pTcpV != nil then (
            set xSession.sGate.pBoshV = nil;
            set xSession.sGate.pMode = pTcp;
            set xSession.sGate.pTry = 3;
            set xSession.sGate.pActualMode = 1 // Mode TCP
        )else (
            set xSession.sGate.pTcpV = nil;
            set xSession.sGate.pMode = pBosh;
            set xSession.sGate.pTry = 1;
            set xSession.sGate.pActualMode = 2 // Mode BOSH
        )
    );
    //_xmpp_debug strcatlist "TRY TOO LONG... TRY("::(itoa xSession.sGate.pTry)::") ON NEXT SERVER"::nil;
    set xSession.sGate.pTry = xSession.sGate.pTry - 1;      // on met à jour le nombre d'essais
    set xSession.sLastIOTime = time;                    // on met à jour la derniere action
    if xSession.sGate.pTry >= 0 then                    // on continue de tester sur en tcp sur le 5222
    (
        if xSession.sGate.pActualMode == 1 then (
            set xSession.sGate.pStatus = pOpening;
            DnsSrvCb nil fixarg3 #XmppTcpReOpen xSession    // on appel le callback DNS qui contient les autres serveurs à tester
        )
        else (
            set xSession.sGate.pStatus = pOpening;
            dnsreq xSession.sDomain fixarg2 #XmppBoshSetUp xSession              // On cherche l'ip du port 80
        );
        0
    )else(  // on passe en BOSH ou en TCP suivant le mode duquel en vient!
        if xSession.sGate.pActualMode == 1 then (
            //_xmpp_debug "Now we try in BOSH";
            set xSession.sGate.pActualMode = 2;
            set xSession.sGate.pTry = 1;
            set xSession.sGate.pTcpV = nil;     // On supprime le tcp
            set xSession.sGate.pMode = pBosh;   // On passe en Bosh
            set xSession.sGate.pStatus = pOpen;
            let [yParent:xSession yHttpList:nil yMsgId:((time_ms*time)%1000) yServerIp:nil] -> newBosh in
                set xSession.sGate.pBoshV = newBosh;    // On déclare la nouvelle structure bosh
        dnsreq xSession.sDomain fixarg2 #XmppBoshSetUp xSession;        // On cherche l'ip du port 80
            set xSession.sLastIOTime = time;          // Mise à jour
            0
        )else(
            //_xmpp_debug "Now we try in TCP";
            set xSession.sGate.pActualMode = 1;
            set xSession.sGate.pTry = 3; // on remet le nombre d'essais à faire en TCP à 3
            set xSession.sGate.pMode = pTcp;
            set xSession.sGate.pBoshV = nil;
            set xSession.sGate.pStatus = pOpening;
            DnsSrvCb nil fixarg3 #XmppTcpReOpen xSession;   // on appel le callback DNS qui contient les autres serveurs à tester
            0
        );
        0
    );
    0
;;

// Is executed while we don't reach the stream
fun XmppGateConnect xSession =
    _xmpp_debug "XmppGateConnect";
    if xSession.sGate == nil then // New Session, Create the Gate
    (
        _xmpp_debug strcatlist "gate nil. DNS SRV REQUEST ON : "::xSession.sDomain::nil;
        let [pParent:xSession pMode:pTcp pStatus:pOpening pTry:3 pTcpV:nil pBoshV:nil pActualMode:nil] -> newGate in        // On crée la structure XmppGate
        (
            set xSession.sGate = newGate;                                       // on la sauvegarde
            DnsSrv strcatlist "_xmpp-client._tcp."::xSession.sDomain::nil fixarg3 #XmppTcpOpen xSession     // et on lance la première requête
        );
        set xSession.sLastIOTime = time;                                            // on met à jour la derniere action
        0
    )else
    (
        match xSession.sGate.pStatus with
        (pOpening -> // On essai d'atteindre le serveur
            _xmpp_debug "pOpening";
            if (time - xSession.sLastIOTime) > TcpServerNoResponseTimeOut then  // Si on dépasse le temps d'attente
            (
                _xmpp_debug "timeout";
                // On se reconnecte
                set xSession.sGate.pStatus = pClose;
                set xSession.sStatus = sClosed;
                XmppGateReconnect xSession xSession.sDisplayLeds
            );
        0)|(pOpen -> // On envoie le stream
            if (time - xSession.sLastIOTime) > TcpServerNoResponseTimeOut then  // Si on a bien envoyé le stream, on ne fait rien
            (
                set xSession.sLastIOTime = time;        // Mise à jour
                XmppGateOpenStream xSession     // Ouverture de stream
            );
        0)|(pInStream -> // On est dans le stream
            // ON ATTEND POUR FAIRE LE LOGIN
            Secho "___";
        0)|(pClose -> // On est dans la boucle d'attente
                        // ON ATTEND POUR FAIRE LE LOGIN
                        Secho "___";
        0)|(_ -> _xmpp_debug "ERREUR!!"; 0)
    )
    ;;

// Call the function to open the xmpp stream
fun XmppGateOpenStream xSession =
    match xSession.sGate.pMode with
    (pTcp -> XmppTcpOpenStream xSession ) | (pBosh -> XmppBoshOpenStream xSession );
0;;

fun XmppGateReOpenStream xSession =
    if xSession.sGate.pActualMode == 2 then (
         XmppBoshReOpenStream xSession
    )
    else (
        XmppTcpOpenStream xSession
    );
0;;

// Is called when a the stream is opened
fun XmppGateStreamOpened xSession =
    set xSession.sGate.pStatus = pInStream;
    let [clINT:"int" clASR:"asr" clPPT:"ppt" clRFID:"rfid" clITMODE:"itmode" clSOURCES:"sources"] -> newsCl in
    (
        set xSession.sState = ssLogging;
        set xSession.sOutQueue = nil;
        set xSession.sInQueue = nil;
        set xSession.sStanzaID = 0;
        set xSession.sClients = newsCl
    );
0;;

fun XmppGateStreamClosed xSession Mode =
    // la connection a déconné. On pourrait essayer de gentiment relancer la connection, mais le plus efficace est de simplement rebooter le bunny.
    _xmpp_debug "gate stream closed, rebooting";
    reboot 0x0407FE58 0x13fb6754
;;

// SEND SOMETHING IN TCP OR BOSH
fun XmppGateSend xSession xData =
    _xmpp_debug strcatlist "Sending : "::xData::"(end)"::nil;
    //if (match xSession.sGate.pMode with
    //(pTcp -> XmppTcpSend xSession xData ) | (pBosh -> XmppBoshSend xSession xData )) == nil then // Si on a un retour nil, il y a un probleme
    //      XmppGateStreamClosed xSession xSession.sGate.pMode; // Stream Closed, problem!
    match xSession.sGate.pMode with
    (pTcp ->
        if ( (XmppTcpSend xSession xData) == nil ) then
            XmppGateStreamClosed xSession xSession.sGate.pMode;     // Stream Closed, problem!
        nil
    ) | (pBosh ->
        if ( (XmppBoshSend xSession xData) == nil ) then (
            _xmpp_debug "We are deconnected (stream closed in Bosh)";
            XmppSessionIsDisconnected xSession
        );
        nil);
0;;


/**
    Called by XmppSessionIdle (which is called at the end of each "loop" turn) if the xmpp session is "up & running"
*/
fun XmppGateIdle xSession=
#ifdef XMPP_DO_PING
    // "ping" stuff
    // send a ping packet, to know reliably if we're still connected with the server
    // if there is an ping packet sent, check if the reply did not timeout
    if (nil != xSession.sLastPingIqId) then // there is a ping packet sent, check timeout
    (
        if (time - xSession.sLastPingTime > XmppPingMaxReponseDelay) then
                XmppSessionIsDisconnected xSession
    )
    else if (time - xSession.sLastPingTime > XmppPingDelay) then
    (
         _xmpp_debug "PING time to send a ping";
         XmppGateSend xSession (xmpps_createStanza xSession (xmpps_OurJID xSession) (xmpps_ServerJID xSession) stanzaIQGet "<ping xmlns='urn:xmpp:ping'/>");
         set xSession.sLastPingIqId = xSession.sStanzaID
    );
#endif
    // other stuff, protocol specific
    match xSession.sGate.pMode with
    (pTcp -> XmppTcpIdle xSession ) | (pBosh -> XmppBoshIdle xSession );
0;;



/** XEP-0199, ping.  This packet can be a packet related to ping,
 either a ping packet, or an answear to one of our ping packet.

 - xSession: xmpp session
 - xData: incoming stanza

 Returns 1 if xData was a ping-related packet and has been handled,
 0 otherwise.
*/
fun XmppGateHandlePingPackets xSession xData =
    (match (xData) with
      (ContentElement xmlStanza ->
          if ((!strcmp xmlStanza.nameS "iq")
                  && (let (Xml_FindFirstElementNamed xmlStanza "ping") -> ping in
               (nil != ping && (!strcmp Xml_GetElementAttribute ping "xmlns" "urn:xmpp:ping"))
             )
         ) then
            (
                // It _is_ a ping packet. Is it an answear or a request ?
                _xmpp_debug "PING received a ping packet";
                if (!strcmp (Xml_GetElementAttribute xmlStanza "type") "result") then
                ( // answear
                  _xmpp_debug "PING  an answear";
                  if (!strcmp (Xml_GetElementAttribute xmlStanza "id") (itoa xSession.sLastPingIqId)) then
                        ( _xmpp_debug "PING and YEAH"; set xSession.sLastPingTime = time; set xSession.sLastPingIqId = nil )
                    else
                      // not sure it should be this type of error sent, but I can't find anywhere in the xmpp spec
                      ( _xmpp_debug "PING and booooo...";
                          XmppSessionResponseSendErrorFeatureNotImplemented xSession
                                                                (Xml_GetElementAttribute xmlStanza "from")
                                                                                                                                (Xml_GetElementAttribute xmlStanza "id")
                        )
                )
            else if (!strcmp (Xml_GetElementAttribute xmlStanza "type") "get") then
                ( // request
                    if (!strcmp (Xml_GetElementAttribute xmlStanza "to") (xmpps_OurJID xSession)) then
                    (
                         XmppGateSend xSession (xmpps_createStanza xSession  // xSession
                                                       (Xml_GetElementAttribute xmlStanza "to")   // From
                                                                                                             (Xml_GetElementAttribute xmlStanza "from") // To
                                                                                                             (stanzaIQResult (Xml_GetElementAttribute xmlStanza "id"))   // Type
                                                                                                             "<ping xmlns='urn:xmpp:ping'/>") // content
                    )
                    else
                    (
                        XmppSessionResponseSendErrorFeatureNotImplemented xSession
                                                                                                                            (Xml_GetElementAttribute xmlStanza "from")
                                                                                                                            (Xml_GetElementAttribute xmlStanza "id")
                    )
                )
                else
                ( // probably invalid
                        XmppSessionResponseSendErrorFeatureNotImplemented xSession
                                                                                                                            (Xml_GetElementAttribute xmlStanza "from")
                                                                                                                            (Xml_GetElementAttribute xmlStanza "id")
                )
            )
            else
            (
                0 // not a ping packet
            )
        ) // end "ContentElement"
        | (_ -> 0 )  // not a ping packet nor a response to a ping packet
    )
;;


/**
    First "xmpp" function reading incoming stanzas
*/
fun XmppGateRead xSession xData =
    _xmpp_debug "Receive : ";
    if xData != nil then (
        XMLPrintContent xData 0;

        if (! XmppGateHandlePingPackets xSession xData) then
             XmppSessionRead xSession xData;
        0
    )else ( _xmpp_debug "NOTHING!"; 0 );
0;;




// NETTOIE CE QU'il FAUT AVANT LA SUPRESSION DU XSESSION
// TODO : SEPARER EN DEUX FONCTION (idle bosh & tcp);
fun XmppGateClear xSession =

    match xSession.sGate.pMode with
    (pBosh ->

        let hd xSession.sGate.pBoshV.yHttpList -> hdhttp in
        let tl xSession.sGate.pBoshV.yHttpList -> tlhttp in
        (
            while hdhttp != nil do (
                let hdhttp -> [Req Time xData Id] in
                (
                    http_abort Req
                );
                set hdhttp = hd tlhttp;
                set tlhttp = tl tlhttp
            )
        );
        set xSession.sGate.pBoshV.yHttpList = nil;
        nil
    ) | (_-> nil)
;;


















// ----- SASL
// parse realm="somerealm",nonce="OA6MG9tEQGm2hh",qop="auth",charset=utf-8,algorithm=md5-sess
// en "realm"::"somerealm"::"nonce"::"OA6MG9tEQGm2hh"...
fun _Sasl_challengeStr2List str l=
    if ((strlen str) == 0) then l
    else
        let 0 -> startPos in
        let strget str startPos -> char1 in
        let nil -> closingPos in (
            if char1 == 34 /* DOUBLE_QUOTE */ then (
                // quote : skip first and find last quote
                set startPos = 1;
                set closingPos = strstr str "\"" 1
            ) else (
                // find = or ,
                let strstr str "=" 0 -> equalPos in
                let strstr str "," 0 -> commaPos in (
                    set closingPos = equalPos;
                    if (closingPos == nil) then set closingPos = commaPos else if (commaPos != nil && commaPos < closingPos) then set closingPos = commaPos
                )
            );
            if closingPos == nil then
                // not found : return all
                str::l
            else (
                let (strsub str startPos (closingPos - startPos)) -> souschaine in
                let (strsub str (closingPos + (if char1 == 34 then 2 else 1)) nil) -> remaining in
                // recurse
                _Sasl_challengeStr2List remaining souschaine::l
            )
    );;

fun Sasl_challengeStr2List str=
    ReverseElements _Sasl_challengeStr2List str nil;;

fun SechoListWithSlash stringlist=
    Secho "/";
    for l=stringlist;l!=nil;tl l do ( Secho (hd l); Secho "/");;

// Creation d'une chaine aléatoire
const gSasl_RandomStringChars = "0123456789528460";; // 16 chars
fun Sasl_randomString nbChars=
    let strnew (nbChars+1) -> res in (
        for i=0; i<nbChars do ( strset res i (strget gSasl_RandomStringChars rand&15) );
        strset res nbChars 0;
        res
    );;

fun Sasl_response_value xSession authstring=
    // compute the response_value
    let strcatlist "xmpp/"::xSession.sDomain::nil -> digest_uri in
    let (md5bytes strcatlist xSession.sUsername::":"::(if (xSession.sRealm != nil) then xSession.sRealm else "")::":"::xSession.sPassword::nil) -> A11 in
    let strcatlist ":"::xSession.sNonce::":"::xSession.sCnonce::nil -> A12 in
    let strcatlist A11::A12::nil -> A1 in
    (
        //Secho "HEX(A11)="; Secho md5tohex A11;
        //Secho "HEX(A1)="; Secho md5tohex A1 ;
        let strcatlist authstring::":"::digest_uri::nil -> A2 in
        let strcatlist (md5tohex (md5bytes A1))::":"
                        ::xSession.sNonce::":"
                        ::"00000001"::":"
                        ::xSession.sCnonce::":"
                        ::xSession.sQop::":"
                        ::(md5tohex (md5bytes A2))
                        ::nil -> theValue in
             md5tohex md5bytes theValue
    );;

// Protocole challenge_response DIGEST_MD5
// challengeText est la chaine codée
fun Sasl_processChallenge xSession challengeText=
    let nil -> xmlpacket in (
    if challengeText != nil then
    let B64toS challengeText -> decoded in if decoded != nil then // realm="somerealm",nonce="OA6MG9tEQGm2hh",qop="auth",charset=utf-8,algorithm=md5-sess
    let Sasl_challengeStr2List decoded -> decodedList in if decodedList != nil then (
        // Step One of http://www.ietf.org/rfc/rfc2831.txt

        let 0 -> phase in
        let 0 -> error in (
            let decodedList -> ll in
            while (ll != nil && !error) do (
                let hd ll -> tok in
                let hd tl ll -> val in (
                    if (!strcmp tok "nonce") then (
                        // only once
                        if xSession.sNonce != nil then (
                            _xmpp_debug "nonce already set ! : error";
                            set error = 1
                        ) else (set xSession.sNonce = val;set phase = 1;0)
                    )
                    else if (!strcmp tok "realm") then (set xSession.sRealm = val;0)
                    else if (!strcmp tok "charset") then (set xSession.sCharset = val;0)
                    else if (!strcmp tok "qop") then (set xSession.sQop = val;0)
                    else if (!strcmp tok "algorithm") then (
                        // only once
                        if xSession.sAlgo != nil then (
                            _xmpp_debug "algorithm already set ! : error";
                            set error = 1
                        ) else (set xSession.sAlgo = val;0)
                    ) else if (!strcmp tok "rspauth") then (
                        set phase = 2;
                        _xmpp_debug "rcv rspauth:";
                        let Sasl_response_value xSession "" -> myval in
                        if (!strcmp myval val) then (
                            Secholn "rspauth ok, snd response";
                            set xmlpacket = "<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>";
                            0
                        ) else (
                            Secholn "BAD rspauth='"; Secho val; Secho "', myval='"; Secho myval; Secho "'";0
                        );
                        0
                    )
                );

                // next doublon
                set ll = tl tl ll
            ); // while

            if (!error) then
            if (phase == 1) then (
                if (!strcmp xSession.sAlgo "md5-sess") then // check algorithm = md5-sess
                if (!strcmp xSession.sQop "auth") then // check qop = auth
                if (!strcmp xSession.sCharset "utf-8") then // check charset = utf-8
                (
                    _xmpp_debug "rcv challenge:";

                    // compute a new sCnonce
                    set xSession.sCnonce = Sasl_randomString 13;
                    //Secholn "cnonce='"; Secho gXmpps_cur.sCnonce; Secho "'";

                    // compute the response_value
                    let Sasl_response_value xSession "AUTHENTICATE" -> response_value in
                    let strcatlist "xmpp/"::xSession.sDomain::nil -> digest_uri in
                    let strcatlist
                        "username=\""::xSession.sUsername::"\","::
                        (if (xSession.sRealm != nil) then (strcatlist "realm=\""::xSession.sRealm::"\","::nil) else "")::
                        "nonce=\""::xSession.sNonce::"\","::
                        "cnonce=\""::xSession.sCnonce::"\","::
                        "nc=00000001"::",":: // ?? only one answer
                        "qop="::xSession.sQop::","::
                        "digest-uri=\""::digest_uri::"\","::
                        "response="::response_value::",":: //
                        "charset="::xSession.sCharset::
                        nil
                        -> response in
                    (
                        _xmpp_debug "snd response"; // ='"; Secho response; Secho "'";
                        set response = StoB64 response;
                        // send response
                        set xmlpacket = strcatlist "<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>"::response::"</response>"::nil;
                        0
                    )
                ) // if
            )
        ) // let error
        );
    xmlpacket) // let xmlpacket
;;























// ----- JID utils
// JID = [ node "@" ] domain [ "/" resource ]
fun xmpps_JIDNode jid=
    let strstr jid "@" 0 -> arobPos in
    if (arobPos != nil) then strsub jid 0 arobPos;;

fun xmpps_JIDResource jid=
    let strstr jid "/" 0 -> slashPos in
    if (slashPos != nil) then strsub jid slashPos+1 nil;;

fun xmpps_JIDPlatform jid=
    let strstr jid "@" 0 -> arobPos in
    let strstr jid "/" arobPos -> slashPos in
    (
        Iecholn arobPos; Iecholn slashPos;
        Secholn strsub jid (arobPos+1) (slashPos - arobPos -1);
        if ((nil!=arobPos) && (nil!=slashPos)) then
            strsub jid (arobPos+1) (slashPos - arobPos -1)
        else
            nil
    )
;;

/**
 * Retourne le JID de la plateforme, pour une resource donnée.
 */
fun xmpps_PlatformJID xSession resource =
    strcatlist resource ::"@"::XmppVioletObjectsComponent::"/"::resource::nil;;

/**
 * Retourne le JID du serveur
 */
fun xmpps_ServerJID xSession =
    xSession.sDomain;;

/**
 * Retourne notre JID courant.
 */
fun xmpps_OurJID xSession =
    xSession.sJID;;

/**
 * Retourne un JID pour le bind.
 */
fun xmpps_BindJID xSession resource =
    strcatlist xSession.sUsername::"@"::xSession.sDomain::"/"::resource::nil;;

// -----------------------------------



















// -----------------------------------
// requetes Stanza (IQ / MESSAGE / PRESENCE)

/*
 * Récupère l'id en cours
 * Incrémente l'ID courant
 */
fun xmpps_getNextStanzaId xSession =
    set xSession.sStanzaID = xSession.sStanzaID + 1;    // update stanza id
    itoa xSession.sStanzaID
;;

/*
 * Création de la chaine à envoyer pour un IQ / Message / Presence
 *
 * xSession session courante
 * From     from (jid complet) ou nil (pas d'attribut from)
 * To       jid complet ou nil (pas d'attribut to)
 * Type     type du stanza: stanzaIQGet, stanzaIQSet, stanzaMessage, stanzaPresence
 * Content  contenu de la stanza ou nil (pas de sous-élément)
 */
fun xmpps_createStanza xSession From To Type Content =
    let (match Type with                            // Si on a un iq (set, get), presence ou message
        (stanzaIQGet -> ["iq" " type='get'"])
        |(stanzaIQSet -> ["iq" " type='set'"])
        |(stanzaIQResult _Request_id -> ["iq" " type='result'"])    //<iq to="" from="" id="" type="result" />
        |(stanzaMessage -> ["message" ""])
        |(stanzaPresence -> ["presence" ""])
        |(stanzaIQError _Request_id -> ["iq" " type='error'"])
        )-> [ElementType Attributes] in
    let (match Type with
        (stanzaIQResult Request_id -> Request_id)
        |(stanzaIQError Request_id -> Request_id)
        |(_ -> (xmpps_getNextStanzaId xSession))) -> Id in
    (
        strcatlist "<"::ElementType::""::
            (if(From != nil) then strcatlist " from='"::From::"'"::nil else "")::
            (if(To != nil) then strcatlist " to='"::To::"'"::nil else "")::
            Attributes::" id='"::Id::"'>"::Content::"</"::ElementType::">"::nil
    )
;;

/**
 * Crée un paquet IQ pour faire un bind vers une nouvelle ressource.
 * Retourne la chaine.
 */
fun XmppCreateBindIQ xSession newRes =
    strcatlist "<iq "::
        //"from=\""::(xmpps_BindJID xSession newRes)::"\" "::
        "from=\""::(xmpps_BindJID xSession xSession.sPreviousResource)::"\" "::
        "to=\""::(xmpps_ServerJID xSession)::"\" "::
        "type='set' id='"::(xmpps_getNextStanzaId xSession)::"'><bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'><resource>"::newRes::"</resource></bind></iq>"::nil
;;

fun XmppCreateXmlPacket xSession from to type content resource =
    let "" -> xmlPacket in (
    if (resource != nil) then (
        let "" -> strFrom in
        if (resource != "") then (
            if (xSession.sPreviousResource!=nil) then set strFrom = (xmpps_BindJID xSession xSession.sPreviousResource)
            else
                if (xSession.sResource!=nil) then set strFrom = (xmpps_BindJID xSession xSession.sResource)
                else set strFrom = (xmpps_BindJID xSession resource);
            set xmlPacket = strcatlist "<iq "::
                    "from=\""::strFrom::"\" "::
                    "to=\""::(xmpps_ServerJID xSession)::"\" "::
                    "type='set' id='"::(xmpps_getNextStanzaId xSession)::"'><bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'><resource>"::resource::"</resource></bind></iq>"::nil
        )
        else set xmlPacket = nil
    )
    else (
        if (from == nil ) && (to == nil) && (type == nil) && (content == nil) then set xmlPacket = " "
        else
        let (match type with                                            // Si on a un iq (set, get), presence ou message
        (stanzaIQGet -> ["iq" " type='get'"])
        |(stanzaIQSet -> ["iq" " type='set'"])
        |(stanzaIQResult _Request_id -> ["iq" " type='result'"])        //<iq to="" from="" id="" type="result" />
        |(stanzaMessage -> ["message" ""])
        |(stanzaPresence -> ["presence" ""])
        )-> [ElementType Attributes] in
            let (match type with
                (stanzaIQResult Request_id -> Request_id)
                |(_ -> (xmpps_getNextStanzaId xSession))) -> id in
            (
                set xmlPacket = strcatlist "<"::ElementType::""::
                    (if(from != nil) then strcatlist " from='"::from::"'"::nil else "")::
                    (if(to != nil) then strcatlist " to='"::to::"'"::nil else "")::
                    Attributes::" id='"::id::"'>"::content::"</"::ElementType::">"::nil
            )
    );
    xmlPacket
    )
;;


/*
 * Send Iq
 * Permet d'envoyer ou de mettre en liste d'attente un iq
 */
fun xmpps_sendStanza xSession NextState To Type Content =
    // On recupere le dernier xSession de la liste si celui donné en parametre est nul
    if xSession != nil then (
        if (    // condition pour l'ajout en queue de l'iq
            match xSession.sState with
            (ssFree ->
                if xSession.sOutQueue == nil then ( // si la queue est vide, on envoie
                    //let xmpps_createStanza xSession (xmpps_OurJID xSession) To Type Content -> XML in // on construit la requete
                    //(
                    let xmpps_OurJID xSession -> From in
                    (
                        if NextState != nil then
                            set xSession.sState = NextState;    // On verrouille
                        XmppSessionSend xSession [xSession From To Type Content nil] //XML
                    );
                0 )else 1   // 1 pour ajout en queue
            )|(_ -> 1 )

        ) == 1 then ( // Si on doit faire un ajout en queue -- cas ou il y a le verrou, ou que la queue n'est pas vide
            let [NextState To Type Content] -> tlQueue in
                set xSession.sOutQueue = conc xSession.sOutQueue tlQueue::nil
        )
    )else
        if XmppGlobalSession != nil then
            xmpps_sendStanza XmppGlobalSession NextState To Type Content
;;































// ---------------------------------------------------------
// XMPP SESSION
// ---------------------------------------------------------


// This open a new Xmpp Session
fun XmppSessionStart domain displayChor=
    _xmpp_debug strcatlist "Xmpp Session Start on : "::domain::nil;
    if displayChor == 1 then leds_set_all RGB_GREEN;     // DISPLAY STATUS WITH LIGHT TODO
    if XmppGlobalSession != nil then XmppSessionStop XmppGlobalSession;
    let [sStatus:sOpening sUsername:(webmac netMac) sPassword:_xmpp_get_password sDomain:domain/*"xmpp-dev.nabaztag.com"*/ sDisplayLeds:displayChor sState:ssLogging sLastIOTime:time sNextRestart:-1 sPacketQueue:nil sDataToSend:[nil 0 0] sLastPingTime:time sLastPingIqId:nil ] -> NewSession in
    (
        set XmppGlobalSession = NewSession
    );;

// Delete the Xmpp Session from the chain.
fun XmppSessionStop XmppSession=
    set XmppGlobalSession = nil;
    0;;


// Send Something
fun XmppSessionSend xSession data=
    if (xSession.sPacketQueue == nil) then
        set xSession.sPacketQueue = [xSession.sState data]::nil
    else
        let [xSession.sState data] -> newPacket in
            set xSession.sPacketQueue = newPacket::xSession.sPacketQueue;
0;;

// Envoie un message immédiatement
fun XmppSessionResponseSend xSession data=
    if (data!=nil) then
        XmppGateSend xSession data;
0;;


// envoie un message de type iq error feature not implemented
fun XmppSessionResponseSendErrorFeatureNotImplemented xSession to id =
    XmppSessionResponseSend
        xSession
        (xmpps_createStanza
            xSession
            xSession.sJID /* FROM */
            to /* To */
            (stanzaIQError id)
            ( strcatlist
            // TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
                "<error type='cancel'>"
                :: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
                :: "</error>" :: nil)
        )
;;



// Send the message for one button
fun XmppSessionSendButtonMsg btn withEvent eventValue=
    _xmpp_debug strcatlist "XmppSessionSendButtonMsg btn="::(itoa btn)::nil;
    if (withEvent) then (_xmpp_debug strcatlist " eventValue="::(itoa eventValue)::nil);

    /*
    let "" -> message in
    let "" -> packet in
    let "" -> from in
    let "" -> to in
    (
        set from = xmpps_OurJID XmppGlobalSession;
        _xmpp_debug from;
        set to = xmpps_PlatformJID XmppGlobalSession XmppGlobalSession.sClients.clINT;
        _xmpp_debug to;
        set message = strcatlist "<button xmlns=\"violet:nabaztag:button\"><clic>"::(itoa btn)::"</clic>"::(if withEvent then (if eventValue != nil then strcatlist "<event>"::(itoa eventValue)::"</event>"::nil else "<event/>") else "")::"</button>"::nil;
        _xmpp_debug message;
        set packet = XmppCreateXmlPacket XmppGlobalSession from to stanzaMessage message nil;
        _xmpp_debug packet;
        XmppGateSend XmppGlobalSession packet
    );
    _xmpp_debug "End of XmppSessionSendButtonMsg";
    */

    xmpps_sendStanza
        XmppGlobalSession
        nil // Next State
        xmpps_PlatformJID XmppGlobalSession XmppGlobalSession.sClients.clINT
        stanzaMessage /* Type */
        strcatlist "<button xmlns=\"violet:nabaztag:button\"><clic>"::(itoa btn)::"</clic>"::
        (if withEvent then (if eventValue != nil then strcatlist "<event>"::(itoa eventValue)::"</event>"::nil else "<event/>") else "")::
        "</button>"::nil;

0;;

// Send the message when a ears is moved
fun XmppSessionSendEarMsg leftValue rightValue=
    _xmpp_debug strcatlist "XmppSessionSendEarMsg l="::(itoa leftValue)::" r="::(itoa rightValue)::nil;

    /* SEND THE EAR POSITION NOW */
    xmpps_sendStanza
        XmppGlobalSession
        nil /* Next State */
        xmpps_PlatformJID XmppGlobalSession XmppGlobalSession.sClients.clINT
        stanzaMessage /* Type */
        strcatlist "<ears xmlns=\"violet:nabaztag:ears\"><left>"::(itoa leftValue)::"</left><right>"::(itoa rightValue)::"</right></ears>"::nil;
0;;

/**
 * Initie l'acquisition d'une nouvelle ressource en envoyant un paquet bind.
 */
fun XmppSessionRequestResource newRes =
    _xmpp_debug strcatlist "RequestResource!"::newRes::nil;
    /* REQUEST RESOURCE NOW */
    let XmppGlobalSession -> xSession in
        if (xSession.sNextResource == nil) then (
            if (strcmp newRes xSession.sResource) then ( // Si on n'a pas deja cette nouvelle ressource
                match xSession.sState with
                (ssFree -> // on est libre, on peux faire l'acquisition de la nouvelle ressource
                    set xSession.sPreviousResource = xSession.sResource;
                    set xSession.sNextResource = newRes;
                    set xSession.sState = ssBind;
                    XmppSessionSend xSession [xSession nil nil nil nil newRes];
                    0
                )|(_ -> set xSession.sNextResource = newRes; 0)
            ) // Sinon il ne se passe rien (parce qu'on a deja la ressource)
        ) else (
            match xSession.sState with
            (ssBind -> // On est en train de faire un bind, mettre le prochain bind dans NextRessource serai écrasé lors du retour du success
                set xSession.sNextResourceBinding = newRes
            )|(_ -> set xSession.sNextResource = newRes);   // Sinon, on peut mettre la ressource, elle sera traité au prochain ssFree
            0
        );
0;;

// Manage xmpp packet queue
fun XmppSessionRunR xSession xPacketQueue =
    if (xPacketQueue!=nil) then (
        let XmppSessionRunR xSession tl xPacketQueue -> s in
        let hd xPacketQueue -> [xState xData] in
        let xData -> [theSession theFrom theTo theType theContent theResource] in
            if (xState==xSession.sState) then strcatlist s::(XmppCreateXmlPacket theSession theFrom theTo theType theContent theResource)::nil
            else nil
    );;


fun sendPkts pktList state =
    if nil==pktList then [ nil nil ]
    else
        let hd pktList -> pkt in
        let pkt -> [pktState pktData] in
            if pktState==state then
                let sendPkts tl pktList state -> [ newList data2send ] in
                let pktData -> [theSession theFrom theTo theType theContent theResource] in
                    [ newList strcatlist (XmppCreateXmlPacket theSession theFrom theTo theType theContent theResource)::data2send::nil ]
            else (
                set XmppGlobalSession.sState = pktState; // On change de statu
                [ pktList nil ]
            )
;;


fun XmppSessionRun=
    if (XmppGlobalSession.sPacketQueue!=nil) then (
        let sendPkts rev XmppGlobalSession.sPacketQueue nil XmppGlobalSession.sState -> [ newList data2send] in
        (
            set XmppGlobalSession.sPacketQueue = newList;
            XmppGateSend XmppGlobalSession data2send
        )
    );
    JobRun;;


var lastIdle = 0;;
var tmpi=0;; //DEBUG

// Manage all Xmpp Session
fun XmppSessionIdle=
    let time_ms - lastIdle -> Checking in
    (
        if (Checking < 0 || Checking > 100) then // ON TEST TOUTES LES 100ms
        (
            set lastIdle = time_ms;
            let XmppGlobalSession -> xSession in
            let nil -> UpdateXmppSession in
            (
                    match xSession.sStatus with
                    (sOpening -> // We are trying to open a connexion (jabber is not reached yet)
                    // on ne renvoie rien.
                        XmppGateConnect xSession;   // Try to connect (TCP or BOSH)
                        if (xSession.sDisplayLeds == 1) then
                            leds_set_state (if (xSession.sGate != nil) then (match xSession.sGate.pMode with (pTcp -> LEDS_STATE_XMPP_OPENING_XMPP_TCP) | (pBosh -> LEDS_STATE_XMPP_OPENING_XMPP_BOSH)) else LEDS_STATE_XMPP_OPENING_XMPP);
                    0)|(sLogging ->
                        _xmpp_debug "TRY TO LOGGIN";
                        if xSession.sNextRestart < time then
                            XmppSessionIsDisconnected xSession
                        else ( Iecho time; Secho " "; Iecho xSession.sNextRestart; 0);
                    0)|(sLoggedin ->
                        _xmpp_debug "LOGGED IN";
                        if xSession.sNextRestart < time then
                            XmppSessionIsDisconnected xSession;
                    0)|(sOpened -> /*Debug if (time%5 == 0) then (if tmpi == 1 then (XmppGateInfo xSession; set tmpi = 0)) else set tmpi = 1; */
                        XmppGateIdle xSession ;
                        if xSession.sLastReadTime + XmppSessionReadTimeout < time then (
                            // On n'a pas eu de nouvelle du serveur depuis XmppSessionReadTimeout
                            XmppSessionIsDisconnected xSession
                        ) else (
                            if xSession.sNextRestart > 0 then (
                                if xSession.sNextRestart > time then
                                    XmppSessionIsDisconnected xSession
                            )
                        );
                    0)|(sClosed -> // la session est fermee...
                    0)|(sRegistrationError -> leds_set_all RGB_RED; nil; // TODO _xmpp_debug "HERRRRE IN ERROR";
                    0)|(_ -> 0);
                0
            )
        )
    );
    JobRun;;

fun XmppSessionUnreachable id =
    if id == 0 then
        _xmpp_debug "Can't reach the server on port 80";
0;;

fun XmppSessionSetStatus xSession xStatus =
    set xSession.sStatus = xStatus;
    XmppSessionUpdate xSession;
0;;


// définie tout à la fin
proto stopEverythingAndResetToIdle 0;;

// le nombre de secondes maximum qu'on peut attendre avant d'essayer de se reconnecter
// au serveur xmpp si on a été déconnecté
const XMPP_MAX_NB_SECS_BEFORE_TRYING_TO_RECONNECT = 30;;

fun XmppSessionIsDisconnected xSession=

    // on arrête tout ce qu'on est en train de faire, afin de ne pas
  // avoir un problème avec l'état du lapin : on gère mal de ne pas
    // être en idle à la reconnection...
    stopEverythingAndResetToIdle;

    match run_get_state with
    (xmppReconnectRun _ -> 0)
    |(
        _ ->
            // on attend au moins 5 secondes, plus un temps aléatoire entre 0 et 30 secondes, avant de se
            // reconnecter, ceci afin d'éviter, en cas de crash du serveur, que tous les lapins se reconnectent
            // en même temps
            let random XMPP_MAX_NB_SECS_BEFORE_TRYING_TO_RECONNECT -> randomWaitTimeInSecs in
                run_set_state (xmppReconnectRun [(time_ms + 5000 + 1000 * randomWaitTimeInSecs) xSession run_get_state]);
    0);
    set xSession.sStatus = sClosed;
    set xSession.sGate.pStatus = pClose;
0;;


fun XmppSessionUpdate xSession =

    match xSession.sStatus with     // XmppSessionUpdate should be called when we want to change the status of the connexion
    (sOpening ->    set xSession.sNextRestart = time + 12;  // Update for the next restart
    0)|(sLogging -> set xSession.sNextRestart = time + 12;  // Update for the next restart
    0)|(sLoggedin -> set xSession.sNextRestart = time + 12; // Update for the next restart
        if ears_is_initialized != 1 then
            ears_init; // we init the ears
        run_set_state idleRun;        // On s'est connecté.
    0)|(sOpened -> set xSession.sNextRestart = -1;  // Update for the next restart
    0)|(sClosed ->
        /* TODO!! */
        //restart session after 10 seconds
        //let XmppSession.sCnx.xDomain -> xdomain in
            //Xmpps_setwaitAndRestartSessionRun xdomain 10; // restart session after 10 seconds*/
    0)|(sRegistrationError ->
        /* TODO!!*/
        // restart session after 5mn
        //set Xmpps_closedSince = time;
        //let XmppSession.sCnx.xDomain -> xdomain in (
            //XmppSessionStop;
            // just to be sure that all is clean
            //Secho "Xmpp Session error : waiting 5mn and restart"; Secho "domain="; Secholn xdomain;
            //if (xdomain != nil) then
            //  run_set_state waitAndRestartSessionRun [time+(5*60) xdomain]
        //);
    0)|(_->0);
0;;


















/**
 * Fonction qui lit les paquets entrants.
 */
fun XmppSessionRead xSession PaquetXml =

    set xSession.sInQueue = conc xSession.sInQueue PaquetXml::nil; // Ajout en queue du dernier element

    /*
    // DEBUG AFFICHAGE DE LA QUEUE
    _xmpp_debug "INQUEUE : ";
    let hd xSession.sInQueue -> hdM in
    let tl xSession.sInQueue -> tlM in
    (
        while hdM != nil do (
            XMLPrintContent hdM 5;
            _xmpp_debug "-------------------------------";
            set hdM = hd tlM;
            set tlM = tl tlM
        )
    );

    // DEBUG AFFICHAGE DE LA QUEUE
    _xmpp_debug "OUTQUEUE : ";
    let hd xSession.sOutQueue -> hdM in
    let tl xSession.sOutQueue -> tlM in
    (
        while hdM != nil do (
            let hdM -> [NextState To Type Content] in
            (
                _xmpp_debug match NextState with (ssLogging -> "Logging") | (ssBind -> "Bind") | (ssStartSession -> "UnBind") | (_ -> "Autre");
                _xmpp_debug strcatlist To::"-"::nil;
                _xmpp_debug Content;
                _xmpp_debug "-------------------------------"
            );
            set hdM = hd tlM;
            set tlM = tl tlM
        )
    );*/

    // Traitement des retours du serveur
    let 0 -> dowhile in
    while match xSession.sState with (ssFree -> 1)|(_-> set dowhile = dowhile + 1; if dowhile == 1 then 1 else 0 ) && xSession.sInQueue != nil  do (
        let XmppSessionProcessR xSession xSession.sInQueue nil -> NextOne in
        (
            if NextOne == nil then  (_xmpp_debug "Erreur in XmppSessionRead(0)"; 0) // Pas logique car ProcessR, le retour n'est jamais nul
            else
            (
                let NextOne -> [NextState StrXml] in
                (
                    if NextState != nil then
                        set xSession.sState = NextState;
                    if StrXml != nil then
                        XmppGateSend xSession StrXml
                )
            )
        )
    );

    match xSession.sState with
    (ssFree -> // On est prêt a executer les commandes souhaitées

        if xSession.sNextResource != nil then ( // Si on doit changer de ressource
            if (!strcmp xSession.sNextResource xSession.sResource) then ( // Si les ressouces sont identiques il ne se passe rien
                set xSession.sNextResource = nil;   // UPDATE
            0)else (
                set xSession.sPreviousResource = xSession.sResource;    // On sauvegarde notre ressource actuelle qui va etre liberee
                set xSession.sState = ssBind;
                XmppGateSend xSession (XmppCreateBindIQ xSession xSession.sNextResource);
            0)
        );

        if xSession.sNextResource == nil then ( // sinon (finalement, il n'y a pas de NexResource
            let hd xSession.sOutQueue -> hdOutQueue in
            let tl xSession.sOutQueue -> tlOutQueue in
            (
                while match xSession.sState with (ssFree -> 1)|(_->0) && hdOutQueue != nil  do (
                    let hdOutQueue -> [NextState To Type Content] in
                    (
                        if NextState != nil then
                            set xSession.sState = NextState;
                        if Type != nil then
                            XmppGateSend xSession (xmpps_createStanza xSession (xSession.sJID) To Type Content)
                    );
                    set hdOutQueue = hd tlOutQueue;
                    set tlOutQueue = tl tlOutQueue
                );
                set xSession.sOutQueue = tlOutQueue // Mise à jour de la queue
            );
            0
        );

    1)|(_ -> 0)
;;


fun XmppGetRsc xSession =
    xSession.sResource
;;


fun XmppSessionProcessR xSession Liste Acc =
    let hd Liste -> PaquetXml in
    let tl Liste -> tlListe in
    let XmppSessionProcess xSession PaquetXml -> R in
    (
        if R != nil then (  // Si on a quelque chose a executer avant de faire le reste de la liste des elements reçus
            set xSession.sInQueue = conc Acc tlListe;   // Ceux qui sont arrivee en premier et non traitee :: reste de la liste
            R
        ) else  // R = nil > le paquet traitee n'est pas le bon, on le laisse dans la pile et on passe au suivant
        (
            if (hd tlListe) == nil then ( // il n'y a plus d'actions à faire
                if (hd Acc) != nil then
                    set xSession.sInQueue = conc Acc PaquetXml::nil // On met a jour la liste des actions encore a traiter
                else
                    set xSession.sInQueue = PaquetXml::nil; // On met a jour la liste des actions encore a traiter
                [nil nil] // On a traiter tous éléments de la liste de retour, on reste dans le même état et on passe à la suite
            )else ( // il nous reste encore des actions à faire
                if (hd Acc) != nil then
                    set Acc = conc Acc PaquetXml::nil
                else
                    set Acc = PaquetXml::nil;
                XmppSessionProcessR xSession tlListe Acc
            )
        )
    )
;;


proto XmppSessionProcessHandleStanzaIq 2;;


/**
 * Fonction qui traite un paquet entrant.
 */
fun XmppSessionProcess xSession PaquetXml =
    if PaquetXml == nil then (

        if (match xSession.sStatus with (sLoggedin ->1)|(_->0)) then (
            // In logging phase, try to reopen while negociating (base XMPP protocol)
            Secholn "ReOpenStreamXmpp";
            XmppGateReOpenStream xSession;
            /* ETAT SUIVANT */
            [nil nil]   // on ne renvoie rien.
        ) else (
            XmppSessionIsDisconnected xSession; // server closed stream
            /* ETAT SUIVANT */
            [nil nil] // on ne renvoie rien.
        )

    ) else (
        match PaquetXml with
        (ContentElement xmlStanza ->

            // On a vraiment reçu quelque chose
            match xSession.sStatus with (sOpened -> set xSession.sNextRestart = -1) | (_ -> 0);

            //type tXmppSessionStreamState = ssRegister1 | ssRegister2 | ssBind | ssUnBind | ssStartSession | ssGetSource | ssFree | ssLogging;;
            // ss pour Stream State
            // Register1 > Première phase de l'enregistrement
            // Register2 > Seconde phase de l'enregistrement
            // Bind > Acquisition de la Ressource
            // UnBind > Rendre la Ressource
            // Session > Creation d'une session
            // Source > Recupération des sources
            // Free > Connected, pret a faire les action
            // Logging > Process de loggin (auth, challenge, ...)
            match xSession.sState with










            (ssRegister1 -> // Première phase d'enregistrement
              _xmpp_debug "State : Register // Step 1";
                if !strcmp xmlStanza.nameS "iq" then (  // On a bien un iq

                    let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
                    let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
                    (
                        if (!strcmp type "result") then ( // Si on a un resultat, on continue

                            _xmpp_debug "Go to state : Register // Step 2 -- start register";
                            set xSession.sPassword = _xmpp_generate_password;   // On genere le mot de passe

                            // RETOURNE [ETATSUIVANT XML]
                            [ssRegister2 /* ETAT SUIVANT */
                                (xmpps_createStanza xSession
                                nil /* PAS DE FROM*/
                                (xmpps_ServerJID xSession) /* Vers le Serveur */
                                stanzaIQSet /* Type dy stanza Envoyee */
                                (strcatlist "<query xmlns=\"violet:iq:register\"><username>"::xSession.sUsername::"</username><password>"::(XorHexStr xSession.sPassword xSession.sUsername)::"</password></query>"::nil))]
                        )else if (!strcmp type "error") then (

                            _xmpp_debug "Error registering phase1";
                            http_request "GET" (sendmailxmppurl xSession.sDomain "FailureRegister1") nil nil HTTP_NORMAL;

                            // TODO : Gestion de l'erreur
                            XmppSessionSetStatus xSession sRegistrationError;
                            [   ssFree /* Pas d'etat suivant */
                                nil /* Pas de retour */
                            ]
                        )else (
                            _xmpp_debug strcatlist "Type unwanted : "::type::"!!!"::nil;
                            nil // On retourne rien, donc on met dans la queue
                        )
                    )
                )else nil   // stanza non souhaité, mise en attente










            )|(ssRegister2 -> // Seconde phase d'enregistrement

                _xmpp_debug "State : Register // Step 2";

                if !strcmp xmlStanza.nameS "iq" then (  // On a bien un iq

                    let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
                    let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
                    (
                        if (!strcmp type "result") then ( // Si on a un resultat, on continue
                            _xmpp_debug "Register succeeded";
                            _xmpp_set_password xSession.sPassword;

                            // NOT DISPLAYED! _xmpp_debug strcatlist "snd start login, user='"::xSession.sUsername::"', pwd='"::xSession.sPassword::"'"::nil;
                            _xmpp_debug "snd start login";

                            XmppSessionSetStatus xSession sLogging; // Change the status

                            /* ETAT SUIVANT */
                            [ssLogging "<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='DIGEST-MD5'/>"]
                        ) else if (!strcmp type "error") then (

                            _xmpp_debug "XML in=["; XMLPrintContent PaquetXml 0; _xmpp_debug "]";
                            _xmpp_debug "error registering phase2";

                            http_request "GET" (sendmailxmppurl xSession.sDomain "FailureRegister2") nil nil HTTP_NORMAL;

                            XmppSessionSetStatus xSession sRegistrationError;
                            /* ERREUR, ON LIBERE */
                            [ssFree nil]
                        ) else nil // stanza non souhaité, mise en attente
                    )
                )else nil   // stanza non souhaité, mise en attente











            )|(ssBind -> // On a lancé une demande de ressource
                _xmpp_debug strcatlist "State : Binding From : ":: xSession.sResource::" To : ":: xSession.sNextResource::" -- "::xSession.sPreviousResource::nil;

                if !strcmp xmlStanza.nameS "iq" then (  // On a bien un iq

                    let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
                    let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
                    (
                        if (!strcmp type "result") then (
                            let (Xml_FindFirstElementNamed xmlStanza "bind") -> bind in if (bind != nil) then
                            let Xml_GetElementAttribute bind "xmlns" -> xmlns in if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-bind") then
                            let (Xml_FindFirstElementNamed bind "jid") -> jid in if (jid != nil) then
                            let (Xmp_GetTextContent jid) -> jidstr in if (jidstr != nil) then (     // Nouveau JID reçu par le BIND

                                set xSession.sNextResource = nil; // on a reussit à arriver dans cette état
                                set xSession.sJID = jidstr; // Sauvegarde les JID et ressources
                                set xSession.sResource = xmpps_JIDResource xSession.sJID;

                                _xmpp_debug "Bind Done!";
                                _xmpp_debug strcatlist "JID="::xSession.sJID::nil;
                                _xmpp_debug strcatlist "Resource="::xSession.sResource::nil;

                                // Attention, si il y a eu un request ressource pendant l'etat bind, cette nouvelle ressource est dans sNextResourceBinding
                                // on la met donc dans sNextResource si cette variable n'est pas vide (cela permettra de passer dans la ressource requise au
                                // bon moment
                                if xSession.sNextResourceBinding != nil then (
                                    set xSession.sNextResource = xSession.sNextResourceBinding;
                                    set xSession.sNextResourceBinding = nil
                                );
                                set xSession.sState = ssStartSession;
                                [ssStartSession
                                    xmpps_createStanza xSession xSession.sJID (xmpps_ServerJID xSession) stanzaIQSet "<session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>"]
                            )
                        ) else if (!strcmp type "error") then (
                            _xmpp_debug "XML in=["; XMLPrintContent PaquetXml 0; _xmpp_debug "]";
                            _xmpp_debug "error binding";
                            [ssFree nil]    // on n'envoie rien.
                        ) else nil // stanza non souhaité, mise en attente
                    )
                )else nil // stanza non souhaité, mise en attente










            )|(ssUnBind -> // On est en train de rendre une ressource

                _xmpp_debug "State : UnBinding";

                if !strcmp xmlStanza.nameS "iq" then (  // On a bien un iq

                    let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
                    let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
                    (
                        if (!strcmp type "result") then (
                            _xmpp_debug "Unbind done!";
                            set xSession.sPreviousResource = nil;   // Reussite, on supprime alors l'ancienne ressource

                            _xmpp_debug strcatlist xSession.sJID::" : New Session"::nil;

                            /* ETAT SUIVANT */
                            [ssFree nil]

                        ) else if (!strcmp type "error") then (
                            _xmpp_debug "XML in=["; XMLPrintContent PaquetXml 0; _xmpp_debug "]";
                            _xmpp_debug "error unbinding";

                            /* ETAT SUIVANT */
                            [ssFree nil]
                        ) else nil // stanza non souhaité, mise en attente
                    )
                )else nil   // stanza non souhaité, mise en attente










            )|(ssStartSession -> // On est en train d'ouvrir une session

                _xmpp_debug "State : Opening a session";

                if !strcmp xmlStanza.nameS "iq" then (  // On a bien un iq

                    let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
                    let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
                    (
                        if (!strcmp type "result") then (

                            set xSession.sNextRestart = -1;
                            XmppSessionSetStatus xSession sOpened;
                            leds_set_state LEDS_STATE_XMPP_CONNECTED ;

                            _xmpp_debug "Session opened!";

                            if (!strcmp xSession.sResource "boot") then (
                                // request initial sources to="sources@xmpp.objects.violet.net/sources"
                                _xmpp_debug "Request for sources";
                                /* ETAT SUIVANT */
                                [
                                    ssGetSource
                                    xmpps_createStanza xSession
                                        xSession.sJID /* FROM */
                                        (strcatlist ( XmppVioletPlatformClient :: "@" :: (xmpps_ServerJID xSession) :: "/sources" :: nil))
                                        stanzaIQGet /* Type = iq & get */
                                        "<query xmlns=\"violet:iq:sources\"><packet xmlns=\"violet:packet\" format=\"1.0\"/></query>"
                                ]
                            ) else (
                                _xmpp_debug "Send Presence";
                                /* ETAT SUIVANT */
                                [   ssPresence
                                    xmpps_createStanza xSession
                                    xSession.sJID /* FROM */
                                    nil /* TO */
                                    stanzaPresence /* Type = iq & get */
                                    nil
                                ]
                            )
                        )else if (!strcmp type "error") then (
                            _xmpp_debug "XML in=["; XMLPrintContent PaquetXml 0; _xmpp_debug "]";
                            _xmpp_debug "error opening session";

                            /* ETAT SUIVANT */
                            [ssFree nil]
                        ) else nil // stanza non souhaité, mise en attente
                    )
                )else nil   // stanza non souhaité, mise en attente










            )|(ssPresence ->
                if (!strcmp xmlStanza.nameS "presence") then (      // Si on reçoit une présence
                    let Xml_GetElementAttribute xmlStanza "from" -> from in
                        _xmpp_debug strcatlist "Free now!  "::from::nil;
                    /* ETAT SUIVANT */
                    let (xmpps_BindJID xSession xSession.sPreviousResource) -> previousjid in
                        if (previousjid == nil) then (
                            [ssFree nil]
                        ) else (
                                                        [ssUnBind
                                                                 xmpps_createStanza xSession previousjid (xmpps_ServerJID xSession) stanzaIQSet strcatlist "<unbind xmlns='urn:ietf:params:xml:ns:xmpp-bind'><resource>"::xSession.sPreviousResource::"</resource></unbind>"::nil]
                                                 )
                )else
                    nil // on empile si on a pas un presence










            )|(ssGetSource -> // On est en train de récupérer les sources

                _xmpp_debug "State : Getting Sources";

                if !strcmp xmlStanza.nameS "iq" then (  // On a bien un iq

                    let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
                    let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
                    (
                        // verifier from plateforme xmpp.objects.violet.net
                        let Xml_GetElementAttribute xmlStanza "from" -> from in
                        if ( (strcmp (xmpps_JIDPlatform from) XmppVioletObjectsComponent) && (strcmp (xmpps_JIDNode from) XmppVioletPlatformClient) ) then (    // Si ce n'est pas la plateforme... Hacker?

                            _xmpp_debug "XML in=["; XMLPrintContent PaquetXml 0; _xmpp_debug "]";
                            _xmpp_debug strcatlist "Error : received msg from ":: from ::" dropped (" :: (xmpps_JIDPlatform from) :: ")" :: nil;

                            /* ETAT SUIVANT */
                            [xSession.sState nil]

                        ) else if (!strcmp type "result") then ( // Si on a un result

                            // EXECUTION DE LA TRAME DE RETOUR
                            let (Xml_GetElementAttribute xmlStanza "to") -> to in if (to != nil) then
                            let xmpps_JIDResource to -> resourceName in
                            let (Xml_FindFirstElementNamed xmlStanza "query") -> query in if (query != nil) then
                            let Xml_GetElementAttribute query "xmlns" -> xmlns in if (!strcmp xmlns "violet:iq:sources") then
                            let (Xml_FindFirstElementNamed query "packet") -> packet in if (packet != nil) then
                            let Xml_GetElementAttribute packet "xmlns" -> xmlns_packet in if (!strcmp xmlns_packet "violet:packet") then
                            let Xml_GetElementAttribute packet "format" -> format in if (!strcmp format "1.0") then
                            let Xml_GetElementAttribute packet "ttl" -> ttl in
                            let (Xmp_GetTextContent packet) -> data_64 in if (data_64 != nil) then
                            // decode trame
                            let B64toS data_64 -> ping_trame in (
                                //_xmpp_debug "ping_trame_64="; _xmpp_debug data_64;
                                _xmpp_process_incoming_trame ping_trame resourceName ttl
                            );

                            _xmpp_debug "We have the sources!";

                            /* ETAT SUIVANT */
                            [ssFree nil] // On repasse en libre
                        ) else if (!strcmp type "error") then (
                            _xmpp_debug "Error getting sources";
                            _xmpp_debug "XML in= ";
                            XMLPrintContent PaquetXml 0;

                            // Pas de resource donc on relance le process de connexion
                            XmppSessionIsDisconnected xSession;

                            // TODO : RELANCER 10 SECONDES APRES
                            //xmpps_scheduleIQ xSession (time + 10) iqSources xSession.sClients.clSOURCES "get" "<query xmlns=\"violet:iq:sources\"><packet xmlns=\"violet:packet\" format=\"1.0\"/></query>";
                            // Pour le moment on libère
                            [ssFree nil]
                        ) else nil  // stanza non souhaité, mise en attente
                    )
                )else nil   // stanza non souhaité, mise en attente











            )|(ssLogging -> // On n'est pas encore connecté

                _xmpp_debug "State Logging";

                if (!strcmp xmlStanza.nameS "stream:features") then (   // Si on a du détail sur le flux
                    // stream:features
                    // teste si on a un element 'mechanisms'. Si non, on stoppe tout de suite
                    _xmpp_debug "Receive stream:features";

                    // Ici, on exploite le fait que stream:features est ouvert avant authentification et
                    // après (une fois que ça a marché).

                    // mechanisms
                    let (Xml_FindFirstElementNamed xmlStanza "mechanisms") -> mechanisms in
                    if (mechanisms != nil) then (
                        let Xml_GetElementAttribute mechanisms "xmlns" -> xmlns in
                        if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-sasl") then (
                            // On devrait tester register / login ?
                            _xmpp_debug "Receive mechanisms";

                            // Register ou login ?
                            if (NOWREGISTER == 1 || xSession.sPassword == nil) then (
                                _xmpp_debug "No password (or not good) : start register";

                                /* ETAT SUIVANT */
                                [ssRegister1
                                xmpps_createStanza xSession xSession.sJID nil stanzaIQGet "<query xmlns='violet:iq:register'/>"]
                            )else(
                                //_xmpp_debug strcatlist "Start login, user ='"::xSession.sUsername::"', pass='"::xSession.sPassword::"'"::nil;
                                _xmpp_debug "Start login";
                                XmppSessionSetStatus xSession sLogging;

                                /* ETAT SUIVANT */
                                [ssLogging
                                "<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='DIGEST-MD5'/>"]
                            )

                        ) else (
                            _xmpp_debug "No SASL!";
                            /* ETAT SUIVANT */
                            [ssLogging nil]
                        )
                    ) else (
                        // bind: seconde ouverture de stream:features.
                        let (Xml_FindFirstElementNamed xmlStanza "bind") -> bind in
                        if (bind != nil) then ( // Si on reçoit bien un bind
                            let Xml_GetElementAttribute bind "xmlns" -> xmlns in
                            if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-bind") then (
                                _xmpp_debug "Receive Bind (in Logging)";

                                set NOWREGISTER = 0;

                                set xSession.sPreviousResource = nil;   // Pas de ressource précédente
                                /* ETAT SUIVANT */
                                [ssBind
                                XmppCreateBindIQ xSession "boot"]

                            ) else
                                [ssFree nil] // xmlns incorrect. TODO: envoyer une erreur.
                        ) else
                            [ssFree nil] // ni mechanism ni sasl. TODO: envoyer une erreur.
                    )


                ) else if (!strcmp xmlStanza.nameS "challenge") then (
                    let (Xmp_GetTextContent xmlStanza) -> Text in
                        /* ETAT SUIVANT */
                        [ssLogging Sasl_processChallenge xSession Text]


                ) else if (!strcmp xmlStanza.nameS "failure") then (
                    let Xml_GetElementAttribute xmlStanza "xmlns" -> xmlns in
                    if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-sasl") then (

                        _xmpp_debug "Failure to login. Warn server and re-register";
                        http_request "GET" (sendmailxmppurl xSession.sDomain "FailureLogin") nil nil HTTP_NORMAL;
                        // first reset all values set by login
                        set xSession.sNonce = nil;
                        set xSession.sCnonce = nil;
                        set xSession.sRealm = nil;
                        set xSession.sQop = "auth";
                        set xSession.sAlgo = nil;
                        set xSession.sCharset = nil;

                        set NOWREGISTER = 1;

                        XmppSessionIsDisconnected xSession;

                        // On s'enregistre a nouveau
                        /* ETAT SUIVANT */
                        [ssLogging nil /*xmpps_createStanza xSession xSession.sJID nil stanzaIQGet "<query xmlns='violet:iq:register'/>"*/]
                    )else (
                        /* ETAT SUIVANT */
                        [ssLogging nil]
                    )


                ) else if (!strcmp xmlStanza.nameS "success") then (
                    let Xml_GetElementAttribute xmlStanza "xmlns" -> xmlns in
                        if (!strcmp xmlns "urn:ietf:params:xml:ns:xmpp-sasl") then (
                            _xmpp_debug "rcv success, snd reopen stream";
                            // On doit réouvrir le stream
                            // TODO REVOIR
                            XmppSessionSetStatus xSession sLoggedin;
                            XmppGateReOpenStream xSession
                        );
                    [ssLogging nil]
                ) else  nil // stanza non souhaitee, on empile











            )|(ssFree -> // On est libre de faire les actions venant de la plateforme
                _xmpp_debug "State : we are free and ready";

                if !strcmp xmlStanza.nameS "iq" then (  // SI ON A UN IQ
                    XmppSessionProcessHandleStanzaIq xSession xmlStanza
                ) else if   (!strcmp xmlStanza.nameS "message") then (          // Si on a un message
                    _xmpp_debug "We got a message";

                    let  Xml_GetElementAttribute xmlStanza "id" -> id in
                    let (Xml_FindFirstElementNamed xmlStanza "packet") -> packet in
                    if (packet != nil) then (
                        let (Xml_GetElementAttribute xmlStanza "to") -> to in if (to != nil) then
                        let xmpps_JIDResource to -> resourceName in
                        let Xml_GetElementAttribute packet "xmlns" -> xmlns in if (!strcmp xmlns "violet:packet") then
                        let Xml_GetElementAttribute packet "format" -> format in if (!strcmp format "1.0") then
                        let Xml_GetElementAttribute packet "ttl" -> ttl in
                        let (Xmp_GetTextContent packet) -> data_64 in if (data_64 != nil) then
                        let B64toS data_64 -> ping_trame in
                            _xmpp_process_incoming_trame ping_trame resourceName ttl    // EXECUTION DE LA TRAME
                    );

                    /* ETAT SUIVANT */
                    [nil nil] //on ne change pas d'etat car si cela est fait dans _xmpp_process_incoming_trame (par exemple ssBind, on se fait avoir en l'enlevant)


                ) else if (!strcmp xmlStanza.nameS "presence") then (       // Si on reçoit une présence
                    let Xml_GetElementAttribute xmlStanza "from" -> from in
                        _xmpp_debug strcatlist "rcv presence from "::from::nil;
                    /* ETAT SUIVANT */
                    [nil nil]
                ) else if (!strcmp xmlStanza.nameS "stream:error") then (
                    _xmpp_debug "Erreur dans le flux!";
                    [nil nil]
                ) else /* ETAT SUIVANT */ [nil nil] /* Si il s'agit d'autre chose, on ne le prend pas en compte */




            )|(_ -> // On est dans un état inconnu ici, pas normal

                _xmpp_debug "State : starting?";
                _xmpp_debug "State : UNKNOWN!!";
                [nil nil]

            )

        ) | ( ContentText Texte ->
            _xmpp_debug strcatlist "Received text:'"::Texte::"', dropping"::nil;
            [nil nil] // on n'envoie rien.
        ) | (_ -> nil)
    )
;;



proto XmppSessionProcessHandleStanzaIqSet 2;;
proto XmppSessionProcessHandleStanzaIqGet 2;;
proto XmppSessionProcessHandleStanzaIqError 1;;


/**
    Utilisé pour le getrunningstate, convertit un etat du lapin sous forme textuelle
*/
fun xmppStateToStr state =
//          match xSession.sStatus with (sOpened -> set xSession.sNextRestart = -1) | (_ -> 0);
    match state with
            ( ssRegister1 -> "ssRegister1" )
        |   ( ssRegister2 -> "ssRegister2" )
        |   ( ssBind -> "ssBind" )
        |   ( ssUnBind -> "ssUnbind" )
        |   ( ssStartSession -> "ssStartSession" )
        |   ( ssGetSource -> "ssGetSource" )
        |   ( ssFree -> "ssFree" )
        |   ( ssLogging -> "ssLogging" )
        |   ( ssPresence -> "ssPresence" )
;;


/**
 Gère la réponse à apporter à un IQ

  xSession: les infos de session xmpp
  xmlStanza: l'iq reçu

  --> le couple [ action nouvel_etat ] pour savoir où aller dans la machine à état fini
*/
fun XmppSessionProcessHandleStanzaIq xSession xmlStanza =
    // check that message from xmpp.objects.violet.net or xmpp.platform.violet.net
    let Xml_GetElementAttribute xmlStanza "from" -> from in
    if ((strcmp (xmpps_JIDPlatform from) XmppVioletPlatformComponent)
            && (strcmp (xmpps_JIDPlatform from) XmppVioletObjectsComponent)
            && (strcmp (xmpps_JIDPlatform from) XmppVioletAppletComponent)) then (
        _xmpp_debug strcatlist "Error : received msg from "::from::"dropped"::nil;
        [ssFree nil]
    )
    else
    (
        let Xml_GetElementAttribute xmlStanza "id"      -> id in    // On recupere l'ID
        let Xml_GetElementAttribute xmlStanza "type"    -> type in  // et le type
        let (
            if (!strcmp type "set") then
                XmppSessionProcessHandleStanzaIqSet xSession xmlStanza
            else if (!strcmp type "get") then
                XmppSessionProcessHandleStanzaIqGet xSession xmlStanza
            else
                XmppSessionProcessHandleStanzaIqError type
            ) -> [ error answear newstate ] in
        (
            XmppSessionResponseSend xSession (xmpps_createStanza xSession
                xSession.sJID /* FROM */
                from /* To > Retour a l'envoyeur */
                (if 0==error then (stanzaIQResult id) else (stanzaIQError id))
                answear );
            newstate
        )
    )
;;


/**
    Gère un IQ de type "set"

  xSession: les infos de session xmpp
  xmlStanza: l'iq reçu

    --> [ contenu_de_la_reponse [ action nouvel_etat ]]
*/
fun XmppSessionProcessHandleStanzaIqSet xSession xmlStanza =
    let (
    // Si on reçoit un paquet "addresses", on met à jour les clients
    let (Xml_FindFirstElementNamed xmlStanza "addresses") -> addresses in
    let (Xml_FindFirstElementNamed xmlStanza "command") -> command in
    if (addresses != nil) then (
        let Xml_GetElementAttribute addresses "xmlns" -> xmlns in
        if (!strcmp xmlns "violet:iq:addresses") then (
            let addresses.content -> l in
            (
                while ((hd l) != nil) do (
                    let (hd l) -> xmlPaqi in (
                        match xmlPaqi with
                            (ContentElement subXml ->
                                if (!strcmp subXml.nameS "int") then (
                                    Secho "int=";
                                    set xSession.sClients.clINT = Secholn (Xmp_GetTextContent subXml)
                                ) else if (!strcmp subXml.nameS "asr") then (
                                    Secho "asr=";
                                    set xSession.sClients.clASR = Secholn (Xmp_GetTextContent subXml)
                                ) else if (!strcmp subXml.nameS "ppt") then (
                                    Secho "ppt=";
                                    set xSession.sClients.clPPT = Secholn (Xmp_GetTextContent subXml)
                                ) else if (!strcmp subXml.nameS "rfid") then (
                                    Secho "rfid=";
                                    set xSession.sClients.clRFID = Secholn (Xmp_GetTextContent subXml)
                                ) else if (!strcmp subXml.nameS "itmode") then (
                                    Secho "itmode=";
                                    set xSession.sClients.clITMODE = Secholn (Xmp_GetTextContent subXml)
                                ) else if (!strcmp subXml.nameS "sources") then (
                                    Secho "sources=";
                                    set xSession.sClients.clSOURCES = Secholn (Xmp_GetTextContent subXml)
                                );
                            0)|(_ -> 0)
                    );
                    set l = tl l
                )
            )
        );
        nil
    )
    else
    if nil != command then
    (
        let Xml_GetElementAttribute command "xmlns" -> xmlns in
        let Xml_GetElementAttribute command "node" -> node in
        let Xml_GetElementAttribute command "action" -> action in // action='execute'  est optionnel
        if (!strcmp xmlns "http://jabber.org/protocol/commands") then
            if (!strcmp node "getconfig") then
            ( strcatlist
                    "<command xmlns='http://jabber.org/protocol/commands' node='getconfig' status='completed'>"
                    :: "<x xmlns='jabber:x:data' type='result'><item>"
                    :: "<field var='bytecode_revision'><value>" :: getBytecodeRevision :: "</value></field>"
                    :: "<field var='wifi_ssid'><value>" :: (StoB64 config_get_wifi_ssid) :: "</value></field>"
                    :: "<field var='wifi_crypt'><value>" :: (itoa config_get_wifi_crypt) :: "</value></field>"
                    :: "<field var='net_dhcp'><value>" :: (itoa config_get_dhcp) :: "</value></field>"
                    :: "<field var='net_ip'><value>" :: (webip config_get_net_ip) :: "</value></field>"
                    :: "<field var='net_mask'><value>" :: (webip config_get_netmask) :: "</value></field>"
                    :: "<field var='net_gateway'><value>" :: (webip config_get_net_gw) :: "</value></field>"
                    :: "<field var='net_dns'><value>" :: (webip config_get_net_dns) :: "</value></field>"
                    :: "<field var='server_url'><value>" :: config_get_server_url :: "</value></field>"
                    :: "<field var='login'><value></value></field>"
                    :: "<field var='proxy_enabled'><value>" :: (itoa config_get_proxy) :: "</value></field>"
                    :: "<field var='proxy_ip'><value>" :: (webip config_get_proxy_ip) :: "</value></field>"
                    :: "<field var='proxy_port'><value>" :: (itoa config_get_proxy_port) :: "</value></field>"
                    :: "</item></x>"
                    :: "</command>"
                    :: nil
            )
            else if (!strcmp node "getrunningstate") then
            ( strcatlist
                "<command xmlns='http://jabber.org/protocol/commands' node='getrunningstate' status='completed'>"
                    :: "<x xmlns='jabber:x:data' type='result'><item>"
                    :: "<field var='connection_mode'><value>" :: (if (1 == xSession.sGate.pActualMode) then "tcp" else "bosh") :: "</value></field>"
                    :: "<field var='net_ip'><value>" :: (webip netip) :: "</value></field>"
                    :: "<field var='net_mask'><value>" :: (webip netmask) :: "</value></field>"
                    :: "<field var='net_gateway'><value>" :: (webip netgateway) :: "</value></field>"
                    :: "<field var='net_dns'><value>" :: (dns_list_to_str) :: "</value></field>"
                    :: "<field var='sState'><value>" :: (xmppStateToStr xSession.sState) :: "</value></field>"
                    :: "<field var='sResource'><value>" :: xSession.sResource :: "</value></field>"
                    :: "<field var='gItState'><value>" :: (itoa interactive_status) :: "</value></field>"
                    :: "<field var='gSleepState'><value>" :: (itoa sleep_status) :: "</value></field>"
                    :: "<field var='gStreamingState'><value>" :: (itoa streaming_status) :: "</value></field>"
                    :: "<field var='gProcessingState'><value>" :: (itoa chor_processing_status) :: "</value></field>"
                    :: "<field var='gProcessingWaitState'><value>" :: (itoa chor_processing_wait_status) :: "</value></field>"
                    :: "<field var='gBusyState'><value>" :: (itoa xmpp_busy_status) :: "</value></field>"
                    :: "<field var='gItApp'><value>" :: interactive_app :: "</value></field>"
                    :: "<field var='run'><value>" :: (runToStr run_get_state) :: "</value></field>"
                    :: "</item></x>"
                    :: "</command>"
                    :: nil
            )
        else
        (
            nil
        )
    )
    else
    (
        // si on reçoit un paquet "packet", on execute la trame reçue
        let (Xml_FindFirstElementNamed xmlStanza "packet") -> packet in
        if (packet != nil) then (
            let (Xml_GetElementAttribute xmlStanza "to") -> to in
            if (to != nil) then (
                let xmpps_JIDResource to -> resourceName in
                let Xml_GetElementAttribute packet "xmlns" -> xmlns in
                if (!strcmp xmlns "violet:packet") then (
                    let Xml_GetElementAttribute packet "format" -> format in
                    if (!strcmp format "1.0") then (
                        let Xml_GetElementAttribute packet "ttl" -> ttl in
                        let (Xmp_GetTextContent packet) -> data_64 in
                        if (data_64 != nil) then (
                            let B64toS data_64 -> ping_trame in
                             (_xmpp_process_incoming_trame ping_trame resourceName ttl ; nil)
                        )
                    )
                )
            )
        );
        nil
    )
    ) -> s in [ 0 s [ nil nil ]]
;;


/**
    Gère un IQ de type "get"

  xSession: les infos de session xmpp
  xmlStanza: l'iq reçu

    --> [ contenu_de_la_reponse [ action nouvel_etat ]]
*/
fun XmppSessionProcessHandleStanzaIqGet xSession xmlStanza =
    let (
        let (Xml_FindFirstElementNamed xmlStanza "query") -> query in
        if (nil!=query) then (
            let Xml_GetElementAttribute query "xmlns" -> xmlns in
            let Xml_GetElementAttribute query "node" -> node in
            // XEP-0092: Software Version (http://www.xmpp.org/extensions/xep-0092.html)
            if (!strcmp xmlns "jabber:iq:version") then
            (
                [ 0
                    strcatlist
                                        "<query xmlns='jabber:iq:version'>"
                                        :: "<name>" :: "Nabaztag/tag" :: "</name>"
                                        :: "<version>" :: getBytecodeRevision :: "</version>"
                                        :: "</query>" :: nil
                ]
            )
            // XEP-0030: Service Discovery (http://www.xmpp.org/extensions/xep-0030.html)
            // (support très très très partiel)
            else if (!strcmp xmlns "http://jabber.org/protocol/disco#info") then
            (
                if nil==node then
                    [ 0
                        strcatlist
                            "<query xmlns='http://jabber.org/protocol/disco#info'>"
                          :: "<feature var='jabber:iq:version'/>"
                            :: "<feature var='urn:xmpp:ping'/>"
                            :: "</query>" :: nil
                    ]
                else if (!strcmp node "getconfig") then
                    [
                        0
                        strcatlist
                            "<query xmlns='http://jabber.org/protocol/disco#info' node='getconfig'>"
                        :: "<identity name='Gets the configuration of the rabbit' category='automation' type='command-node'/>"
                            :: "<feature var='http://jabber.org/protocol/commands'/>"
                            :: "<feature var='jabber:x:data'/>"
                            :: "</query>" :: nil
                    ]
                else if (!strcmp node "getrunningstate") then
                    [
                        0
                        strcatlist
                            "<query xmlns='http://jabber.org/protocol/disco#info' node='getrunningstate'>"
                        :: "<identity name='Gets the running state of the rabbit' category='automation' type='command-node'/>"
                            :: "<feature var='http://jabber.org/protocol/commands'/>"
                            :: "<feature var='jabber:x:data'/>"
                            :: "</query>" :: nil
                    ]
                else // node qu'on ne connait pas
                    [
                        1
                        (strcatlist
                            // TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
                            "<error type='cancel'>"
                            :: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
                            :: "</error>" :: nil)
                    ]
            )
            else if (!strcmp xmlns "http://jabber.org/protocol/disco#items") then
            (
                if (!strcmp node "http://jabber.org/protocol/commands") then
                    [ 0
                        strcatlist
                            "<query xmlns='http://jabber.org/protocol/disco#items' "
                            :: "node='http://jabber.org/protocol/commands'>"
                        :: "<item jid='" :: xSession.sJID :: "' node='getconfig' name='Gets the configuration of the rabbit' />"
                        :: "<item jid='" :: xSession.sJID :: "' node='getrunningstate' name='Gets the running state of the rabbit' />"
                            :: "</query>" :: nil
                    ]
                else
                    // c'est un noeud qu'on ne connait pas : vide
                    [ 0
                        strcatlist
                            "<query xmlns='http://jabber.org/protocol/disco#items' "
                            :: "node='" :: node :: "' />"
                            :: nil
                    ]
            )
            else (
                [ 1
                    (strcatlist
                    // TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
                    "<error type='cancel'>"
                    :: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
                    :: "</error>" :: nil)
                ]
            )
        )
        else
         [ 1
            ( strcatlist
                    // TODO en premier lieu il faudrait (SHOULD)  mettre le xml qu'on a recu
                    "<error type='cancel'>"
                    :: "<feature-not-implemented xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>"
                    :: "</error>" :: nil)
            ]
        ) -> [ error answear ]
    in [ error answear [ nil nil ] ]
;;


/**
    Gère un IQ de type inconnu (non géré)
*/
fun XmppSessionProcessHandleStanzaIqError type =
    // ON A UN IQ quelque chose, mais on ne devrait pas en avoir ici!
    _xmpp_debug strcatlist "!!! Get a iq "::type::"! Not allowed here"::nil;
    [ 1 nil [ nil nil ] ]
;;


// ---------------------------------------------------------
// END XMPP SESSION
// ---------------------------------------------------------
