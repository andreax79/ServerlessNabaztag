#include protos/hooks_protos.mtl

const CONTROL_WAIT=1;;
const CONTROL_PLAY=2;;
const CONTROL_INTERACTIF=3;;
const CONTROL_PROGRAMWAIT=4;;

const CONTROL_MSG_IDLE=0x7fffffff;;
const CONTROL_MSG_ASLEEP=0x7ffffffe;;

// Main loop state
var run;;

var _run_net_activity = 0;;

// Get main loop state
fun run_get_state =
    run;;

// Set main loop state
fun run_set_state r =
    let run -> old_run in (
        set run = r;
        old_run
    );;

fun run_init =
    run_set_state configstartRun;;

fun _run_control_wait =
    let button_get_event -> ev in
    let if ev==nil then ears_get_event else ev -> ev in
    if ev!=nil then
    (
        audiolib_wav_stop;
        ears_stop 0;
        if ev==BUTTON_CLIC then (hook_click time_ms;0) // click
        else if ev==BUTTON_DCLIC then (midi_play midi_ack; hook_dbl_click time_ms;0) //ackall
#ifdef RECLIB
        else if ev==BUTTON_LCLIC then record_control 0  //  //back ou record
        else if ev==BUTTON_DLCLIC then record_control 1 // //back ou record
#endif
        else if ev&0x8000 then (
            // oreilles
            midi_play midi_acquired;
            let (ev-0x8000)&0xFF00>>8 -> leftpos in
            let (ev-0x8000)&0xFF -> rightPos in (
                // remember for after sleep, etc...
                set ears_left=leftpos;
                set ears_right=rightPos;
                hook_ears leftpos rightPos
            );
            0
        )
    );
    rfid_control
    ;;


fun _run_control_inter =
    let button_get_event -> ev in
    if ev!=nil then
    (
        if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then (
            if (g_int_mask&MASK_BUTTON == 0) then interactive_send_btn ev
        ) else if ev==BUTTON_LCLIC then (
            if (g_record_enabled) then (
                // remember wav position and start record
#ifdef RECLIB
                set record_last_wav_bytes = audiolib_wav_cur_played_bytes;
                record_control 0;
#endif
                0
            ) else (
                // like BUTTON_CLIC
                set ev = BUTTON_CLIC;
                if (g_int_mask&MASK_BUTTON == 0) then interactive_send_btn ev
            )
        )
    );
    rfid_control
    ;;

/**
    Stop everything we can be doing and resets to either idle or asleep
 */
fun stopEverythingAndResetToIdle =
    audiolib_wav_stop;
    streaming_stop;
    ears_start_reset;
    set interactive_status = 0;
    set g_cookie = "";
    set gItApp = nil;
    set gProcessingState = 0;
    set gStreamingState = 0;
    set streaming_current_program = nil;
    run_set_state if !sleep_status then idleRun else sleepRun;
    0
;;

fun _run_control_play =
    let button_get_event -> ev in
    if ev!=nil then (
        audiolib_wav_stop;
        ears_stop 0;
        let atoi listswitchstr streaming_current_program "ID" -> id in
            if ev==BUTTON_CLIC then (
                midi_play midi_abort;
                if (gStreamingState) then streaming_stop;
                endOfProgram 0;
                XmppSessionSendButtonMsg ev 1 id
            ) //pause
            else if ev==BUTTON_DCLIC then (
                midi_play midi_ack;
                if (gStreamingState) then streaming_stop;
                endOfProgram 0;
                XmppSessionSendButtonMsg ev 1 id
            ) //ackall
            else if ev==BUTTON_LCLIC then nil //pause ou record ? callPingRequest 5
    )
    ;;

/*
    Utilise dans le cas ou on execute un programme et qu'on est en train
  d'executer une commande "WT". En gros on a un comportement normal
  sauf qu'on lit les rfid en plus
*/
fun _run_control_program_wait =
    (if (!interactive_status) then _run_control_play else _run_control_inter) ;
    rfid_control
;;


const _run_tab_osc={
    0 0 0 0 0 0 1 1 2 3 3 4 5 6 7 8
    9 10 12 13 15 16 18 19 21 23 25 27 29 31 33 35
    37 39 42 44 46 49 51 54 56 59 62 64 67 70 73 76
    79 81 84 87 90 93 96 99 103 106 109 112 115 118 121 124
};;


fun _run_osc x=
    let (x>>6)&3 -> q in
    let x&255 -> x in
    if q==0 then _run_tab_osc.x
    else if q==1 then 255-_run_tab_osc.(127-x)
    else if q==2 then 255-_run_tab_osc.(x-128)
    else _run_tab_osc.(255-x);;


fun _run_bottom_led=
    if !sleep_status then
    if !ears_detecting then
        (let _run_osc time_ms>>4 -> v in led LED_BASE v*0x000100); // pulse green - was violet 0x10001
    0;;


fun _run_nose_led=
    if !ears_detecting then
    // led tete clignote if netactivity or audiolib_wav_buffering //
#ifdef RECLIB
    let record_uploading || (match run with (rscLoadWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
#else
    let (match run with (rscLoadWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
#endif
    if (netactivity) then (
        led LED_NOSE (if time_ms&256 then RGB_BLUE else RGB_BLACK);
        set _run_net_activity = 1
    ) else if (audiolib_wav_buffering) then (
        led LED_NOSE (if time_ms&128 then RGB_VIOLET else RGB_BLACK);
        set _run_net_activity = 1
    ) else if (_run_net_activity) then (
        // show off the light
        led LED_NOSE RGB_BLACK;
        set _run_net_activity = 0
    );
    0;;


fun _run_ear_reset cb =
    if (!ears_resetting) then
        call cb []
    ;;

fun _run_idle =
    // if trame waiting, execute it
    let trame_get_next_pending -> trame in
    if trame != nil then (
        trame_eval trame;
        0
    ) else (
        set gProcessingState = 0;
#ifdef SERVERLESS
        if surprise_check then (
            surprise;
            0
        )
        else
#endif
        if dotaichinow then (
            taichistart
        ) else (
#ifdef PING
            ping_run_start
#else
            0
#endif
        )
    );
    0;;


fun _run_get_config_cb http res=
    if (nil != res) then
    (
        Secholn "config=";
        let trame_filter_config Secholn httpgetcontent res 0-> conf in
        (
            // http urls
            set url_ping_server=listswitchstr conf "ping";
            set url_broadcast=listswitchstr conf "broad";
            if !strcmp url_ping_server "0.0.0.0" then set url_ping_server = config_get_server_url;
            if !strcmp url_broadcast "0.0.0.0" then set url_broadcast = config_get_server_url;

#ifdef PING
            sleep_end;
            if url_ping_server!=nil && url_broadcast!=nil then run_set_state pingstartRun;
#endif
#ifdef XMPP
        /****** XMPP ****/
            let listswitchstr conf "xmpp_domain" -> xmpp_domain in
                if xmpp_domain != nil then
                    XmppSessionStart xmpp_domain 1; // START 1 XMPP SESSION HERE (1 == Display Leds for connexion Details)

            run_set_state xmppLoginRun;
#endif
#ifdef SERVERLESS
            sleep_end;
#endif
            0
        )
    )
;;

fun _run_config_start =
    if wifi_connected && audiolib_wav_running==0 then (
        leds_set_state LEDS_STATE_CONFIG_WAIT ;
#ifdef SERVERLESS
        meteo_get;
        get_time_from_timeserver;
        sleep_end
#else
        Secho "config_get_server_url: "; Secholn config_get_server_url;
        Secho "url_config: "; Secholn url_config;
        run_set_state configwaitRun httprequest "GET" url_config nil #_run_get_config_cb HTTP_NORMAL
#endif
    );
    0;;

fun _run_config_wait http=
    // check timeout and retry : cligne + ou - la led middle body toutes les secondes en bleu
    if ((httpinactive http) > STD_NET_TIMEOUT) then
    (
        Secholn "##timeout on configwait";
        httpabort http;
        run_init
    );
    0;;


fun run_step=
    let match run with
    ( configstartRun ->
        ears_run;
        _run_config_start )|
    ( configwaitRun http ->
        ears_run;
        _run_config_wait http )|
#ifdef PING
    ( pingstartRun ->
        ears_run;
        if currentTrameID!=CONTROL_MSG_ASLEEP then _run_bottom_led;
        ping_run_start )|
    ( pingwaitRun http ->
        ears_run;
        if currentTrameID!=CONTROL_MSG_ASLEEP then (
            info_run;
            _run_bottom_led;
            _run_nose_led
        );
        runpingwait http;
        if currentTrameID!=CONTROL_MSG_ASLEEP then CONTROL_WAIT)|
    ( pingRequestWaitRun http->
        _run_bottom_led;
        _run_nose_led;
        runPingRequestWait http;
        0)|
    ( stdWaitRun t -> ears_run;if currentTrameID!=CONTROL_MSG_ASLEEP then (info_run;_run_bottom_led;_run_nose_led);runStdWait t; CONTROL_WAIT) |
#endif
#ifdef XMPP
    ( xmppLoginRun ->
    if (ears_resetting && ears_is_initialized) then ears_run else ears_stop 1;
    xmpp_run_login;
    CONTROL_WAIT) |
    ( xmppReconnectRun params ->
    if (ears_resetting && ears_is_initialized) then ears_run else ears_stop 1;
    if !sleep_status then (
        // Affichage des sources.
        info_run;
        // On fige la base en violet
        led LED_BASE RGB_VIOLET
    );
    let params -> [waitTime xSession oldRun] in
        match xSession.sStatus with
            (sOpened -> run_set_state oldRun; 0)
            |(sClosed ->
                if time_ms > waitTime then (
                    XmppGateReconnect xSession 0
                );
                0)
            |(_ -> 0);
    CONTROL_WAIT)|
#endif
    ( idleRun -> ears_run;info_run;_run_bottom_led;_run_nose_led;_run_idle;CONTROL_WAIT) |
    ( sleepRun -> ears_run;_run_idle;0) |

    ( rscLoadNextRun -> ears_run;info_run;_run_bottom_led;_run_nose_led;runRscLoadNext; CONTROL_WAIT)|
    ( rscLoadWaitRun http-> ears_run;info_run;_run_bottom_led;_run_nose_led;runRscLoadWait http;CONTROL_WAIT)|
    ( cmdEvalOne i-> ears_run;runEvalOneCommand i;CONTROL_PLAY)|
    ( chorCmdRun i-> ears_run;_run_nose_led;runChorCmd i;CONTROL_PLAY)|
    ( streamCmdRun i0-> ears_run;_run_nose_led;streaming_run_cmd i0;CONTROL_PLAY)|
    ( waitCmdRun i -> ears_run;_run_nose_led;runWaitCmd i;CONTROL_PROGRAMWAIT)|

    ( earResetWaitRun cb -> ears_run; _run_ear_reset cb; 0) |

#ifdef RECLIB
    ( recordRun -> record_run)|
    ( recordStartRun -> record_start_run) |
#endif

    ( interactiveReqWaitRun http-> ears_run;info_run;_run_bottom_led;_run_nose_led;runInteractiveReqWait http;CONTROL_WAIT)
     -> keymanager in
    if keymanager==CONTROL_WAIT then
        _run_control_wait
    else if keymanager==CONTROL_PLAY then
        (if (!interactive_status) then _run_control_play else _run_control_inter)
    else if keymanager==CONTROL_PROGRAMWAIT then
        _run_control_program_wait
    else
        button_get_event;
    JobRun;;
