#include protos/button_protos.mtl
#include protos/hooks_protos.mtl
#include protos/chor_protos.mtl
#include protos/streaming_protos.mtl
#include protos/surprise_protos.mtl
#include protos/midi_protos.mtl
#ifdef PING
#include protos/ping_protos.mtl
#endif
#ifdef XMPP
#include protos/xmpp_protos.mtl
#endif

const CONTROL_NONE=0;;
const CONTROL_WAIT=1;;
const CONTROL_PLAY=2;;
const CONTROL_INTERACTIF=3;;
const CONTROL_PROGRAM_WAIT=4;;

const CONTROL_MSG_IDLE=0x7fffffff;;
const CONTROL_MSG_ASLEEP=0x7ffffffe;;

// Main loop state
var run;; // type Run

var _run_net_activity = 0;;

// Get main loop state
fun run_get_state =
    run;;

fun _run_to_str run=
    match run with
    ( configstartRun -> "configstartRun" )|
    ( configwaitRun _ -> "configwaitRun" )|
#ifdef PING
    ( pingstartRun -> "pingstartRun" )|
    ( pingwaitRun _ -> "pingwaitRun" )|
    ( pingRequestWaitRun _ -> "pingRequestWaitRun" )|
    ( stdWaitRun _ -> "stdWaitRun" )|
#endif
#ifdef XMPP
    ( xmppLoginRun -> "xmppLoginRun" )|
    ( xmppReconnectRun _ -> "xmppReconnectRun" )|
#endif
    ( idleRun -> "idleRun" )|
    ( sleepRun -> "sleepRun" )|
    ( rscLoadNextRun -> "rscLoadNextRun" )|
    ( rscLoadWaitRun http-> "rscLoadWaitRun" )|
    ( cmdEvalOne _-> "cmdEvalOne" )|
    ( chorCmdRun _-> "chorCmdRun" )|
    ( streamCmdRun _-> "streamCmdRun" )|
    ( waitCmdRun _ -> "waitCmdRun" )|
    ( recordRun -> "recordRun" )|
    ( recordStartRun -> "recordStartRun" )|
    ( interactiveReqWaitRun _ -> "interactiveReqWaitRun" );;

// Set main loop state
fun run_set_state r =
    // Secho "run_set_state "; Secholn _run_to_str r;
    let run -> old_run in (
        set run = r;
        old_run
    );;

fun run_init =
    run_set_state configstartRun;
    job_start "run" #run_job;;

fun _run_control_wait =
    let button_get_event -> ev in
    let if ev==nil then ears_get_event else ev -> ev in
    if ev!=nil then
    (
        audiolib_wav_stop;
        ears_stop 0;
        if ev==BUTTON_CLIC then hook_click // click
        else if ev==BUTTON_DCLIC then hook_dbl_click //ackall
        else if ev==BUTTON_LCLIC then record_control 0  //  //back ou record
        else if ev==BUTTON_DLCLIC then record_control 1 // //back ou record
        else if ev&0x8000 then hook_ears // oreilles
    );
    rfid_control
    ;;


fun _run_control_inter =
    let button_get_event -> ev in
    if ev!=nil then
    (
        if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then (
            if (interactive_int_mask & MASK_BUTTON == 0) then interactive_send_btn ev
        ) else if ev==BUTTON_LCLIC then (
            if (record_enabled) then (
                // remember wav position and start record
                set record_last_wav_bytes = audiolib_wav_cur_played_bytes;
                record_control 0;
                0
            ) else (
                // like BUTTON_CLIC
                set ev = BUTTON_CLIC;
                if (interactive_int_mask & MASK_BUTTON == 0) then interactive_send_btn ev
            )
        )
    );
    rfid_control
    ;;

/**
    Stop everything we can be doing and resets to either idle or asleep
 */
fun stopEverythingAndResetToIdle =
    audiolib_wav_stop;
    streaming_stop;
    ears_start_reset;
    set interactive_status = 0;
    set interactive_cookie = "";
    set interactive_app = nil;
    set chor_processing_status = 0;
    set streaming_status = 0;
    set streaming_current_program = nil;
    run_set_state if !sleep_status then idleRun else sleepRun;
    0
;;

fun _run_control_play =
    let button_get_event -> ev in
    if ev!=nil then (
        audiolib_wav_stop;
        ears_stop 0;
        let atoi listswitchstr streaming_current_program "ID" -> id in
            if ev==BUTTON_CLIC then (
                midi_play MIDI_ABORT;
                if (streaming_status) then streaming_stop;
                endOfProgram 0;
#ifdef XMPP
                XmppSessionSendButtonMsg ev 1 id
#else
                0
#endif
            ) //pause
            else if ev==BUTTON_DCLIC then (
                midi_play MIDI_ACK;
                if (streaming_status) then streaming_stop;
                endOfProgram 0;
#ifdef XMPP
                XmppSessionSendButtonMsg ev 1 id
#else
                0
#endif
            ) //ackall
            else if ev==BUTTON_LCLIC then nil //pause ou record ? callPingRequest 5
    )
    ;;

/*
    Utilise dans le cas ou on execute un programme et qu'on est en train
  d'executer une commande "WT". En gros on a un comportement normal
  sauf qu'on lit les rfid en plus
*/
fun _run_control_program_wait =
    (if (!interactive_status) then _run_control_play else _run_control_inter) ;
    rfid_control
;;


const _run_tab_osc={
    0 0 0 0 0 0 1 1 2 3 3 4 5 6 7 8
    9 10 12 13 15 16 18 19 21 23 25 27 29 31 33 35
    37 39 42 44 46 49 51 54 56 59 62 64 67 70 73 76
    79 81 84 87 90 93 96 99 103 106 109 112 115 118 121 124
};;


fun _run_osc x=
    let (x>>6)&3 -> q in
    let x&255 -> x in
    if q==0 then _run_tab_osc.x
    else if q==1 then 255-_run_tab_osc.(127-x)
    else if q==2 then 255-_run_tab_osc.(x-128)
    else _run_tab_osc.(255-x);;


fun _run_bottom_led=
    if !sleep_status then
    if !ears_detecting then
        (let _run_osc time_ms>>4 -> v in led LED_BASE v*0x000100); // pulse green - was violet 0x10001
    0;;


fun _run_nose_led=
    if !ears_detecting then
    // led tete clignote if netactivity or audiolib_wav_buffering //
    let record_uploading || (match run with (rscLoadWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
    if (netactivity) then (
        led LED_NOSE (if time_ms&256 then RGB_BLUE else RGB_BLACK);
        set _run_net_activity = 1
    ) else if (audiolib_wav_buffering) then (
        led LED_NOSE (if time_ms&128 then RGB_VIOLET else RGB_BLACK);
        set _run_net_activity = 1
    ) else if (_run_net_activity) then (
        // show off the light
        led LED_NOSE RGB_BLACK;
        set _run_net_activity = 0
    );
    0;;

fun _run_idle =
    // if trame waiting, execute it
    let trame_get_next_pending -> trame in
    if trame != nil then (
        trame_eval trame;
        0
    ) else (
        set chor_processing_status = 0;
#ifdef SERVERLESS
        if surprise_check then (
            surprise;
            0
        )
        else
#endif
        if chor_do_taichi_now then (
            chor_taichi_start nil
        ) else (
#ifdef PING
            ping_run_start
#else
            0
#endif
        )
    );
    0;;


fun _run_parse_config_cb _ res=
    if (nil != res) then
    (
        Secholn "config=";
        let trame_filter_config Secholn http_get_content res 0-> conf in
        (
            // http urls
            set url_ping_server=listswitchstr conf "ping";
            set url_broadcast=listswitchstr conf "broad";
            if !strcmp url_ping_server "0.0.0.0" then set url_ping_server = config_get_server_url;
            if !strcmp url_broadcast "0.0.0.0" then set url_broadcast = config_get_server_url;

#ifdef PING
            sleep_end;
            if url_ping_server!=nil && url_broadcast!=nil then run_set_state pingstartRun;
#endif
#ifdef XMPP
        /****** XMPP ****/
            let listswitchstr conf "xmpp_domain" -> xmpp_domain in
                if xmpp_domain != nil then
                    XmppSessionStart xmpp_domain 1; // START 1 XMPP SESSION HERE (1 == Display Leds for connexion Details)

            run_set_state xmppLoginRun;
#endif
#ifdef SERVERLESS
            sleep_end;
#endif
            0
        )
    )
;;

fun _run_config_start =
    if wifi_connected && audiolib_wav_running==0 then (
        leds_set_state LEDS_STATE_CONFIG_WAIT ;
#ifdef SERVERLESS
        meteo_get;
        get_time_from_timeserver;
        sleep_end
#else
        Secho "config_get_server_url: "; Secholn config_get_server_url;
        Secho "url_config: "; Secholn url_config;
        run_set_state configwaitRun http_request "GET" url_config nil #_run_parse_config_cb HTTP_NORMAL
#endif
    );
    0;;

fun _run_config_wait http=
    // check timeout and retry : cligne + ou - la led middle body toutes les secondes en bleu
    if ((http_inactive http) > STD_NET_TIMEOUT) then
    (
        Secholn "##timeout on configwait";
        http_abort http;
        run_set_state configstartRun
    );
    0;;

fun _run_step_match=
    match run with
    ( configstartRun ->
        ears_run;
        _run_config_start )|
    ( configwaitRun http ->
        ears_run;
        _run_config_wait http )|
#ifdef PING
    ( pingstartRun ->
        ears_run;
        if ping_current_trame_id!=CONTROL_MSG_ASLEEP then _run_bottom_led;
        ping_run_start )|
    ( pingwaitRun http ->
        ears_run;
        if ping_current_trame_id!=CONTROL_MSG_ASLEEP then (
            info_run;
            _run_bottom_led;
            _run_nose_led
        );
        runpingwait http;
        if ping_current_trame_id!=CONTROL_MSG_ASLEEP then CONTROL_WAIT)|
    ( pingRequestWaitRun http->
        _run_bottom_led;
        _run_nose_led;
        runPingRequestWait http;
        CONTROL_NONE )|
    ( stdWaitRun t ->
        ears_run;
        if ping_current_trame_id != CONTROL_MSG_ASLEEP then (
            info_run;
            _run_bottom_led;
            _run_nose_led
        );
        runStdWait t;
        CONTROL_WAIT )|
#endif
#ifdef XMPP
    ( xmppLoginRun ->
        if (ears_resetting && ears_is_initialized) then ears_run else ears_stop 1;
        xmpp_run_login;
        CONTROL_WAIT )|
    ( xmppReconnectRun params ->
        if (ears_resetting && ears_is_initialized) then ears_run else ears_stop 1;
        if !sleep_status then (
            // Affichage des sources.
            info_run;
            // On fige la base en violet
            led LED_BASE RGB_VIOLET
        );
        let params -> [waitTime xSession oldRun] in
            match xSession.sStatus with
                (sOpened -> run_set_state oldRun; 0)|
                (sClosed -> if time_ms > waitTime then XmppGateReconnect xSession 0; 0)|
                (_ -> 0);
        CONTROL_WAIT )|
#endif
    ( idleRun ->
        ears_run;
        info_run;
        _run_bottom_led;
        _run_nose_led;
        _run_idle;
        CONTROL_WAIT ) |
    ( sleepRun ->
        ears_run;
        _run_idle;
        CONTROL_NONE )|
    ( rscLoadNextRun ->
        ears_run;
        info_run;
        _run_bottom_led;
        _run_nose_led;
        streaming_run_rsc_load_next_cmd;
        CONTROL_WAIT ) |
    ( rscLoadWaitRun http->
        ears_run;
        info_run;
        _run_bottom_led;
        _run_nose_led;
        streaming_run_rsc_load_wait_cmd http;
        CONTROL_WAIT )|
    ( cmdEvalOne i->
        ears_run;
        streaming_run_eval_one_cmd i;
        CONTROL_PLAY )|
    ( chorCmdRun i->
        ears_run;
        _run_nose_led;
        chor_run_cmd i;
        CONTROL_PLAY )|
    ( streamCmdRun i0->
        ears_run;
        _run_nose_led;
        streaming_run_cmd i0;
        CONTROL_PLAY )|
    ( waitCmdRun i ->
        ears_run;
        _run_nose_led;
        streaming_run_wait_cmd i;
        CONTROL_PROGRAM_WAIT )|
    ( earResetWaitRun cb ->
        ears_run;
        if (!ears_resetting) then call cb [];
        CONTROL_NONE) |
    ( recordRun ->
        record_run )|
    ( recordStartRun ->
        record_start_run )|
    ( interactiveReqWaitRun http ->
        ears_run;
        info_run;
        _run_bottom_led;
        _run_nose_led;
        runInteractiveReqWait http;
        CONTROL_WAIT );;

fun run_job=
    let _run_step_match -> keymanager in (
        if keymanager == CONTROL_WAIT then
            _run_control_wait
        else if keymanager == CONTROL_PLAY then
            if !interactive_status then
                _run_control_play
            else
                _run_control_inter
        else if keymanager == CONTROL_PROGRAM_WAIT then
            _run_control_program_wait
        else
            button_get_event
    );
    JobRun;;
