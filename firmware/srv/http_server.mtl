#include protos/meteo_protos.mtl
#include protos/sleep_protos.mtl
#include protos/audiolib_protos.mtl
#include protos/streaming_protos.mtl

//--------------------------------------------------------------------------------------------------
// HTTP Server
//--------------------------------------------------------------------------------------------------

const HTTP_200 = "200 OK";;
const HTTP_204 = "204 No Content";;
const HTTP_404 = "404 Not Found";;
const http_header_sep="\13\n\13\n";; // HTTP header separator
const http_content_start="ontent-Length: ";;
const http_content_start2="ontent-length: ";;
const http_content_end="\13\n";;

proto http_process_request 3 ;;

/**
 * Generate the HTTP response header.
 */
fun http_header http_status content_type=
    strcatlist
        "HTTP/1.0 "::http_status::
        "\13\10Server: MTL HTTP server"::
        "\13\10Access-Control-Allow-Origin: *"::
        (if content_type!=nil then (strcat "\13\10Content-Type: " content_type) else "")::
        "\13\10\13\10"::nil
;;

/**
 * Send a HTTP response header and close the connection.
 * cnx: TCP connection
 * sock: socket object for this connection
 * jsonstatus: response string to send
 */
fun http_send_header_and_close http_status content_type cnx sock=
    let http_header http_status content_type -> res in
        sock_send_and_close cnx sock res;;

/**
 * Send a full HTTP response (header + content) and close the connection.
 * cnx: TCP connection
 * sock: socket object for this connection
 * content_type: MIME type of the content
 * content: response string to send
 */
fun http_send_content_and_close cnx sock content_type content=
    let http_header HTTP_200 content_type -> header in
    let strcat header content -> res in
        sock_send_and_close cnx sock res;;

/**
 * Extract the header of an HTTP message string.
 * It works by finding the double CRLF that separates the header from the body.
 * res: HTTP request
 */
fun http_get_header res =
    let strstr res http_header_sep 0 -> i in
    if i!=nil then strsub res 0 i;;

/**
 * Parse an HTTP header to calculate the total size of the full HTTP message.
 * It reads the 'Content-Length' value and adds it to the length of the header itself.
 * s: HTTP request
 */
fun http_find_content_end s=
    let http_get_header s -> header in
    if header!=nil then
    let strstr header http_content_start 0 -> i in
    let if i!=nil then i else strstr header http_content_start2 0 -> i in
    let if i!=nil then strstr header http_content_end i -> j in
    (strlen header)+(strlen http_header_sep)+if i!=nil then
        let i+strlen http_content_start -> i in atoi strsub header i if j!=nil then j-i;;

/**
 * Main data handling function for an HTTP connection.
 * It buffers incoming data until a complete HTTP request is received,
 * then calls the user callback.
 * cnx: TCP connection
 * input: new chunk of data received
 * sock: socket object for this connection
 */
fun http_sock_read cnx input sock=
    // If the input is nil or empty, the client has closed the connection
    if input==nil ||0==strlen input then
    (
        closetcp cnx;
        nil
    )
    else
    (
        if sock.sockSize==nil then
        (
            set sock.sockInput=(strcat hd sock.sockInput input)::nil;
            Secho "size=";
            Iecholn set sock.sockSize=http_find_content_end hd sock.sockInput;
            nil
        )
        else set sock.sockInput=input::sock.sockInput;
        // Check if the total received data length now equals or exceeds the expected size
        if sock.sockSize!=nil && (slistlen sock.sockInput)>=sock.sockSize then
        let strcatlist rev sock.sockInput nil -> str in
        (
            // Clear the input buffer
            set sock.sockInput=nil;
            // Call the callback function with the full request
            call sock.sockCallback [str cnx sock]
        )
    );
    0;;

/**
 * Event handler for a connection being used for HTTP.
 * This function is registered as the callback for the TCP connection.
 * cnx: TCP connection
 * val: event type (e.g., TCPWRITE, TCPCLOSE)
 * msg: dataa associated with the event (e.g., incoming data)
 * sock: socket object for this connection
 */
fun http_sock_event cnx val msg sock=
    if val==TCPWRITE then sock_write cnx sock
    else if val==TCPCLOSE then http_sock_read cnx nil sock
    else http_sock_read cnx msg sock;;

/**
 * Callback function for the main HTTP listening socket.
 * This is called by the TCP stack whenever a new client connects.
 * cnx: TCP connection
 */
fun http_server_cb cnx code msg=
    Secholn "http server accept";
    tcpcb cnx fixarg4 #http_sock_event [sockCallback:#http_process_request];
    0;;

//--------------------------------------------------------------------------------------------------

fun http_get_json_status cnx sock args=
    http_send_content_and_close cnx sock "application/json"
    strcatlist
        "{\n"::
            (json_str "mac" webmac netMac) :: ",\n" ::
            (json_str "ts" current_time_human) :: ",\n" ::
            (json_int "time" time) :: ",\n" ::
            (json_str "city_code" config_get_city_code) :: ",\n" ::
            (json_int "dst" config_get_dst) :: ",\n" ::
            (json_int "time_offset" get_time_offset) :: ",\n" ::
            (json_str "language" config_get_lang) :: ",\n" ::
            (json_str "latitude" config_get_latitude) :: ",\n" ::
            (json_str "longitude" config_get_longitude) :: ",\n" ::
            (json_int "wake_up" config_get_wake_up) :: ",\n" ::
            (json_int "go_to_bed" config_get_go_to_bed) :: ",\n" ::
            (json_int "taichi" infotaichi) :: ",\n" ::
            (json_int "messages" infomessages) :: ",\n" ::
            (json_int "left" ears_left) :: ",\n" ::
            (json_int "right" ears_right) :: ",\n" ::
            (json_int "earsmode" earsmode) :: ",\n" ::
            (json_int "ear_detecting" ears_detecting) :: ",\n" ::
            (json_int "sleep_state" sleep_status) :: ",\n" ::
            (json_int "streaming_state" gStreamingState) :: ",\n" ::
            (json_int "processing_state" gProcessingState) :: ",\n" ::
            (json_int "busy_state" gBusyState) :: ",\n" ::
            (json_int "it_state" gItState) :: ",\n" ::
            (json_str "it_app" gItApp) :: ",\n" ::
            (json_int "meteo_weather_code" _meteo_weather_code) :: ",\n" ::
            (json_str "rev" BYTECODE_REVISION_STR) :: "\n" ::
        "}" :: nil
;;

fun job_format_json job =
    strcatlist
        "{ "::
            (json_str "name" job.name) :: ", " ::
            (json_str "status" job_status job) ::
        " }" :: nil
;;

fun http_get_json_jobs cnx sock args =
    let "[\n" -> result in
    let listlen _jobs -> n in (
        for l=_jobs;l!=nil; tl l do
            let hd l -> job in
            let if nil!=tl l then ",\n" else "\n]" -> sep in
            set result = strcatlist result::(job_format_json job)::sep::nil;
        http_send_content_and_close cnx sock "application/json" result
    )
;;

//--------------------------------------------------------------------------------------------------

fun httpindex=
        "
#include srv/www/index.html
        "
;;

fun milligram_css=
        "
#include srv/www/milligram.css
        "
;;

fun openapi_yaml=
        "
#include srv/www/openapi.yaml
        "
;;

//--------------------------------------------------------------------------------------------------

proto taichistart 0;;
proto stopEverythingAndResetToIdle 0;;
proto get_time_from_timeserver 0;;
proto audiolib_start_http 2;;
proto surprise 0;;
proto _infosrc_update 2;;

//--------------------------------------------------------------------------------------------------

fun filterplus s=
    let strlen s -> n in
    for i=0;i<n do if (strget s i)=='+' then strset s i 32;
    s;;

fun filterpercent s i0=
    let strstr s "%" i0 -> i in
    if i==nil then (strsub s i0 nil)::nil
    else (strsub s i0 i-i0)::(ctoa htoi strsub s i+1 2)::(filterpercent s i+3);;

fun extractargs urlencoded i=
    let strstr urlencoded "=" i-> j in
    if j!=nil then let strstr urlencoded "&" j-> k in
    let if k==nil then strlen urlencoded else k -> k in
    [(strget urlencoded i) strcatlist filterpercent filterplus strsub urlencoded j+1 k-j-1 0]::extractargs urlencoded k+1
    ;;

/**
 * Extract the verb, path and args from the HTTP request line.
 * req: full HTTP request string
 */
fun _http_server_parse_req req=
    let nil -> args in
    let strstr req " " 0 -> i in
    let strstr req " " i+1 -> j in
    let strsub req 0 i -> verb in
    let strsub req i+1 j-i-1 -> path in (
        if !strcmp verb "POST" then
            // For POST requests, extract arguments from the body
            set args = extractargs req ((strstr req http_header_sep 0) + (strlen http_header_sep))
        else
            // For GET requests, extract arguments from the path
            let strstr path "?" 0 -> i in
                if i!=nil then (
                    set path=(strsub path 0 i);
                    set args=(extractargs path i+1)
                );
    [verb path args]
    );;

// Get a string value from the args by the key
fun _http_arg_str args key =
    let nil -> value in (
        for l=args; l!=nil; tl l do
            let hd l->[n v] in
                if n==key then set value=v;
        value
    )
    ;;

// Get an integer value from the args by the key
fun _http_arg_int args key =
    let nil -> value in (
        for l=args; l!=nil; tl l do
            let hd l->[n v] in
                if n==key then set value=atoi v;
        value
    )
    ;;

/**
 * Get time from the time server
 */
fun http_get_update_time cnx sock args=
    get_time_from_timeserver;
    http_send_header_and_close HTTP_204 nil cnx sock;;

/**
 * Get weather information from the weather server
 */
fun http_get_update_weather cnx sock args=
    meteo_get;
    http_send_header_and_close HTTP_204 nil cnx sock;
    nil;;

/**
 * Stop everything we can be doing and resets to either idle or asleep
 */
fun http_get_stop cnx sock args=
    stopEverythingAndResetToIdle;
    http_send_header_and_close HTTP_204 nil cnx sock;
    nil;;

/**
 * Reboot the system
 */
fun http_get_reboot cnx sock args=
    http_send_header_and_close HTTP_204 nil cnx sock;
    reboot 0x0407FE58 0x13fb6754;
    nil;;

/**
 * Surprise action
 */
fun http_get_surprise cnx sock args=
    surprise;
    http_send_header_and_close HTTP_204 nil cnx sock;;

/**
 * Play a sound
 */
fun http_get_play_midi midi cnx sock args=
    if !sleep_status then (
        midi_play midi
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_play cnx sock args=
    if !sleep_status then (
        audiolib_start_http _http_arg_str args 'u' #streaming_wav_error
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_say cnx sock args=
    if !sleep_status then (
        audiolib_start_http (strcatlist "http://translate.google.com/translate_tts?ie=UTF-8&total=1&idx=0&textlen=32&client=tw-ob&tl=En-gb&q="::(strreplace (_http_arg_str args 't') " " "+")::nil) #streaming_wav_error
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_taichi cnx sock args=
    let _http_arg_int args 'v' -> v in
        if v == 1000 && !sleep_status then
            taichistart
        else
            set infotaichi = v;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_mp3 cnx sock args=
    audiolib_start_http _http_arg_str args 'v' #streaming_wav_error;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_sleep cnx sock args=
    sleep_start;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_wakeup cnx sock args=
    sleep_end;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_left cnx sock args=
    if !sleep_status then (
        ears_go 0 _http_arg_int args 'p' _http_arg_int args 'd'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_right cnx sock args=
    if !sleep_status then (
        ears_go 1 _http_arg_int args 'p' _http_arg_int args 'd'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_nose cnx sock args=
    set infomessages = _http_arg_int args 'v';
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_weather cnx sock args=
    if !sleep_status then (
        _infosrc_update 1 _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_stock cnx sock args=
    if !sleep_status then (
        _infosrc_update 2 _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_traffic cnx sock args=
    if !sleep_status then (
        _infosrc_update 3 _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_mail cnx sock args=
    if !sleep_status then (
        _infosrc_update 6 _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_pollution cnx sock args=
    if !sleep_status then (
        _infosrc_update 7 _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_clear cnx sock args=
    for i=1;i<=8 do (
        _infosrc_update 0 i
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun _http_get_dns_cb ip x=
	let x->[cnx sock] in
    let strcatlist "{ " :: (json_str "ip" ip) :: " }" :: nil -> res in
    http_send_content_and_close cnx sock "application/json" res;;

/**
 * Perform a DNS lookup for the given domain and return the result as JSON.
 * args: d=domain name
 */
fun http_get_dns cnx sock args=
    let _http_arg_str args 'd' -> domain in
        dnsreq domain fixarg2 #_http_get_dns_cb [cnx sock];;

fun http_get_setup cnx sock args=
    config_set_lang _http_arg_str args 'l';            // set language
    config_set_city _http_arg_str args 'c';            // set city code
    config_set_dst atoi _http_arg_str args 'd';        // set Daylight Saving Time
    config_set_latitude _http_arg_str args 'j';        // set latitude
    config_set_longitude _http_arg_str args 'k';       // set longitude
    config_set_wake_up atoi _http_arg_str args 'w';    // set wake up time
    config_set_go_to_bed atoi _http_arg_str args 'b';  // set go to bed time
    config_save;
    meteo_get;
    http_send_header_and_close HTTP_204 nil cnx sock;;


// fun http_post_forth cnx sock args=
//     Secholn "http_post_forth";
//     let _http_arg_str args 'c' -> code in
//     let forth_interpreter code -> f in (
//         http_send_header_and_close HTTP_204 nil cnx sock
//     );;

/**
 * Process an HTTP request and generate the response
 */
fun http_process_request req cnx sock=
    let _http_server_parse_req req -> [verb path args] in
    (
        Secho "verb: "; Secho verb; Secho " path: "; Secholn path;

        if !strcmp path "/update-time" then http_get_update_time cnx sock args // get time from time server
        else if !strcmp path "/update-weather" then http_get_update_weather cnx sock args  // get weather from weather server
        else if !strcmp path "/stop" then http_get_stop cnx sock args // stop
        else if !strcmp path "/reboot" then http_get_reboot cnx sock args // reboot
        else if !strcmp path "/surprise" then http_get_surprise cnx sock args // surprise
        else if !strcmp path "/status" then http_get_json_status cnx sock args // status
        else if !strcmp path "/jobs" then http_get_json_jobs cnx sock args // jobs
        else if !strcmp path "/communication" then http_get_play_midi midi_communion cnx sock args // play communication sound
        else if !strcmp path "/ack" then http_get_play_midi midi_ack cnx sock args // play ack sound
        else if !strcmp path "/abort" then http_get_play_midi midi_abort cnx sock args // play abort sound
        else if !strcmp path "/ministop" then http_get_play_midi midi_ministop cnx sock args // play ministop sound
        else if !strcmp path "/play" then http_get_play cnx sock args // play a wav from url
        else if !strcmp path "/say" then http_get_say cnx sock args // text to speech
        else if !strcmp path "/taichi" then http_get_taichi cnx sock args // taichi
        else if !strcmp path "/mp3" then http_get_mp3 cnx sock args // play an mp3 from url
        else if !strcmp path "/sleep" then http_get_sleep cnx sock args // sleep
        else if !strcmp path "/wakeup" then http_get_wakeup cnx sock args // wake up
        else if !strcmp path "/left" then http_get_left cnx sock args // p=position d=direction
        else if !strcmp path "/right" then http_get_right cnx sock args // p=position d=direction
        else if !strcmp path "/nose" then http_get_nose cnx sock args // v=value
        else if !strcmp path "/weather" then http_get_weather cnx sock args // v=value
        else if !strcmp path "/stock" then http_get_stock cnx sock args // v=value
        else if !strcmp path "/traffic" then http_get_traffic cnx sock args // v=value
        else if !strcmp path "/mail" then http_get_mail cnx sock args // v=value
        else if !strcmp path "/pollution" then http_get_pollution cnx sock args // v=value
        else if !strcmp path "/clear" then http_get_clear cnx sock args // clear all infosrc
        else if !strcmp path "/dns" then http_get_dns cnx sock args // d=domain name
        else if !strcmp path "/setup" then http_get_setup cnx sock args // setup parameters
        else if !strcmp path "/forth" then http_post_forth cnx sock args // forth command
        else if !strcmp path "/milligram.css" then (
            let http_header HTTP_200 "text/css" -> header in
            let strcat header milligram_css -> res in
            sock_send_and_close cnx sock res
        )
        else if !strcmp path "/openapi.yaml" then (
            let webip netip -> ip in
            let http_header HTTP_200 "application/yaml" -> header in
            let strcat header (strreplace openapi_yaml "192.168.1.100" ip) -> res in
            sock_send_and_close cnx sock res
        )
        else if !strcmp path "/" then (  // index page
            let http_header HTTP_200 "text/html" -> header in
            let strcat header httpindex -> res in
            sock_send_and_close cnx sock res
        )
        else (
            let http_header HTTP_404 "text/plain" -> header in
            let strcat header "Not Found" -> res in
            sock_send_and_close cnx sock res
        );
        0
    );;


fun http_server_start_srv port =
    listentcp port #http_server_cb;
    0;;
