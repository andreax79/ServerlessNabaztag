#include protos/meteo_protos.mtl
#include protos/sleep_protos.mtl
#include protos/audiolib_protos.mtl
#include protos/streaming_protos.mtl
#include protos/chor_protos.mtl
#include protos/jobs_protos.mtl
#include protos/forth_protos.mtl
#include protos/json_protos.mtl
#include protos/info_protos.mtl

//--------------------------------------------------------------------------------------------------
// HTTP Server
//--------------------------------------------------------------------------------------------------

const HTTP_200 = "200 OK";;
const HTTP_204 = "204 No Content";;
const HTTP_404 = "404 Not Found";;
const http_header_sep="\13\n\13\n";; // HTTP header separator
const http_content_start="ontent-Length: ";;
const http_content_start2="ontent-length: ";;
const http_content_end="\13\n";;

proto http_process_request 3 ;;

/**
 * Generate the HTTP response header.
 */
fun http_header http_status content_type content_length=
    strcatlist
        "HTTP/1.1 "::http_status::
        "\13\10Server: MTL HTTP server"::
        "\13\10Access-Control-Allow-Origin: *"::
        (if content_type!=nil then (strcat "\13\10Content-Type: " content_type) else "")::
        (if content_length!=nil then (strcat "\13\10Content-Length: " (itoa content_length)) else "")::
        "\13\10Date: " :: time_date_utc ::
        "\13\10Cache-Control: max-age=0, no-cache, no-store" ::
        "\13\10Pragma: no-cache" ::
        "\13\10Connection: close"::
        "\13\10\13\10"::nil
;;

/**
 * Send a HTTP response header and close the connection.
 * cnx: TCP connection
 * sock: socket object for this connection
 * jsonstatus: response string to send
 */
fun http_send_header_and_close http_status content_type cnx sock=
    sock_send_and_close cnx sock (http_header http_status content_type nil);;

/**
 * Send a full HTTP response (header + content) and close the connection.
 * cnx: TCP connection
 * sock: socket object for this connection
 * content_type: MIME type of the content
 * content: response string to send
 */
fun http_send_content_and_close cnx sock content_type content=
    sock_send cnx sock (http_header HTTP_200 content_type (strlen content)); // header
    sock_send_and_close cnx sock content;;

/**
 * Extract the header of an HTTP message string.
 * It works by finding the double CRLF that separates the header from the body.
 * res: HTTP request
 */
fun http_get_header res =
    let strstr res http_header_sep 0 -> i in
    if i!=nil then strsub res 0 i;;

/**
 * Parse an HTTP header to calculate the total size of the full HTTP message.
 * It reads the 'Content-Length' value and adds it to the length of the header itself.
 * s: HTTP request
 */
fun http_find_content_end s=
    let http_get_header s -> header in
    if header!=nil then
    let strstr header http_content_start 0 -> i in
    let if i!=nil then i else strstr header http_content_start2 0 -> i in
    let if i!=nil then strstr header http_content_end i -> j in
    (strlen header)+(strlen http_header_sep)+if i!=nil then
        let i+strlen http_content_start -> i in atoi strsub header i if j!=nil then j-i;;

/**
 * Main data handling function for an HTTP connection.
 * It buffers incoming data until a complete HTTP request is received,
 * then calls the user callback.
 * cnx: TCP connection
 * input: new chunk of data received
 * sock: socket object for this connection
 */
fun http_sock_read cnx input sock=
    // If the input is nil or empty, the client has closed the connection
    if input==nil ||0==strlen input then
    (
        closetcp cnx;
        nil
    )
    else
    (
        if sock.sockSize==nil then
        (
            set sock.sockInput=(strcat hd sock.sockInput input)::nil;
            Secho "size=";
            Iecholn set sock.sockSize=http_find_content_end hd sock.sockInput;
            nil
        )
        else set sock.sockInput=input::sock.sockInput;
        // Check if the total received data length now equals or exceeds the expected size
        if sock.sockSize!=nil && (slistlen sock.sockInput)>=sock.sockSize then
        let strcatlist rev sock.sockInput nil -> str in
        (
            // Clear the input buffer
            set sock.sockInput=nil;
            // Call the callback function with the full request
            call sock.sockCallback [str cnx sock]
        )
    );
    0;;

/**
 * Event handler for a connection being used for HTTP.
 * This function is registered as the callback for the TCP connection.
 * cnx: TCP connection
 * val: event type (e.g., TCPWRITE, TCPCLOSE)
 * msg: dataa associated with the event (e.g., incoming data)
 * sock: socket object for this connection
 */
fun http_sock_event cnx val msg sock=
    if val==TCPWRITE then sock_write cnx sock
    else if val==TCPCLOSE then http_sock_read cnx nil sock
    else http_sock_read cnx msg sock;;

/**
 * Callback function for the main HTTP listening socket.
 * This is called by the TCP stack whenever a new client connects.
 * cnx: TCP connection
 */
fun http_server_cb cnx code msg=
    tcpcb cnx fixarg4 #http_sock_event [sockCallback:#http_process_request];
    0;;

//--------------------------------------------------------------------------------------------------

/**
 * Retrieve the system status as a JSON object.
 */
fun http_get_json_status cnx sock args=
    http_send_content_and_close cnx sock "application/json"
    strcatlist
        "{\n"::
            (json_str "language" config_get_lang) :: ",\n" ::
            (json_str "latitude" config_get_latitude) :: ",\n" ::
            (json_str "longitude" config_get_longitude) :: ",\n" ::
            (json_int "wake_up" config_get_wake_up) :: ",\n" ::
            (json_int "go_to_bed" config_get_go_to_bed) :: ",\n" ::
            (json_int "sleep_state" sleep_status) :: ",\n" ::
            (json_int "streaming_state" streaming_status) :: ",\n" ::
            (json_int "processing_state" chor_processing_status) :: ",\n" ::
            (json_int "meteo_weather_code" _meteo_weather_code) :: ",\n" ::
            (json_obj "interactive" interactive_json) :: ",\n" ::
            (json_obj "time" time_json) :: ",\n" ::
            (json_obj "ears" ears_json) :: ",\n" ::
            (json_obj "info" info_json) :: ",\n" ::
            (json_obj "network" net_json) :: ",\n" ::
            (json_obj "wifi" wifi_json) :: ",\n" ::
            (json_str "rev" BYTECODE_REVISION_STR) :: "\n" ::
        "}" :: nil
;;

/**
 * Retrieve the jobs list as a JSON object.
 */
fun http_get_json_jobs cnx sock args =
    http_send_content_and_close cnx sock "application/json" job_json;;

/**
 * Retrieve the list of available timezones as a JSON object.
 */
fun http_get_timezones cnx sock args =
    http_send_content_and_close cnx sock "application/json" timezones_json;;

//--------------------------------------------------------------------------------------------------

fun http_index=
        strreplace "
#include srv/www/index.html
        " "{SERVER_URL}" config_get_server_url
;;

fun milligram_css=
        "
#include srv/www/milligram.css
        "
;;

fun openapi_yaml=
        "
#include srv/www/openapi.yaml
        "
;;

//--------------------------------------------------------------------------------------------------

proto stopEverythingAndResetToIdle 0;;
proto get_time_from_timeserver 0;;
proto surprise 0;;

//--------------------------------------------------------------------------------------------------

fun filterplus s=
    let strlen s -> n in
    for i=0;i<n do if (strget s i)=='+' then strset s i 32;
    s;;

fun filterpercent s i0=
    let strstr s "%" i0 -> i in
    if i==nil then (strsub s i0 nil)::nil
    else (strsub s i0 i-i0)::(ctoa htoi strsub s i+1 2)::(filterpercent s i+3);;

fun extractargs urlencoded i=
    let strstr urlencoded "=" i-> j in
    if j!=nil then let strstr urlencoded "&" j-> k in
    let if k==nil then strlen urlencoded else k -> k in
    [(strget urlencoded i) strcatlist filterpercent filterplus strsub urlencoded j+1 k-j-1 0]::extractargs urlencoded k+1
    ;;

/**
 * Extract the verb, path and args from the HTTP request line.
 * req: full HTTP request string
 */
fun _http_server_parse_req req=
    let nil -> args in
    let strstr req " " 0 -> i in
    let strstr req " " i+1 -> j in
    let strsub req 0 i -> verb in
    let strsub req i+1 j-i-1 -> path in (
        if !strcmp verb "POST" then
            // For POST requests, extract arguments from the body
            set args = extractargs req ((strstr req http_header_sep 0) + (strlen http_header_sep))
        else
            // For GET requests, extract arguments from the path
            let strstr path "?" 0 -> i in
                if i!=nil then (
                    set args=(extractargs path i+1);
                    set path=(strsub path 0 i);
                    nil
                );
    [verb path args]
    );;

// Get a string value from the args by the key
fun _http_arg_str args key =
    let nil -> value in (
        for l=args; l!=nil; tl l do
            let hd l->[n v] in
                if n==key then set value=v;
        value
    )
    ;;

// Get an integer value from the args by the key
fun _http_arg_int args key =
    let nil -> value in (
        for l=args; l!=nil; tl l do
            let hd l->[n v] in
                if n==key then set value=atoi v;
        value
    )
    ;;

/**
 * Get time from the time server
 */
fun http_get_update_time cnx sock args=
    get_time_from_timeserver;
    http_send_header_and_close HTTP_204 nil cnx sock;;

/**
 * Get weather information from the weather server
 */
fun http_get_update_weather cnx sock args=
    meteo_get;
    http_send_header_and_close HTTP_204 nil cnx sock;;

/**
 * Stop everything we can be doing and resets to either idle or asleep
 */
fun http_get_stop cnx sock args=
    stopEverythingAndResetToIdle;
    http_send_header_and_close HTTP_204 nil cnx sock;;

/**
 * Reboot the system
 */
fun http_get_reboot cnx sock args=
    http_send_header_and_close HTTP_204 nil cnx sock;
    reboot 0x0407FE58 0x13fb6754;
    nil;;

/**
 * Surprise action
 */
fun http_get_surprise cnx sock args=
    surprise;
    http_send_header_and_close HTTP_204 nil cnx sock;;

/**
 * Play a sound
 */
fun http_get_play_midi midi cnx sock args=
    if !sleep_status then (
        midi_play midi
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_play cnx sock args=
    if !sleep_status then (
        audiolib_start_http _http_arg_str args 'u' #streaming_wav_error
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_say cnx sock args=
    if !sleep_status then (
        audiolib_start_http (strcatlist "http://translate.google.com/translate_tts?ie=UTF-8&total=1&idx=0&textlen=32&client=tw-ob&tl=En-gb&q="::(strreplace (_http_arg_str args 't') " " "+")::nil) #streaming_wav_error
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_taichi cnx sock args=
    let _http_arg_int args 'v' -> v in
        if v == 1000 && !sleep_status then
            chor_taichi_start nil
        else
            set info_taichi = v;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_mp3 cnx sock args=
    audiolib_start_http _http_arg_str args 'v' #streaming_wav_error;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_sleep cnx sock args=
    sleep_start;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_wakeup cnx sock args=
    sleep_end;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_left cnx sock args=
    if !sleep_status then (
        ears_go EARS_LEFT _http_arg_int args 'p' _http_arg_int args 'd'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_right cnx sock args=
    if !sleep_status then (
        ears_go EARS_RIGHT _http_arg_int args 'p' _http_arg_int args 'd'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_nose cnx sock args=
    set info_messages = _http_arg_int args 'v';
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_weather cnx sock args=
    if !sleep_status then (
        info_src_update INFO_WEATHER _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_stock cnx sock args=
    if !sleep_status then (
        info_src_update INFO_STOCK _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_traffic cnx sock args=
    if !sleep_status then (
        info_src_update INFO_TRAFFIC _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_mail cnx sock args=
    if !sleep_status then (
        info_src_update INFO_MAIL _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_pollution cnx sock args=
    if !sleep_status then (
        info_src_update INFO_POLLUTION _http_arg_int args 'v'
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_clear cnx sock args=
    for i=1;i<=8 do (
        info_src_update 0 i
    );
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun _http_get_dns_cb ip x=
	let x->[cnx sock] in
    let strcatlist "{ " :: (json_str "ip" ip) :: " }" :: nil -> res in
    http_send_content_and_close cnx sock "application/json" res;;

/**
 * Perform a DNS lookup for the given domain and return the result as JSON.
 * args: d=domain name
 */
fun http_get_dns cnx sock args=
    let _http_arg_str args 'd' -> domain in
        dnsreq domain fixarg2 #_http_get_dns_cb [cnx sock];;

fun http_get_setup cnx sock args=
    config_set_lang _http_arg_str args 'l';            // set language
    config_set_city _http_arg_str args 'c';            // set city code
    config_set_dst atoi _http_arg_str args 'd';        // set Daylight Saving Time
    config_set_latitude _http_arg_str args 'j';        // set latitude
    config_set_longitude _http_arg_str args 'k';       // set longitude
    config_set_wake_up atoi _http_arg_str args 'w';    // set wake up time
    config_set_go_to_bed atoi _http_arg_str args 'b';  // set go to bed time
    config_save;
    meteo_get;
    http_send_header_and_close HTTP_204 nil cnx sock;;

fun http_get_milligram_css cnx sock args=
    sock_send cnx sock (http_header HTTP_200 "text/css" (strlen milligram_css)); // header
    sock_send_and_close cnx sock milligram_css;;

fun http_get_openapi_yaml cnx sock args=
    let webip netip -> ip in
    let strreplace openapi_yaml "192.168.1.100" ip -> res in (
        sock_send cnx sock (http_header HTTP_200 "text/css" (strlen res)); // header
        sock_send_and_close cnx sock res
    );;

fun http_get_index cnx sock args=
    sock_send cnx sock (http_header HTTP_200 "text/html" (strlen http_index)); // header
    sock_send_and_close cnx sock http_index;;

fun http_not_found cnx sock args=
    let "Not found" -> res in (
        sock_send cnx sock (http_header HTTP_404 "text/plain" (strlen res)); // header
        sock_send_and_close cnx sock res
    );;

/**
 * Process an HTTP request and generate the response
 */
fun http_process_request req cnx sock=
    let _http_server_parse_req req -> [verb path args] in
    (
        Secho "verb: "; Secho verb; Secho " path: "; Secholn path;

        if !strcmp path "/update-time" then http_get_update_time cnx sock args // get time from time server
        else if !strcmp path "/update-weather" then http_get_update_weather cnx sock args  // get weather from weather server
        else if !strcmp path "/stop" then http_get_stop cnx sock args // stop
        else if !strcmp path "/reboot" then http_get_reboot cnx sock args // reboot
        else if !strcmp path "/surprise" then http_get_surprise cnx sock args // surprise
        else if !strcmp path "/status" then http_get_json_status cnx sock args // status
        else if !strcmp path "/jobs" then http_get_json_jobs cnx sock args // jobs
        else if !strcmp path "/timezones" then http_get_timezones cnx sock args // timezones
        else if !strcmp path "/communication" then http_get_play_midi midi_communion cnx sock args // play communication sound
        else if !strcmp path "/ack" then http_get_play_midi midi_ack cnx sock args // play ack sound
        else if !strcmp path "/abort" then http_get_play_midi midi_abort cnx sock args // play abort sound
        else if !strcmp path "/ministop" then http_get_play_midi midi_ministop cnx sock args // play ministop sound
        else if !strcmp path "/play" then http_get_play cnx sock args // play a wav from url
        else if !strcmp path "/say" then http_get_say cnx sock args // text to speech
        else if !strcmp path "/taichi" then http_get_taichi cnx sock args // taichi
        else if !strcmp path "/mp3" then http_get_mp3 cnx sock args // play an mp3 from url
        else if !strcmp path "/sleep" then http_get_sleep cnx sock args // sleep
        else if !strcmp path "/wakeup" then http_get_wakeup cnx sock args // wake up
        else if !strcmp path "/left" then http_get_left cnx sock args // p=position d=direction
        else if !strcmp path "/right" then http_get_right cnx sock args // p=position d=direction
        else if !strcmp path "/nose" then http_get_nose cnx sock args // v=value
        else if !strcmp path "/weather" then http_get_weather cnx sock args // v=value
        else if !strcmp path "/stock" then http_get_stock cnx sock args // v=value
        else if !strcmp path "/traffic" then http_get_traffic cnx sock args // v=value
        else if !strcmp path "/mail" then http_get_mail cnx sock args // v=value
        else if !strcmp path "/pollution" then http_get_pollution cnx sock args // v=value
        else if !strcmp path "/clear" then http_get_clear cnx sock args // clear all infosrc
        else if !strcmp path "/dns" then http_get_dns cnx sock args // d=domain name
        else if !strcmp path "/setup" then http_get_setup cnx sock args // setup parameters
        else if !strcmp path "/forth" then forth_http_post cnx sock args // forth command
        else if !strcmp path "/milligram.css" then http_get_milligram_css cnx sock args // milligram.css
        else if !strcmp path "/openapi.yaml" then http_get_openapi_yaml cnx sock args // openapi spec
        else if !strcmp path "/" then http_get_index cnx sock args // index page
        else http_not_found cnx sock args;
        0
    );;

/**
 * Start the HTTP server on the given port.
 * port: TCP port number to listen on
 */
fun http_server_start_srv port =
    listentcp port #http_server_cb;
    0;;
