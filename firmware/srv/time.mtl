#include utils/timezones.mtl
#include protos/json_protos.mtl
#include protos/task_protos.mtl

//--------------------------------------------------------------------------------------------------
// Time functions
//--------------------------------------------------------------------------------------------------

const TIME_DELAY = 1000;; // Time update task delay (in ms)
const TIME_RFC868_DELAY = 24 * 60 * 60 * 1000;; // Delay between time server requests (in ms)
const TIME_PROTOCOL_PORT = 37 ;;
const TIME_PROTOCOL_EPHEMERAL_PORT = 49152 ;;
const WEEKDAYS = {"Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"} ;;
const MONTHS = {"Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"} ;;

var time_server_ip = "\128\138\140\44" ;;

var _time_rfc868_low = nil ;;  // low part of the last value read from the time server
var _time_rfc868_high = nil ;; // high part of the last value read from the time

var time_local = [0 0 0 0 0 0 0] ;; // [year, month, day, hour, minute, second, days_since_epoc]
var time_utc = [0 0 0 0 0 0 0] ;; // [year, month, day, hour, minute, second, days_since_epoc]

/**
 * Get Daylight Saving Time offset (in minutes)
 */
fun _time_dst_offset=
    if (config_get_dst == 1) then 60 else 0;;


/**
 * Get the time offset (in minutes) from UTC
 */
fun time_offset=
    _time_dst_offset + get_offset_from_city_code config_get_city_code;;


/**
 * Calculate the year, month, day, hours, minutes, seconds
 * offset: offset is in minutes
 */
fun _time_calculate_parts offset=
    let _time_rfc868_high -> h in
    let _time_rfc868_low -> l in
    let offset * 60 + time -> offset in
    let if (l + offset) > 65536 then h + ((l + offset) >> 16) else h -> h in
    let (l + offset) % 65536 -> l in
    let ((h % 675) * 65536 + l) % 86400 -> time_of_the_day in   // 675 is 86400 >> 7
    let h * 512 / 675 + 1 -> days_since_epoc in
    let 4 * (days_since_epoc - 59) + 3 -> ee in
    let (ee % 1461) / 4 -> gg in
    let 5 * gg + 2 -> hh in
    let ((hh % 153) / 5) + 1 -> day in
    let ((hh / 153) + 2) % 12 + 1 -> month in
    let (ee / 1461) + 1900 + ((14 - month) / 12) -> year in
        [
            year
            if (month > 0) then month else 1
            if (day > 0) then day else 1
            (time_of_the_day / 3600 ) % 24
            time_of_the_day / 60 % 60
            time_of_the_day % 60
            days_since_epoc
        ];;

/**
 * Update the current year, month, day, housrs, minutes, seconds
 */
fun _time_calculate=
    set time_local = _time_calculate_parts time_offset;
    set time_utc = _time_calculate_parts 0;
    0;;


/**
 * Update the time, day, local time
 */
fun time_update_task task=
    // Update time of the day
    _time_calculate;
    TaskRun;;


/**
 * Return the current local time in human readable form
 */
fun time_local_human=
    let time_local -> [local_time_year local_time_month local_time_day local_time_hour local_time_minute local_time_second _] in
        strcatlist
           (zero_pad (itoa local_time_year) 4) :: "-" ::
           (zero_pad (itoa local_time_month) 2) :: "-" ::
           (zero_pad (itoa local_time_day) 2) :: " " ::
           (zero_pad (itoa local_time_hour) 2) :: ":" ::
           (zero_pad (itoa local_time_minute) 2) :: ":" ::
           (zero_pad (itoa local_time_second) 2) :: nil;;

fun time_current_weekday days_since_epoc=
    let (days_since_epoc + 1) % 7 -> weekday in
        WEEKDAYS.weekday;;

/**
 * Return the current time as a UTC string
 */
fun time_date_utc=
    let time_local -> [local_time_year local_time_month local_time_day local_time_hour local_time_minute local_time_second days_since_epoc] in
        strcatlist (time_current_weekday days_since_epoc) :: ", " ::
           (zero_pad (itoa local_time_day) 2) :: " " ::
           MONTHS.(local_time_month - 1) :: " " ::
           (zero_pad (itoa local_time_year) 4) :: " " ::
           (zero_pad (itoa local_time_hour) 2) :: ":"::
           (zero_pad (itoa local_time_minute) 2) :: ":"::
           (zero_pad (itoa local_time_second) 2) :: " GMT" ::
           nil;;

/**
 * Return time status as JSON
 */
fun time_json=
    strcatlist
        "{\n"::
            (json_int "time" time) :: ",\n" ::
            (json_str "ts" time_local_human) :: ",\n" ::
            (json_int "dst" config_get_dst) :: ",\n" ::
            (json_int "offset" time_offset) :: ",\n" ::
            (json_str "city_code" config_get_city_code) :: ",\n" ::
            (json_str "time_server_ip" ip_to_str time_server_ip) :: "\n" ::
        "}" :: nil
;;

//--------------------------------------------------------------------------------------------------
// Time Protocol (RFC 868) client
//--------------------------------------------------------------------------------------------------

/**
 * Time protocol client - callback function
 */
fun _time_rfc868_cb msg mac ipfrom=
    unregudp TIME_PROTOCOL_EPHEMERAL_PORT;
    let time -> now in (
        set _time_rfc868_high = (strgetword msg 0) - (now >> 16);
        set _time_rfc868_low = (strgetword msg 2) - (now % 65536);
        _time_calculate
    );
    0;;

/**
 * Check if time has been received from the time server
 */
fun time_rfc868_received=
    _time_rfc868_low !=nil;;

/**
 * Get the current time from the time server
 */
fun get_time_from_timeserver=
    udp_send netip TIME_PROTOCOL_EPHEMERAL_PORT time_server_ip TIME_PROTOCOL_PORT "" nil;
    regudp TIME_PROTOCOL_EPHEMERAL_PORT #_time_rfc868_cb;;

/**
 * RFC 868 time client task
 */
fun time_rfc868_client_task task=
    get_time_from_timeserver;
    TaskRun;;

/**
 * Initialize the time task
 */
fun time_init=
    // Seed the random number generator
    srand time_ms;
    // Start the time update task
    task_start_ex "time_update" TIME_DELAY #time_update_task;
    // Start the RFC 868 time client task
    task_start_ex "rfc868_client" TIME_RFC868_DELAY #time_rfc868_client_task;;
