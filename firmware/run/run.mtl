#include protos/button_protos.mtl
#include protos/word_protos.mtl
#include protos/forth_protos.mtl
#include protos/chor_protos.mtl
#include protos/streaming_protos.mtl
#include protos/surprise_protos.mtl
#include protos/midi_protos.mtl
#ifdef PING
#include protos/ping_protos.mtl
#endif
#ifdef XMPP
#include protos/xmpp_protos.mtl
#endif

const RUN_NONE=0;;
const RUN_WAIT=1;;
const RUN_PLAY=2;;
const RUN_INTERACTIF=3;;
const RUN_PROGRAM_WAIT=4;;

const RUN_MSG_IDLE=0x7fffffff;;
const RUN_MSG_ASLEEP=0x7ffffffe;;

// Main loop state
var run;; // type Run

fun run_get_state =
    run;;

fun _run_to_str run=
    match run with
    ( configstartRun -> "configstartRun" )|
    ( configwaitRun _ -> "configwaitRun" )|
    ( interactiveReqWaitRun _ -> "interactiveReqWaitRun" )|
#ifdef PING
    ( pingstartRun -> "pingstartRun" )|
    ( pingwaitRun _ -> "pingwaitRun" )|
    ( stdWaitRun _ -> "stdWaitRun" )|
    ( pingRequestWaitRun _ -> "pingRequestWaitRun" )|
#endif
#ifdef XMPP
    ( xmppLoginRun -> "xmppLoginRun" )|
    ( xmppReconnectRun _ -> "xmppReconnectRun" )|
#endif
    ( rscLoadNextRun -> "rscLoadNextRun" )|
    ( rscLoadWaitRun http-> "rscLoadWaitRun" )|
    ( chorCmdRun _-> "chorCmdRun" )|
    ( streamCmdRun _-> "streamCmdRun" )|
    ( waitCmdRun _ -> "waitCmdRun" )|
    ( cmdEvalOne _-> "cmdEvalOne" )|
    ( idleRun -> "idleRun" )|
    ( sleepRun -> "sleepRun" )|
    ( recordRun -> "recordRun" )|
    ( recordStartRun -> "recordStartRun" )|
    ( earResetWaitRun _ -> "earResetWaitRun" )
    ;;

// Set main loop state
fun run_set_state r =
    // Secho "run_set_state "; Secholn _run_to_str r;
    let run -> old_run in (
        set run = r;
        old_run
    );;

fun run_init =
    run_set_state configstartRun;
    task_start "run" #run_task;;

fun _run_control_wait =
    let button_get_event -> ev in
    let if ev==nil then ears_get_event else ev -> ev in
    if ev!=nil then
    (
        audiolib_wav_stop;
        ears_stop 0;
        if ev==BUTTON_CLIC then forth_interpreter WORD_ON_CLICK // click
        else if ev==BUTTON_DCLIC then forth_interpreter WORD_ON_DBL_CLICK //ackall
        else if ev==BUTTON_LCLIC then record_control 0  //back ou record
        else if ev==BUTTON_DLCLIC then record_control 1 //back ou record
        else if ev&0x8000 then forth_interpreter WORD_ON_EARS // oreilles
    );
    rfid_control
    ;;


fun _run_control_inter =
    let button_get_event -> ev in
    if ev!=nil then
    (
        if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then (
            if (interactive_int_mask & MASK_BUTTON == 0) then interactive_send_btn ev
        ) else if ev==BUTTON_LCLIC then (
            if (record_enabled) then (
                // remember wav position and start record
                set record_last_wav_bytes = audiolib_wav_cur_played_bytes;
                record_control 0;
                0
            ) else (
                // like BUTTON_CLIC
                set ev = BUTTON_CLIC;
                if (interactive_int_mask & MASK_BUTTON == 0) then interactive_send_btn ev
            )
        )
    );
    rfid_control
    ;;

/**
    Stop everything we can be doing and resets to either idle or asleep
 */
fun run_reset_to_idle =
    audiolib_wav_stop;
    streaming_stop;
    ears_start_reset;
    set interactive_status = 0;
    set interactive_cookie = "";
    set interactive_app = nil;
    set chor_processing_status = 0;
    set streaming_status = 0;
    set streaming_current_program = nil;
    run_set_state if !sleep_is_sleeping then idleRun else sleepRun;
    0
;;

fun _run_control_play =
    let button_get_event -> ev in
    if ev!=nil then (
        audiolib_wav_stop;
        ears_stop 0;
        let atoi listswitchstr streaming_current_program "ID" -> id in
            if ev==BUTTON_CLIC then (
                midi_play MIDI_ABORT;
                if (streaming_status) then streaming_stop;
                endOfProgram 0;
#ifdef XMPP
                XmppSessionSendButtonMsg ev 1 id
#else
                0
#endif
            ) //pause
            else if ev==BUTTON_DCLIC then (
                midi_play MIDI_ACK;
                if (streaming_status) then streaming_stop;
                endOfProgram 0;
#ifdef XMPP
                XmppSessionSendButtonMsg ev 1 id
#else
                0
#endif
            ) //ackall
            else if ev==BUTTON_LCLIC then nil //pause ou record ? callPingRequest 5
    )
    ;;

/*
    Utilise dans le cas ou on execute un programme et qu'on est en train
  d'executer une commande "WT". En gros on a un comportement normal
  sauf qu'on lit les rfid en plus
*/
fun _run_control_program_wait =
    (if (!interactive_status) then _run_control_play else _run_control_inter) ;
    rfid_control
;;



fun _run_idle =
#ifdef XMPP
    // if trame waiting, execute it
    let trame_get_next_pending -> trame in
    if trame != nil then (
        trame_eval trame;
        0
    )
    else
#endif
    (
        set chor_processing_status = 0;
#ifdef SERVERLESS
        if surprise_check then (
            surprise;
            0
        )
        else
#endif
        if chor_do_taichi_now then (
            chor_taichi_start nil
        ) else (
#ifdef PING
            ping_run_start
#else
            0
#endif
        )
    );
    0;;


fun _run_parse_config_cb _ res=
    ntp_get_time;
    forth_init;

    if (nil != res) then
    (
        Secholn "config=";
        let trame_filter_config Secholn http_get_content res 0-> conf in
        (
            // http urls
            set url_ping_server=listswitchstr conf "ping";
            set url_broadcast=listswitchstr conf "broad";
            if !strcmp url_ping_server "0.0.0.0" then set url_ping_server = config_get_server_url;
            if !strcmp url_broadcast "0.0.0.0" then set url_broadcast = config_get_server_url;

#ifdef PING
            sleep_wake_up nil;
            if url_ping_server!=nil && url_broadcast!=nil then run_set_state pingstartRun;
#endif
#ifdef XMPP
        /****** XMPP ****/
            let listswitchstr conf "xmpp_domain" -> xmpp_domain in
                if xmpp_domain != nil then
                    XmppSessionStart xmpp_domain 1; // START 1 XMPP SESSION HERE (1 == Display Leds for connexion Details)

            run_set_state xmppLoginRun;
#endif
#ifdef SERVERLESS
            sleep_wake_up nil;
#endif
            0
        )
    )
;;

fun _run_config_start =
    if wifi_connected && audiolib_wav_running==0 then (
#ifdef SERVERLESS
        ntp_get_time;
        forth_init // set the run state to configwaitRun while fetching init.forth
#else
        Secho "config_get_server_url: "; Secholn config_get_server_url;
        Secho "url_config: "; Secholn url_config;
        run_set_state configwaitRun http_request "GET" url_config nil #_run_parse_config_cb HTTP_NORMAL
#endif
    );
    0;;

/**
 * Check forth.init/config fetch timeout
 */
fun _run_config_wait http=
    // check timeout and retry : cligne + ou - la led middle body toutes les secondes en bleu
    if ((http_inactive http) > STD_NET_TIMEOUT) then
    (
        Secholn "##timeout on configwait";
        http_abort http;
        run_set_state configstartRun
    );
    0;;

fun _run_step_match=
    // Secholn _run_to_str run;
    match run with
    ( configstartRun ->
        _run_config_start )|
    ( configwaitRun http ->
        _run_config_wait http )|
#ifdef PING
    ( pingstartRun ->
        if ping_current_trame_id!=RUN_MSG_ASLEEP then leds_bottom_animation;
        ping_run_start )|
    ( pingwaitRun http ->
        if ping_current_trame_id!=RUN_MSG_ASLEEP then (
            leds_bottom_animation;
            leds_nose_animation
        );
        runpingwait http;
        if ping_current_trame_id!=RUN_MSG_ASLEEP then RUN_WAIT)|
    ( pingRequestWaitRun http->
        leds_bottom_animation;
        leds_nose_animation;
        runPingRequestWait http;
        RUN_NONE )|
    ( stdWaitRun t ->
        if ping_current_trame_id != RUN_MSG_ASLEEP then (
            leds_bottom_animation;
            leds_nose_animation
        );
        runStdWait t;
        RUN_WAIT )|
#endif
#ifdef XMPP
    ( xmppLoginRun ->
        xmpp_run_login;
        RUN_WAIT )|
    ( xmppReconnectRun params ->
        if !sleep_is_sleeping then
            // On fige la base en violet
            led LED_BASE RGB_VIOLET;
        let params -> [waitTime xSession oldRun] in
            match xSession.sStatus with
                (sOpened -> run_set_state oldRun; 0)|
                (sClosed -> if time_ms > waitTime then XmppGateReconnect xSession 0; 0)|
                (_ -> 0);
        RUN_WAIT )|
#endif
    ( idleRun ->
        leds_bottom_animation;
        leds_nose_animation;
        _run_idle;
        RUN_WAIT ) |
    ( sleepRun ->
        _run_idle;
        RUN_NONE )|
    ( rscLoadNextRun ->
        leds_bottom_animation;
        leds_nose_animation;
        streaming_run_rsc_load_next_cmd;
        RUN_WAIT ) |
    ( rscLoadWaitRun http->
        leds_bottom_animation;
        leds_nose_animation;
        streaming_run_rsc_load_wait_cmd http;
        RUN_WAIT )|
    ( cmdEvalOne i->
        streaming_run_eval_one_cmd i;
        RUN_PLAY )|
    ( chorCmdRun i->
        leds_nose_animation;
        chor_run_cmd i;
        RUN_PLAY )|
    ( streamCmdRun i0->
        leds_nose_animation;
        streaming_run_cmd i0;
        RUN_PLAY )|
    ( waitCmdRun i ->
        leds_nose_animation;
        streaming_run_wait_cmd i;
        RUN_PROGRAM_WAIT )|
    ( earResetWaitRun cb ->
        RUN_NONE) |
    ( recordRun ->
        record_run )|
    ( recordStartRun ->
        record_start_run )|
    ( interactiveReqWaitRun http ->
        leds_bottom_animation;
        leds_nose_animation;
        interactive_request_wait http;
        RUN_WAIT );;

fun run_task task=
    let _run_step_match -> keymanager in (
        if keymanager == RUN_WAIT then
            _run_control_wait
        else if keymanager == RUN_PLAY then
            if !interactive_status then
                _run_control_play
            else
                _run_control_inter
        else if keymanager == RUN_PROGRAM_WAIT then
            _run_control_program_wait
        else
            button_get_event
    );
    TaskRun;;
