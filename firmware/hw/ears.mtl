#include protos/interactive_protos.mtl
#include protos/leds_protos.mtl
#include protos/ears_protos.mtl

/*
 Ears management.

 The link with the hardware is done via two methods: motorget and
 motorset.

 The ear is controlled via an engine that we can start in both
 directions and stop. To get feedback, there is a sensor that returns
 the number of holes it has seen so far. An ear has EARS_HOLES holes,
 with the same space between each hole except for one where the space
 is twice the size. It helps us know the absolute position of the ear.

 Two native methods help us access the hardware:

 * motorget motornum : where motornum is 0 or 1, returns the number of
 holes seen so far.

 * motorset motornum dir : where motornum is 0 or 1 and dir is -1 (go
 backward), 0 (stop), or 1 (go forward).

*/

#ifdef EARS_DEBUG
fun _ears_debug str= Secholn strcatlist "[ears] " :: str :: nil; nil;;
#else
fun _ears_debug str= nil;;
#endif

/**
 - numE: the ear number, 0 for right, 1 for left.
 - dirE: the direction in which the ear should move: 0: forward. !=0: backward.
 - targetE: the position we try to go to.
 - targetLoopE: the number of full loops to do before stopping at targetE pos. positive or negative depending on dirE.
 - posE: the last position we know the ear was in, 0 <= posE < EARS_HOLES.
 - lvalE: the last value returned by motorget e.numE
 - delayE: delay (in ms) between two motor holes.
 - ltimeE: last time (in ms) lvalE was updated.
 - countE: ?? (used when returning to previous position after having detected an ear move)
 - brokenE: if 1, the ear has been detected broken (did not respond to instructions). It can no longer be used.
*/
type Ear=[numE dirE targetE targetLoopE posE lvalE ldelayE ltimeE countE brokenE];; // v16 +targetLoopE

var ears;; // tab of two structs type Ear
var ears_mode;;  // EARSMODE_RESET, EARSMODE_WAIT, EARSMODE_WAITANDDETECT, EARSMODE_DETECT
var _ears_last_move;;	// somme des deux compteurs
var _ears_last_move_time;;	// heure du dernier mouvement, lors de la détection (=nil=> acquisition en cours)
var _ears_initialized = 0;; // 1 à partir du moment où les oreilles sont initialisées
var _ears_event;;

// position désirées des oreilles
var ears_left;;
var ears_right;;

fun ears_is_initialized=
    _ears_initialized;;

fun ears_get_event=
	let _ears_event -> ev in
	(
		set _ears_event=nil;
		ev
	);;

/*
 v16 +fun earLoop;;

 returns more or less (v / EAR_HOLES), > 0 (has to be called with prevLoop == 0)
*/
fun _ears_loop_count v prevLoop=
	if v<0 then _ears_loop_count v+EARS_HOLES prevLoop-1
	else if v>=EARS_HOLES then _ears_loop_count v-EARS_HOLES prevLoop+1
	else prevLoop;;

/*
  returns (v % EAR_HOLES), > 0
*/
fun _ears_check v=
	if v<0 then _ears_check v+EARS_HOLES
	else if v>=EARS_HOLES then _ears_check v-EARS_HOLES
	else v;;


fun _ears_motor_set e val =
	_ears_debug strcatlist "_ears_motor_set " :: (itoa e.numE) :: " " :: (itoa val) :: nil;
	if (!_ears_initialized) then
	(
		_ears_debug "ears not inited yet" ;
		ears_init
	);
	set e.dirE=val;
	motorset e.numE val
;;

fun ears_start_reset=
	if ears_mode!=EARSMODE_RESET then (
		_ears_debug "ears_start_reset";
		set ears_mode=EARSMODE_RESET;
		for i=0;i<2 do let ears.i -> e in
		(
			_ears_debug strcatlist "asking for reset of ear " :: (itoa i) :: nil ;
			_ears_motor_set e 1;
			set e.brokenE=0;
			set e.targetE=nil;
			set e.targetLoopE=nil; // v16
			set e.lvalE=motorget i;
			set e.ldelayE=nil;
			set e.ltimeE=time_ms
		);
		_ears_debug "ears_start_reset end";
        0
	);;

/**
 * Creates the tab to handle the ears. No action should be made
 * concerning the ears before having called this function.
 */
fun ears_init=
	set ears=tabnew nil 2;
	for i=0;i<2 do set ears.i=[numE:i];
	set _ears_initialized = 1;
	set ears_mode = -1;
	ears_start_reset
	;;

fun ears_start_detect=
	_ears_debug "ears_start_detect";
	led LED_NOSE RGB_RED;
	led LED_BODY_LEFT RGB_VIOLET;
	led LED_BODY_MIDDLE RGB_BLACK;
	led LED_BODY_RIGHT RGB_VIOLET;
	set ears_mode=EARSMODE_DETECT;
	set _ears_last_move_time=time_ms;
	set _ears_last_move=(motorget 0)+(motorget 1);;


fun _ears_detect_run=
	if _ears_last_move_time!=nil then
	(
		let (motorget 0)+(motorget 1)->newval in
		if newval!=_ears_last_move then
		(
			set _ears_last_move=newval;
			set _ears_last_move_time=time_ms
		)
		else if time_ms-_ears_last_move_time>EARS_TIMEOUT then
		(
			set _ears_last_move_time=nil;
			for i=0;i<2 do let ears.i -> e in
			if e.brokenE!=1 then
			(
				set e.lvalE=motorget i;
				set e.ldelayE=0;
				set e.ltimeE=time_ms;
				_ears_motor_set e 1;
				set e.countE=e.lvalE+EARS_HOLES
			)
		)
	)
	else
	(
		for i=0;i<2 do let ears.i -> e in
			if e.brokenE!=1 then
			if e.dirE then
			let motorget i -> v in
			if v!=e.lvalE then
				let time_ms -> t in
				let t-e.ltimeE -> d in
				(
					if d>e.ldelayE then
					(
						set e.posE=_ears_check e.countE-e.lvalE-EARS_OFFZERO-1;
						set e.ldelayE=d
					);
					set e.ltimeE=t;
					set e.lvalE=v;
					if v-e.countE>=0 then _ears_motor_set e 0
				);
		if (ears.(0).dirE)==0 && (ears.(1).dirE)==0 then
		(
			set _ears_event=0x8000+(ears.(0).posE<<8)+(ears.(1).posE);
			Secho "Acquisition : "; Iecho ears.(0).posE; Secho ", ";Iecholn ears.(1).posE;
			set ears_mode=EARSMODE_WAITANDDETECT
		)
	);;

fun _ears_reset_run=
	for i=0;i<2 do let ears.i -> e in
	if e.dirE then
	(
		// still trying to move
		let motorget i -> v in
		if v==e.lvalE then
		(	// still previous position
			let time_ms -> t in
			let t-e.ltimeE -> d in
			if d>5000 then
			(
				_ears_debug strcatlist "broken :" :: (itoa i) :: nil;
				set e.brokenE=1;
				set e.posE=0;
//				set e.lvalE=v;
				set e.targetE=0;
				set e.targetLoopE=0; // v16
				set e.ldelayE=0;
				_ears_motor_set e 0
			)
		)
		else
		if e.targetE!=nil then
		(	// moved and have a target : check arrived
			set e.posE=_ears_check e.posE+v-e.lvalE;
			set e.lvalE=v;
			if e.posE==e.targetE then
				if e.targetLoopE == 0 then
					_ears_motor_set e 0
				else if e.dirE>0 then
					set e.targetLoopE = e.targetLoopE-1
				else
					set e.targetLoopE = e.targetLoopE+1
		)
		else
		let time_ms -> t in
		let t-e.ltimeE -> d in
		(	// moved and no target
			if (d<10000) && (d>600) && (nil!=e.ldelayE) then
			(
				/* if entering there, we know the ear is at position "zero",
					because of the delay between two holes. */
				//Secho "gowait "; Iecholn d; Iecholn e.ldelayE;
				set e.posE=_ears_check -EARS_OFFZERO; // position "zero"
				set e.targetE=0;
				set e.targetLoopE=0 //v16
			)
			else
			(
				// Secho "position "; Iecho e.lvalE; Secho " : "; Iecho v; Secho " during "; Iecholn d;
				set e.ltimeE=t
			);
			set e.lvalE=v;
			set e.ldelayE=d
		)
	);
	if (ears.(0).dirE)==0 && (ears.(1).dirE)==0 then
	(
		// finished reset
		set ears_mode=EARSMODE_WAIT
	);;

fun _ears_wait_run=
	for i=0;i<2 do let ears.i -> e in
	if e.brokenE!=1 then
	(
		// Secho "ear "; Iecho i; Secho "last pos="; Iecho e.lvalE; Secho ",pos=";
		let motorget i -> v in
		if v!=e.lvalE then
		let (/* Secho "dv="; Iecho */ v-e.lvalE) -> dv in
		if e.dirE then (
			// Oreille en train de tourner
			//_ears_debug ", tourne e.dirE="; Iecho e.dirE;
			set e.lvalE=v;
			set e.posE=_ears_check e.posE+ if e.dirE>0 then dv else -dv;
			if e.posE==e.targetE then
			(
//					Secho "stop "; Iecholn e.numE;
				if e.targetLoopE == 0 then //v16
					_ears_motor_set e 0
				else if e.dirE>0 then
					set e.targetLoopE = e.targetLoopE-1 //v16
				else
					set e.targetLoopE = e.targetLoopE+1 // v16
			)
		) else if dv>2 then (
			//_ears_debug "bouged";
			// Pas de mvt autonome.
			// Veut dire qu'une oreille a été tournée par l'utilisateur :
			// si interactif : le noter
			// sinon passer en mode detect
			set e.lvalE=v;
			if interactive_status then
				(interactive_note_ear_touched i v dv)
			else if ears_mode==EARSMODE_WAITANDDETECT then
				ears_start_detect
		)
	);;

// boucle pour faire tourner les oreilles vers leur targetobjectif
fun ears_run=
	if (_ears_initialized) then (
		if ears_mode==EARSMODE_RESET then _ears_reset_run
		else if ears_mode==EARSMODE_DETECT then _ears_detect_run
		else _ears_wait_run
	);
	0;;

fun ears_resetting=
    ears_mode==EARSMODE_RESET;;

fun ears_detecting=
    ears_mode==EARSMODE_DETECT;;

fun ears_finished_moving=
    (!ears_resetting) && (!ears.(0).dirE) && (!ears.(1).dirE);;

fun ears_set_wait_and_detect_mode=
	if ears_mode==EARSMODE_WAIT then set ears_mode=EARSMODE_WAITANDDETECT;;

fun ears_set_wait_only_mode=
	if ears_mode==EARSMODE_WAITANDDETECT then set ears_mode=EARSMODE_WAIT;;

fun ears_stop force =
	_ears_debug (strcatlist "ears_stop " :: (itoa force) :: nil);
	if (_ears_initialized && (ears_mode!=EARSMODE_RESET || force)) then (for i=0;i<2 do _ears_motor_set ears.i 0) else ( _ears_debug "ears not inited yet"; 0 );
	0;;

fun ears_target i=
    ears.(i).targetE + ears.(i).targetLoopE*EARS_HOLES;; // v16

// oreille i doit aller à position p dans direction d
// i==0 : droite, i==1 : gauche
// p = int quelconque, même > 17
// d==0 : vers l'avant, d!=0 : vers l'arrière
fun ears_go i p d=
	if ears_mode==EARSMODE_WAIT ||ears_mode==EARSMODE_WAITANDDETECT then
	let ears.i->e in
	let (if d then -1 else 1) -> dir in // v16
	if e.brokenE==1 then
	(
		_ears_debug strcatlist "ears_go " :: (itoa i) :: " broken !" :: nil;
		nil
	)
	else
	if p!=ears_target i then //v16 add start
	(
		_ears_debug strcatlist "ears_go " :: (itoa i) :: " to " :: (itoa p) :: " dir " :: (itoa d) :: nil;
		set e.targetE=_ears_check p;
		set e.targetLoopE=_ears_loop_count p 0;
		_ears_debug strcatlist "targetE=" :: (itoa e.targetE) :: " targetLoopE=" :: (itoa e.targetLoopE) :: nil;
		if e.posE==e.targetE then
			if e.targetLoopE==0 then
			_ears_motor_set e 0 // on est arrivés
			else
			(
				if dir>0 then set e.targetLoopE = e.targetLoopE - 1
				else set e.targetLoopE = e.targetLoopE + 1;
				_ears_motor_set e dir
			)
		else (
		if e.targetLoopE<0 then set e.targetLoopE=e.targetLoopE+1; // sinon fait un tour de trop
		_ears_motor_set e dir //v16 add end
		)
	);
	0;;

fun ears_go_to_ref_pos=
	_ears_debug "ears_go_to_ref_pos";
	if (ears_left != nil || ears_right != nil) then (
		ears_go 0 ears_left EARS_DIR_LEFT;
		ears_go 1 ears_right EARS_DIR_RIGHT;
		set ears_left = set ears_right = nil
	) else (
		ears_go 0 0 0;
		ears_go 1 0 0
	);;

fun ears_ready=
    ears_mode!=EARSMODE_RESET;;

fun ears_detecting=
    ears_mode==EARSMODE_DETECT;;

fun ears_complete=
    ears_ready && (!ears.(0).dirE) && (!ears.(1).dirE);;

/**
 * Return ears status as JSON
 */
fun ears_json=
    strcatlist
        "{\n"::
            (json_int "mode" ears_mode) :: ",\n" ::
            (json_int "left" ears_left) :: ",\n" ::
            (json_int "right" ears_right) :: ",\n" ::
            (json_int "ear_detecting" ears_detecting) :: "\n" ::
        "}" :: nil
;;
