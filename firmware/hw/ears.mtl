#include protos/interactive_protos.mtl
#include protos/leds_protos.mtl
#include protos/ears_protos.mtl
#include protos/run_protos.mtl
#include protos/task_protos.mtl
#include protos/json_protos.mtl

/*
 Ears management.

 The link with the hardware is done via two methods: motorget and
 motorset.

 The ear is controlled via an engine that we can start in both
 directions and stop. To get feedback, there is a sensor that returns
 the number of holes it has seen so far. An ear has EARS_HOLES holes,
 with the same space between each hole except for one where the space
 is twice the size. It helps us know the absolute position of the ear.

 Two native methods help us access the hardware:

 * motorget motornum: returns the number of holes seen so far.
 * motorset motornum dir: set motor direction 0 (stop), 1 (go forward), -1 (go backward).


+-------------------+    reset complete   +-------------------+
| EARS_MODE_RESET   |-------------------->|   EARS_MODE_WAIT  |
+-------------------+                     +-------------------+
                                               |         ^
                ears_set_mode_wait_and_detect  |         |  ears_set_mode_wait
                                               v         |
                    +-----------------------------+      |
                    |  EARS_MODE_WAIT_AND_DETECT  |------+
                    +-----------------------------+
                           ^           |
       detection complete  |           |  ears_set_mode_detect
                           |           v
                      +-------------------+
                      | EARS_MODE_DETECT  |
                      +-------------------+

*/

#ifdef EARS_DEBUG
fun _ears_debug str= Secholn strcatlist "[ears] " :: str :: nil; nil;;
#endif

type Ear = [
    ear_number          // the ear number, 0 for right, 1 for left.
    ear_direction       // the direction in which the ear should move: 0: forward. !=0: backward.
    ear_target          // the position we try to go to.
    ear_target_loop     // the number of full loops to do before stopping at ear_target pos. positive or negative depending on ear_direction.
    ear_last_position   // the last position we know the ear was in, 0 <= ear_last_position < EARS_HOLES.
    ear_last_value      // the last value returned by motorget e.ear_number
    ear_delay           // delay (in ms) between two motor holes.
    ear_last_time       // last time (in ms) ear_last_value was updated.
    ear_count           // ?? (used when returning to previous position after having detected an ear move)
    ear_broken          // if 1, the ear has been detected broken (did not respond to instructions). It can no longer be used.
];;

var ears;; // tab of two structs type Ear
var _ears_mode;;  // EARS_MODE_RESET, EARS_MODE_WAIT, EARS_MODE_WAIT_AND_DETECT, EARS_MODE_DETECT
var _ears_last_move;;	// somme des deux compteurs
var _ears_last_move_time;;	// heure du dernier mouvement, lors de la détection (=nil=> acquisition en cours)
var _ears_initialized = 0;; // 1 à partir du moment où les oreilles sont initialisées
var _ears_event;;  // last ear event (to be retrieved by ears_get_event)
var ears_target_position = { nil nil };; // ears target position table [left_pos, right_pos]

/**
 * Check if the ears have been initialized
 */
fun ears_is_initialized=
    _ears_initialized;;

/**
 * Returns the last ear event and clears it.
 */
fun ears_get_event=
	let _ears_event -> ev in
	(
		set _ears_event=nil;
		ev
	);;

/**
 * Returns more or less (v / EAR_HOLES), > 0 (has to be called with prevLoop == 0)
*/
fun _ears_loop_count v prevLoop=
	if v<0 then _ears_loop_count v+EARS_HOLES prevLoop-1
	else if v>=EARS_HOLES then _ears_loop_count v-EARS_HOLES prevLoop+1
	else prevLoop;;

/**
 * Returns (v % EAR_HOLES), > 0
*/
fun _ears_check v=
	if v<0 then _ears_check v+EARS_HOLES
	else if v>=EARS_HOLES then _ears_check v-EARS_HOLES
	else v;;

/**
 * Sets the motor direction for ear e
 */
fun _ears_motor_set_direction e dir =
#ifdef EARS_DEBUG
	_ears_debug strcatlist "Set ear " :: (itoa e.ear_number) :: " motor to " :: (itoa dir) :: nil;
#endif
	if (!_ears_initialized) then
	(
        set _ears_initialized = 1;
#ifdef EARS_DEBUG
        _ears_debug "Ears initializing...";
#endif
        set _ears_mode = EARS_MODE_WAIT;
        ears_start_reset
	);
	set e.ear_direction = dir;
	motorset e.ear_number dir
;;

/**
 * Starts the ears reset process
 */
fun ears_start_reset=
	if _ears_mode!=EARS_MODE_RESET then (
        if !_ears_initialized then
            set _ears_initialized = 1;
#ifdef EARS_DEBUG
        _ears_debug "Set mode EARS_MODE_RESET";
#endif
		set _ears_mode=EARS_MODE_RESET;
		for i=0;i<2 do let ears.i -> e in
		(
#ifdef EARS_DEBUG
			_ears_debug strcatlist "Asking for reset of ear " :: (itoa i) :: nil ;
#endif
			_ears_motor_set_direction e 1;
			set e.ear_broken=0;
			set e.ear_target=nil;
			set e.ear_target_loop=nil; // v16
			set e.ear_last_value=motorget i;
			set e.ear_delay=nil;
			set e.ear_last_time=time_ms
		);
        0
	);;

/**
 * Set ears to detection mode
 */
fun ears_set_mode_detect=
#ifdef EARS_DEBUG
	_ears_debug "Set mode EARS_MODE_DETECT";
#endif
	leds_set_color LED_NOSE RGB_RED;
	leds_set_color LED_BODY_LEFT RGB_VIOLET;
	leds_set_color LED_BODY_MIDDLE RGB_BLACK;
	leds_set_color LED_BODY_RIGHT RGB_VIOLET;
	set _ears_mode=EARS_MODE_DETECT;
	set _ears_last_move_time=time_ms;
	set _ears_last_move=(motorget 0)+(motorget 1);;

/**
 * Set ears to wait and detect mode
 */
fun ears_set_mode_wait_and_detect=
	if _ears_mode==EARS_MODE_WAIT then (
#ifdef EARS_DEBUG
        _ears_debug "Set mode EARS_MODE_WAIT_AND_DETECT";
#endif
        set _ears_mode=EARS_MODE_WAIT_AND_DETECT
    );;

/**
 * Set ears to wait mode
 */
fun ears_set_mode_wait=
	if _ears_mode==EARS_MODE_WAIT_AND_DETECT then (
#ifdef EARS_DEBUG
        _ears_debug "Set mode EARS_MODE_WAIT";
#endif
        set _ears_mode=EARS_MODE_WAIT
    );;

/**
 * Ears detection process
 */
fun _ears_detect_run=
	if _ears_last_move_time!=nil then
	(
		let (motorget 0)+(motorget 1)->newval in
		if newval!=_ears_last_move then
		(
			set _ears_last_move=newval;
			set _ears_last_move_time=time_ms
		)
		else if time_ms-_ears_last_move_time>EARS_TIMEOUT then
		(
			set _ears_last_move_time=nil;
			for i=0;i<2 do let ears.i -> e in
			if e.ear_broken!=1 then
			(
				set e.ear_last_value=motorget i;
				set e.ear_delay=0;
				set e.ear_last_time=time_ms;
				_ears_motor_set_direction e 1;
				set e.ear_count=e.ear_last_value+EARS_HOLES
			)
		)
	)
	else
	(
		for i=0;i<2 do let ears.i -> e in
			if e.ear_broken!=1 then
			if e.ear_direction then
			let motorget i -> v in
			if v!=e.ear_last_value then
				let time_ms -> t in
				let t-e.ear_last_time -> d in
				(
					if d>e.ear_delay then
					(
						set e.ear_last_position=_ears_check e.ear_count-e.ear_last_value-EARS_OFFZERO-1;
						set e.ear_delay=d
					);
					set e.ear_last_time=t;
					set e.ear_last_value=v;
					if v-e.ear_count>=0 then _ears_motor_set_direction e 0
				);
		if (ears.(0).ear_direction)==0 && (ears.(1).ear_direction)==0 then
		(
			set _ears_event=0x8000+(ears.(0).ear_last_position<<8)+(ears.(1).ear_last_position);
#ifdef EARS_DEBUG
			_ears_debug strcatlist "acquisition: " :: (itoa ears.(0).ear_last_position) :: ", " :: (itoa ears.(1).ear_last_position) :: nil;
            _ears_debug "Set mode EARS_MODE_WAIT_AND_DETECT";
#endif
			set _ears_mode=EARS_MODE_WAIT_AND_DETECT
		)
	);;

/**
 * Ears reset process
 */
fun _ears_reset_run=
	for i=0;i<2 do let ears.i -> e in
	if e.ear_direction then
	(
		// still trying to move
		let motorget i -> v in
		if v==e.ear_last_value then
		(	// still previous position
			let time_ms -> t in
			let t-e.ear_last_time -> d in
			if d>15000 then
			(
#ifdef EARS_DEBUG
				_ears_debug strcatlist "broken: " :: (itoa i) :: nil;
#endif
				set e.ear_broken=1;
				set e.ear_last_position=0;
//				set e.ear_last_value=v;
				set e.ear_target=0;
				set e.ear_target_loop=0; // v16
				set e.ear_delay=0;
				_ears_motor_set_direction e 0
			)
		)
		else
		if e.ear_target!=nil then
		(	// moved and have a target : check arrived
			set e.ear_last_position=_ears_check e.ear_last_position+v-e.ear_last_value;
			set e.ear_last_value=v;
			if e.ear_last_position==e.ear_target then (
				if e.ear_target_loop == 0 then
					_ears_motor_set_direction e 0
				else if e.ear_direction>0 then
					set e.ear_target_loop = e.ear_target_loop-1
				else
					set e.ear_target_loop = e.ear_target_loop+1
                    )
		)
		else
		let time_ms -> t in
		let t-e.ear_last_time -> d in
		(	// moved and no target
			if (d<10000) && (d>600) && (nil!=e.ear_delay) then
			(
				/* if entering there, we know the ear is at position "zero",
					because of the delay between two holes. */
				set e.ear_last_position=_ears_check -EARS_OFFZERO; // position "zero"
				set e.ear_target=0;
				set e.ear_target_loop=0 //v16
			)
			else
			(
				set e.ear_last_time=t
			);
			set e.ear_last_value=v;
			set e.ear_delay=d
		)
	);
	if (ears.(0).ear_direction)==0 && (ears.(1).ear_direction)==0 then
	(
		// finished reset
#ifdef EARS_DEBUG
        _ears_debug "Set mode EARS_MODE_WAIT";
#endif
        for i=0;i<2 do let ears.i -> e in
            if e.ear_broken!=1 then
                set e.ear_last_value = motorget i;
		set _ears_mode=EARS_MODE_WAIT
	);;

/**
 * Ears wait/wait and detect process
 */
fun _ears_wait_run=
	for i=0;i<2 do let ears.i -> e in
	if e.ear_broken!=1 then
	(
		let motorget i -> v in
		let v-e.ear_last_value -> delta in
		if v==e.ear_last_value then (
            nil
		) else if e.ear_direction then (
			// Oreille en train de tourner
			//_ears_debug ", tourne e.ear_direction="; Iecho e.ear_direction;
			set e.ear_last_value = v;
			set e.ear_last_position=_ears_check e.ear_last_position+ if e.ear_direction>0 then delta else -delta;
			if e.ear_last_position==e.ear_target then
			(
                // Secho "stop "; Iecholn e.ear_number;
				if e.ear_target_loop == 0 then //v16
					_ears_motor_set_direction e 0
				else if e.ear_direction>0 then
					set e.ear_target_loop = e.ear_target_loop-1 //v16
				else
					set e.ear_target_loop = e.ear_target_loop+1 // v16
			)
		) else if delta>2 then (
			//_ears_debug "bouged";
			// Pas de mvt autonome.
			// Veut dire qu'une oreille a été tournée par l'utilisateur :
			// si interactif : le noter
			// sinon passer en mode detect
			set e.ear_last_value = v;
			if interactive_status then
				(interactive_note_ear_touched i v delta)
			else if _ears_mode==EARS_MODE_WAIT_AND_DETECT then
				ears_set_mode_detect
		)
	);;

fun ears_resetting=
    _ears_mode==EARS_MODE_RESET;;

fun ears_detecting=
    _ears_mode==EARS_MODE_DETECT;;

fun ears_finished_moving=
    (!ears_resetting) && (!ears.(0).ear_direction) && (!ears.(1).ear_direction);;

fun ears_stop force =
#ifdef EARS_DEBUG
	_ears_debug (strcatlist "ears_stop " :: (itoa force) :: nil);
#endif
	if (_ears_initialized && (_ears_mode!=EARS_MODE_RESET || force)) then
        for i=0;i<2 do
            _ears_motor_set_direction ears.i 0;
	0;;

fun ears_target i=
    ears.(i).ear_target + ears.(i).ear_target_loop*EARS_HOLES;; // v16

/**
 * Returns the current position of ear i
 */
fun ears_get_position i=
    ears.(i).ear_last_position;;

// oreille i doit aller à position p dans direction d
// i==0 : droite, i==1 : gauche
// p = int quelconque, même > 17
// d==0 : vers l'avant, d!=0 : vers l'arrière
fun ears_go i p d=
	if _ears_mode==EARS_MODE_WAIT || _ears_mode==EARS_MODE_WAIT_AND_DETECT then
	let ears.i->e in
	let (if d then -1 else 1) -> dir in
	if e.ear_broken==1 then
	(
#ifdef EARS_DEBUG
		_ears_debug strcatlist "ears_go " :: (itoa i) :: " broken !" :: nil;
#endif
		nil
	)
	else if p!=ears_target i then
	(
#ifdef EARS_DEBUG
		_ears_debug strcatlist "ears_go " :: (itoa i) :: " to " :: (itoa p) :: " dir " :: (itoa d) :: nil;
#endif
		set e.ear_target=_ears_check p;
		set e.ear_target_loop=_ears_loop_count p 0;
#ifdef EARS_DEBUG
		_ears_debug strcatlist "ear_target=" :: (itoa e.ear_target) :: " ear_target_loop=" :: (itoa e.ear_target_loop) :: nil;
#endif
		if e.ear_last_position==e.ear_target then
			if e.ear_target_loop==0 then
                _ears_motor_set_direction e 0 // on est arrivés
			else
			(
				if dir>0 then set e.ear_target_loop = e.ear_target_loop - 1
				else set e.ear_target_loop = e.ear_target_loop + 1;
				_ears_motor_set_direction e dir
			)
		else (
            if e.ear_target_loop<0 then
                set e.ear_target_loop=e.ear_target_loop+1; // sinon fait un tour de trop
            _ears_motor_set_direction e dir
		)
	);
	0;;

fun ears_go_to_ref_pos=
	if (ears_target_position.EARS_LEFT != nil || ears_target_position.EARS_RIGHT != nil) then (
#ifdef EARS_DEBUG
        _ears_debug "Going to target position";
#endif
		ears_go EARS_LEFT ears_target_position.EARS_LEFT EARS_DIR_LEFT;
		ears_go EARS_RIGHT ears_target_position.EARS_RIGHT EARS_DIR_RIGHT;
		set ears_target_position.EARS_LEFT = nil;
        set ears_target_position.EARS_RIGHT = nil
	) else (
#ifdef EARS_DEBUG
        _ears_debug "Going to 0 0";
#endif
		ears_go EARS_LEFT 0 0;
		ears_go EARS_RIGHT 0 0
	);;

fun ears_ready=
    _ears_mode!=EARS_MODE_RESET;;

fun ears_detecting=
    _ears_mode==EARS_MODE_DETECT;;

fun ears_complete=
    ears_ready && (!ears.(0).ear_direction) && (!ears.(1).ear_direction);;

/**
 * Return one ear status as JSON
 */
fun ears_json_ear ear=
    strcatlist
        "{\n"::
            (json_int "num" ear.ear_number) :: ",\n" ::
            (json_int "direction" ear.ear_direction) :: ",\n" ::
            (json_int "target" ear.ear_target) :: ",\n" ::
            (json_int "target_loop" ear.ear_target_loop) :: ",\n" ::
            (json_int "last_position" ear.ear_last_position) :: ",\n" ::
            (json_int "last_value" ear.ear_last_value) :: ",\n" ::
            (json_int "delay" ear.ear_delay) :: ",\n" ::
            (json_int "last_time" ear.ear_last_time) :: ",\n" ::
            (json_int "count" ear.ear_count) :: ",\n" ::
            (json_int "broken" ear.ear_broken) :: "\n" ::
        "}" :: nil;;

/**
 * Return ears status as JSON
 */
fun ears_json=
    strcatlist
        "{\n"::
            (json_int "mode" _ears_mode) :: ",\n" ::
            (json_obj "left" ears_json_ear ears.EARS_LEFT) :: ",\n" ::
            (json_obj "right" ears_json_ear ears.EARS_RIGHT) :: "\n" ::
        "}" :: nil;;

/**
 * Ears task
 */
fun ears_task task=
	if _ears_initialized then
		if _ears_mode==EARS_MODE_RESET then
            _ears_reset_run
		else if _ears_mode==EARS_MODE_DETECT then
            _ears_detect_run
		else
            _ears_wait_run;
    // Check for ear reset completion callback
    match run_get_state with
        ( earResetWaitRun cb -> if !ears_resetting then call cb []; nil );
    TaskRun;;

/**
 * Creates the tab to handle the ears and starts the ears task.
 */
fun ears_init=
	set ears = tabnew nil 2;
    set ears_target_position = tabnew nil 2;
	for i=0;i<2 do set ears.i = [ear_number:i];
    // Start the ears task
    task_start "ears" #ears_task;;
