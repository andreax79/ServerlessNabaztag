#include protos/interactive_protos.mtl
#include protos/leds_protos.mtl
#include protos/ears_protos.mtl
#include protos/run_protos.mtl
#include protos/task_protos.mtl
#include protos/json_protos.mtl

/*
 Ears management.

 The link with the hardware is done via two methods: motorget and
 motorset.

 The ear is controlled via an engine that we can start in both
 directions and stop. To get feedback, there is a sensor that returns
 the number of holes it has seen so far. An ear has EARS_HOLES holes,
 with the same space between each hole except for one where the space
 is twice the size. It helps us know the absolute position of the ear.

 Two native methods help us access the hardware:

 * motorget motornum : where motornum is 0 or 1, returns the number of
 holes seen so far.

 * motorset motornum dir : where motornum is 0 or 1 and dir is -1 (go
 backward), 0 (stop), or 1 (go forward).

*/

#ifdef EARS_DEBUG
fun _ears_debug str= Secholn strcatlist "[ears] " :: str :: nil; nil;;
#endif

type Ear = [
    ear_number          // the ear number, 0 for right, 1 for left.
    ear_direction       // the direction in which the ear should move: 0: forward. !=0: backward.
    ear_target          // the position we try to go to.
    ear_target_loop     // the number of full loops to do before stopping at ear_target pos. positive or negative depending on ear_direction.
    ear_last_position   // the last position we know the ear was in, 0 <= ear_last_position < EARS_HOLES.
    ear_last_value      // the last value returned by motorget e.ear_number
    ear_delay           // delay (in ms) between two motor holes.
    ear_last_time       // last time (in ms) ear_last_value was updated.
    ear_count           // ?? (used when returning to previous position after having detected an ear move)
    ear_broken          // if 1, the ear has been detected broken (did not respond to instructions). It can no longer be used.
];;

var ears;; // tab of two structs type Ear
var ears_mode;;  // EARS_MODE_RESET, EARS_MODE_WAIT, EARS_MODE_WAIT_AND_DETECT, EARS_MODE_DETECT
var _ears_last_move;;	// somme des deux compteurs
var _ears_last_move_time;;	// heure du dernier mouvement, lors de la détection (=nil=> acquisition en cours)
var _ears_initialized = 0;; // 1 à partir du moment où les oreilles sont initialisées
var _ears_event;;  // last ear event (to be retrieved by ears_get_event)
var ears_target_position = { nil nil };; // ears target position table [left_pos, right_pos]

/**
 * Check if the ears have been initialized
 */
fun ears_is_initialized=
    _ears_initialized;;

/**
 * Returns the last ear event and clears it.
 */
fun ears_get_event=
	let _ears_event -> ev in
	(
		set _ears_event=nil;
		ev
	);;

/*
 v16 +fun earLoop;;

 returns more or less (v / EAR_HOLES), > 0 (has to be called with prevLoop == 0)
*/
fun _ears_loop_count v prevLoop=
	if v<0 then _ears_loop_count v+EARS_HOLES prevLoop-1
	else if v>=EARS_HOLES then _ears_loop_count v-EARS_HOLES prevLoop+1
	else prevLoop;;

/*
  returns (v % EAR_HOLES), > 0
*/
fun _ears_check v=
	if v<0 then _ears_check v+EARS_HOLES
	else if v>=EARS_HOLES then _ears_check v-EARS_HOLES
	else v;;

/**
 * Sets the motor direction for ear e
 */
fun _ears_motor_set_direction e dir =
#ifdef EARS_DEBUG
	_ears_debug strcatlist "_ears_motor_set_direction " :: (itoa e.ear_number) :: " " :: (itoa dir) :: nil;
#endif
	if (!_ears_initialized) then
	(
        set _ears_initialized = 1;
        set ears_mode = -1;
        ears_start_reset
	);
	set e.ear_direction = dir;
	motorset e.ear_number dir
;;

fun ears_start_reset=
	if ears_mode!=EARS_MODE_RESET then (
#ifdef EARS_DEBUG
		_ears_debug "ears_start_reset";
#endif
		set ears_mode=EARS_MODE_RESET;
		for i=0;i<2 do let ears.i -> e in
		(
#ifdef EARS_DEBUG
			_ears_debug strcatlist "asking for reset of ear " :: (itoa i) :: nil ;
#endif
			_ears_motor_set_direction e 1;
			set e.ear_broken=0;
			set e.ear_target=nil;
			set e.ear_target_loop=nil; // v16
			set e.ear_last_value=motorget i;
			set e.ear_delay=nil;
			set e.ear_last_time=time_ms
		);
#ifdef EARS_DEBUG
		_ears_debug "ears_start_reset end";
#endif
        0
	);;


fun ears_start_detect=
#ifdef EARS_DEBUG
	_ears_debug "ears_start_detect";
#endif
	led LED_NOSE RGB_RED;
	led LED_BODY_LEFT RGB_VIOLET;
	led LED_BODY_MIDDLE RGB_BLACK;
	led LED_BODY_RIGHT RGB_VIOLET;
	set ears_mode=EARS_MODE_DETECT;
	set _ears_last_move_time=time_ms;
	set _ears_last_move=(motorget 0)+(motorget 1);;


fun _ears_detect_run=
	if _ears_last_move_time!=nil then
	(
		let (motorget 0)+(motorget 1)->newval in
		if newval!=_ears_last_move then
		(
			set _ears_last_move=newval;
			set _ears_last_move_time=time_ms
		)
		else if time_ms-_ears_last_move_time>EARS_TIMEOUT then
		(
			set _ears_last_move_time=nil;
			for i=0;i<2 do let ears.i -> e in
			if e.ear_broken!=1 then
			(
				set e.ear_last_value=motorget i;
				set e.ear_delay=0;
				set e.ear_last_time=time_ms;
				_ears_motor_set_direction e 1;
				set e.ear_count=e.ear_last_value+EARS_HOLES
			)
		)
	)
	else
	(
		for i=0;i<2 do let ears.i -> e in
			if e.ear_broken!=1 then
			if e.ear_direction then
			let motorget i -> v in
			if v!=e.ear_last_value then
				let time_ms -> t in
				let t-e.ear_last_time -> d in
				(
					if d>e.ear_delay then
					(
						set e.ear_last_position=_ears_check e.ear_count-e.ear_last_value-EARS_OFFZERO-1;
						set e.ear_delay=d
					);
					set e.ear_last_time=t;
					set e.ear_last_value=v;
					if v-e.ear_count>=0 then _ears_motor_set_direction e 0
				);
		if (ears.(0).ear_direction)==0 && (ears.(1).ear_direction)==0 then
		(
			set _ears_event=0x8000+(ears.(0).ear_last_position<<8)+(ears.(1).ear_last_position);
#ifdef EARS_DEBUG
			_ears_debug strcatlist "acquisition: " :: (itoa ears.(0).ear_last_position) :: ", " :: (itoa ears.(1).ear_last_position) :: nil;
#endif
			set ears_mode=EARS_MODE_WAIT_AND_DETECT
		)
	);;

fun _ears_reset_run=
	for i=0;i<2 do let ears.i -> e in
	if e.ear_direction then
	(
		// still trying to move
		let motorget i -> v in
		if v==e.ear_last_value then
		(	// still previous position
			let time_ms -> t in
			let t-e.ear_last_time -> d in
			if d>15000 then
			(
#ifdef EARS_DEBUG
				_ears_debug strcatlist "broken: " :: (itoa i) :: nil;
#endif
				set e.ear_broken=1;
				set e.ear_last_position=0;
//				set e.ear_last_value=v;
				set e.ear_target=0;
				set e.ear_target_loop=0; // v16
				set e.ear_delay=0;
				_ears_motor_set_direction e 0
			)
		)
		else
		if e.ear_target!=nil then
		(	// moved and have a target : check arrived
			set e.ear_last_position=_ears_check e.ear_last_position+v-e.ear_last_value;
			set e.ear_last_value=v;
			if e.ear_last_position==e.ear_target then
				if e.ear_target_loop == 0 then
					_ears_motor_set_direction e 0
				else if e.ear_direction>0 then
					set e.ear_target_loop = e.ear_target_loop-1
				else
					set e.ear_target_loop = e.ear_target_loop+1
		)
		else
		let time_ms -> t in
		let t-e.ear_last_time -> d in
		(	// moved and no target
			if (d<10000) && (d>600) && (nil!=e.ear_delay) then
			(
				/* if entering there, we know the ear is at position "zero",
					because of the delay between two holes. */
				//Secho "gowait "; Iecholn d; Iecholn e.ear_delay;
				set e.ear_last_position=_ears_check -EARS_OFFZERO; // position "zero"
				set e.ear_target=0;
				set e.ear_target_loop=0 //v16
			)
			else
			(
				// Secho "position "; Iecho e.ear_last_value; Secho " : "; Iecho v; Secho " during "; Iecholn d;
				set e.ear_last_time=t
			);
			set e.ear_last_value=v;
			set e.ear_delay=d
		)
	);
	if (ears.(0).ear_direction)==0 && (ears.(1).ear_direction)==0 then
	(
		// finished reset
		set ears_mode=EARS_MODE_WAIT
	);;

fun _ears_wait_run=
	for i=0;i<2 do let ears.i -> e in
	if e.ear_broken!=1 then
	(
		// Secho "ear "; Iecho i; Secho "last pos="; Iecho e.ear_last_value; Secho ",pos=";
		let motorget i -> v in
		let v-e.ear_last_value -> delta in
		if v==e.ear_last_value then (
            nil
		) else if e.ear_direction then (
			// Oreille en train de tourner
			//_ears_debug ", tourne e.ear_direction="; Iecho e.ear_direction;
			set e.ear_last_value = v;
			set e.ear_last_position=_ears_check e.ear_last_position+ if e.ear_direction>0 then delta else -delta;
			if e.ear_last_position==e.ear_target then
			(
                // Secho "stop "; Iecholn e.ear_number;
				if e.ear_target_loop == 0 then //v16
					_ears_motor_set_direction e 0
				else if e.ear_direction>0 then
					set e.ear_target_loop = e.ear_target_loop-1 //v16
				else
					set e.ear_target_loop = e.ear_target_loop+1 // v16
			)
		) else if delta>2 then (
			//_ears_debug "bouged";
			// Pas de mvt autonome.
			// Veut dire qu'une oreille a été tournée par l'utilisateur :
			// si interactif : le noter
			// sinon passer en mode detect
			set e.ear_last_value = v;
			if interactive_status then
				(interactive_note_ear_touched i v delta)
			else if ears_mode==EARS_MODE_WAIT_AND_DETECT then
				ears_start_detect
		)
	);;

fun ears_resetting=
    ears_mode==EARS_MODE_RESET;;

fun ears_detecting=
    ears_mode==EARS_MODE_DETECT;;

fun ears_finished_moving=
    (!ears_resetting) && (!ears.(0).ear_direction) && (!ears.(1).ear_direction);;

fun ears_set_wait_and_detect_mode=
	if ears_mode==EARS_MODE_WAIT then set ears_mode=EARS_MODE_WAIT_AND_DETECT;;

fun ears_set_wait_only_mode=
	if ears_mode==EARS_MODE_WAIT_AND_DETECT then set ears_mode=EARS_MODE_WAIT;;

fun ears_stop force =
#ifdef EARS_DEBUG
	_ears_debug (strcatlist "ears_stop " :: (itoa force) :: nil);
#endif
	if (_ears_initialized && (ears_mode!=EARS_MODE_RESET || force)) then
        for i=0;i<2 do
            _ears_motor_set_direction ears.i 0;
	0;;

fun ears_target i=
    ears.(i).ear_target + ears.(i).ear_target_loop*EARS_HOLES;; // v16

/**
 * Returns the current position of ear i
 */
fun ears_get_position i=
    ears.(i).ear_last_position;;

// oreille i doit aller à position p dans direction d
// i==0 : droite, i==1 : gauche
// p = int quelconque, même > 17
// d==0 : vers l'avant, d!=0 : vers l'arrière
fun ears_go i p d=
	if ears_mode==EARS_MODE_WAIT || ears_mode==EARS_MODE_WAIT_AND_DETECT then
	let ears.i->e in
	let (if d then -1 else 1) -> dir in
	if e.ear_broken==1 then
	(
#ifdef EARS_DEBUG
		_ears_debug strcatlist "ears_go " :: (itoa i) :: " broken !" :: nil;
#endif
		nil
	)
	else if p!=ears_target i then
	(
#ifdef EARS_DEBUG
		_ears_debug strcatlist "ears_go " :: (itoa i) :: " to " :: (itoa p) :: " dir " :: (itoa d) :: nil;
#endif
		set e.ear_target=_ears_check p;
		set e.ear_target_loop=_ears_loop_count p 0;
#ifdef EARS_DEBUG
		_ears_debug strcatlist "ear_target=" :: (itoa e.ear_target) :: " ear_target_loop=" :: (itoa e.ear_target_loop) :: nil;
#endif
		if e.ear_last_position==e.ear_target then
			if e.ear_target_loop==0 then
                _ears_motor_set_direction e 0 // on est arrivés
			else
			(
				if dir>0 then set e.ear_target_loop = e.ear_target_loop - 1
				else set e.ear_target_loop = e.ear_target_loop + 1;
				_ears_motor_set_direction e dir
			)
		else (
            if e.ear_target_loop<0 then
                set e.ear_target_loop=e.ear_target_loop+1; // sinon fait un tour de trop
            _ears_motor_set_direction e dir
		)
	);
	0;;

fun ears_go_to_ref_pos=
#ifdef EARS_DEBUG
	_ears_debug "ears_go_to_ref_pos";
#endif
	if (ears_target_position.EARS_LEFT != nil || ears_target_position.EARS_RIGHT != nil) then (
		ears_go EARS_LEFT ears_target_position.EARS_LEFT EARS_DIR_LEFT;
		ears_go EARS_RIGHT ears_target_position.EARS_RIGHT EARS_DIR_RIGHT;
		set ears_target_position.EARS_LEFT = nil;
        set ears_target_position.EARS_RIGHT = nil
	) else (
		ears_go EARS_LEFT 0 0;
		ears_go EARS_RIGHT 0 0
	);;

fun ears_ready=
    ears_mode!=EARS_MODE_RESET;;

fun ears_detecting=
    ears_mode==EARS_MODE_DETECT;;

fun ears_complete=
    ears_ready && (!ears.(0).ear_direction) && (!ears.(1).ear_direction);;

fun ears_json_ear ear=
    strcatlist
        "{\n"::
            (json_int "num" ear.ear_number) :: ",\n" ::
            (json_int "direction" ear.ear_direction) :: ",\n" ::
            (json_int "target" ear.ear_target) :: ",\n" ::
            (json_int "target_loop" ear.ear_target_loop) :: ",\n" ::
            (json_int "last_position" ear.ear_last_position) :: ",\n" ::
            (json_int "last_value" ear.ear_last_value) :: ",\n" ::
            (json_int "delay" ear.ear_delay) :: ",\n" ::
            (json_int "last_time" ear.ear_last_time) :: ",\n" ::
            (json_int "count" ear.ear_count) :: ",\n" ::
            (json_int "broken" ear.ear_broken) :: "\n" ::
        "}" :: nil;;

/**
 * Return ears status as JSON
 */
fun ears_json=
    strcatlist
        "{\n"::
            (json_int "mode" ears_mode) :: ",\n" ::
            (json_obj "left" ears_json_ear ears.EARS_LEFT) :: ",\n" ::
            (json_obj "right" ears_json_ear ears.EARS_RIGHT) :: "\n" ::
        "}" :: nil;;

// boucle pour faire tourner les oreilles vers leur targetobjectif
fun ears_run=
	if (_ears_initialized) then (
		if ears_mode==EARS_MODE_RESET then _ears_reset_run
		else if ears_mode==EARS_MODE_DETECT then _ears_detect_run
		else _ears_wait_run
	);
	0;;

/**
 * Ears task
 */
fun ears_task task=
    match run_get_state with
    ( configstartRun -> ears_run )|
    ( configwaitRun _ -> ears_run )|
#ifdef PING
    ( pingstartRun -> ears_run )|
    ( pingwaitRun _ -> ears_run )|
    ( stdWaitRun _ -> ears_run )|
#endif
#ifdef XMPP
    ( xmppLoginRun -> if (ears_resetting && ears_is_initialized) then ears_run else ears_stop 1 )|
    ( xmppReconnectRun params -> if (ears_resetting && ears_is_initialized) then ears_run else ears_stop 1)|
#endif
    ( idleRun -> ears_run )|
    ( sleepRun -> ears_run )|
    ( rscLoadNextRun -> ears_run )|
    ( rscLoadWaitRun http -> ears_run )|
    ( cmdEvalOne _ -> ears_run )|
    ( chorCmdRun _ -> ears_run )|
    ( streamCmdRun _-> ears_run )|
    ( waitCmdRun _ -> ears_run )|
    ( earResetWaitRun cb -> ears_run; if (!ears_resetting) then call cb []; nil )|
    ( interactiveReqWaitRun http -> ears_run );
    TaskRun;;

/**
 * Creates the tab to handle the ears and starts the ears task.
 */
fun ears_init=
	set ears = tabnew nil 2;
    set ears_target_position = tabnew nil 2;
	for i=0;i<2 do set ears.i = [ear_number:i];
    // Start the ears task
    task_start "ears" #ears_task;;
