/**
 * Control words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

const FORTH_IF_PLACEHOLDER = -1000;;
const FORTH_CASE_PLACEHOLDER = -1001;;
const FORTH_OF_PLACEHOLDER = -1002;;

/**
 * ABORT ( i * x -- ) ( R: j * x -- )
 * Empty the data stack and the return stack
 */
fun forth_abort f=
    set f.stack = nil;
    set f.rstack = nil;
    set f.pc = nil; // end execution
    nil;;

/**
 * Write a message and abort
 */
fun forth_abort_msg f msg=
    forth_write f strcatlist "\n" :: msg :: "\n" :: nil;
    forth_abort f;;

/**
 * EXIT ( -- )
 * Return control to the caller
 */
fun forth_exit f=
    set f.pc = nil; // end execution
    nil;;

/**
 * JMP ( addr -- )
 * Unconditional jump
 */
fun forth_jmp f=
    let forth_pop f -> addr in
    if addr.int != nil then set f.pc = addr.int; // jump to addr
    nil;;

/**
 * ?JMP ( cond addr -- )
 * Jump if zero
 */
fun forth_qjmp f=
    let forth_pop f -> addr in
    let forth_pop f -> cond in
    if (cond.int == 0) && (addr.int != nil) then set f.pc = addr.int; // if cond is false , jump to addr
    nil;;

/**
 * BEGIN (immediate)  ( -- )
 * Begin a loop
 * Store the current position in the return stack
 */
fun forth_begin f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "BEGIN Compile mode only"
    ) else (
        // Push the current position onto the return stack
        let listlen f.cstack -> current_pos in
        set f.rstack = [int:current_pos] :: f.rstack;
        nil
    );;

/**
 * UNTIL (immediate)  ( x -- )
 * End a loop
 * Compile a conditional jump back to the matching BEGIN
 */
fun forth_until f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "UNTIL Compile mode only"
    ) else (
        // Get the position of the matching BEGIN from the return stack
        let hd f.rstack -> loop_start in (
            if loop_start == nil then (
                forth_abort_msg f "UNTIL without matching BEGIN"
            ) else (
                // Remove the loop start from the return stack
                set f.rstack = tl f.rstack;
                // Compile a conditional jump back to the loop start
                set f.cstack = [func:#forth_qjmp] :: loop_start :: f.cstack;
                nil
            )
        )
    );;

/**
 * IF (immediate)  ( cond -- )
 * Begin a conditional
 * Compile a conditional jump to the matching ELSE or THEN
 */
fun forth_if f=
    // [ then_addr ?JMP ...(if true)... :then_addr ]
    // [ else_addr ?JMP ...(if true)... then_addr JMP :else_addr ...(if false)...  :then_addr ]
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "IF Compile mode only"
    ) else (
        // Push the current position onto the return stack
        let listlen f.cstack -> current_pos in
            set f.rstack = [int:current_pos+1] :: f.rstack;
        // Compile a placeholder for the conditional jump
        set f.cstack = [func:#forth_qjmp] :: [int:FORTH_IF_PLACEHOLDER] :: f.cstack;
        0
    );;

/**
 * ELSE (immediate)  ( -- )
 * Begin the else part of a conditional
 * Compile an unconditional jump to the matching THEN
 * Update the previous conditional jump to point to the instruction after the ELSE
 */
fun forth_else f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "ELSE Compile mode only"
    ) else (
        // Get the position of the ?JMP/JMP address from the return stack
        let hd f.rstack -> jmp_addr in
        let listlen f.cstack -> current_pos in
        let (listnth f.cstack (current_pos - jmp_addr.int)) -> jmp_addr_w in (
            // Check the else_pos of the else position
            if (jmp_addr == nil) || (jmp_addr_w.int != FORTH_IF_PLACEHOLDER) then (
                forth_abort_msg f "ELSE without matching IF"
            ) else (
                // Pop the address from the return stack
                set f.rstack = tl f.rstack;
                // Push the jump address position onto the return stack
                set f.rstack = [int:current_pos+1] :: f.rstack;
                // Compile an unconditional jump
                set f.cstack = [func:#forth_jmp] :: [int:FORTH_IF_PLACEHOLDER] :: f.cstack;
                // Update the placeholder for the conditional jump to point to the instruction after the JMP
                set jmp_addr_w.int = current_pos + 2;
                0
            )
        )
    );;

/**
 * THEN (immediate)  ( -- )
 * End a conditional
 * Update the previous conditional jump or unconditional jump to point to the instruction after THEN
 */
fun forth_then f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "THEN Compile mode only"
    ) else (
        // Get the position of the ?JMP/JMP address from the return stack
        let hd f.rstack -> jmp_addr in
        let listlen f.cstack -> current_pos in
        let (listnth f.cstack (current_pos - jmp_addr.int)) -> jmp_addr_w in (
            // Check the else_pos of the else position
            if (jmp_addr == nil) || (jmp_addr_w.int != FORTH_IF_PLACEHOLDER) then (
                forth_abort_msg f "THEN without matching IF"
            ) else (
                // Pop the address from the return stack
                set f.rstack = tl f.rstack;
                // Update the placeholder for the conditional jump to point to the instruction after the JMP
                set jmp_addr_w.int = current_pos;
                0
            )
        )
    );;

/**
 * CASE (immediate)  ( -- )
 * Begin a case statement
 */
fun forth_case f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "CASE Compile mode only"
    ) else (
        // Compile "-1001 >r >r"
        forth_cpush f [int:FORTH_CASE_PLACEHOLDER]; // placeholder for the jump address
        forth_rpush f [int:(listlen f.cstack)]; // push the placeholder position onto the return stack
        forth_cpush f [func:#forth_to_r str:">r"]; // push the placeholder to return stack
        forth_cpush f [func:#forth_to_r str:">r"]; // push the test value to return stack
        // forth_interpreter_ex ">r >r" f nil nil nil;
        // set f.istack = tl f.istack;
        nil
    );;

/**
 * OF (immediate)  ( value -- )
 * Begin a case option
 */
fun forth_of f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "OF Compile mode only"
    ) else (
        // Compile "r@ = -1002 ?jmp"
        forth_cpush f [func:#forth_r_fetch str:"r@"]; // fetch the case value
        forth_cpush f [func:#forth_eq str:"="]; // compare case value
        forth_cpush f [int:FORTH_OF_PLACEHOLDER]; // placeholder for the jump address
        forth_rpush f [int:(listlen f.cstack)]; // push the placeholder position onto the return stack
        forth_cpush f [func:#forth_qjmp str:"?jmp"]; // conditional jump if not zero
        nil
    );;

/**
 * ENDOF (immediate)  ( -- )
 * End a case option
 */
fun forth_endof f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "ENDOF Compile mode only"
    ) else (
        // Get the position of the ?JMP address from the return stack
        let hd f.rstack -> jmp_addr in
        let listlen f.cstack -> current_pos in
        let (listnth f.cstack (current_pos - jmp_addr.int)) -> jmp_addr_w in (
            // Check the position
            if jmp_addr_w.int != FORTH_OF_PLACEHOLDER then (
                forth_abort_msg f "ENDOF without matching OF"
            ) else (
                // Pop the address from the return stack
                set f.rstack = tl f.rstack;
                // Compile "r> r> swap >r jmp"
                forth_cpush f [func:#forth_r_from str:"r>"]; // retrieve the test value from return stack
                forth_cpush f [func:#forth_r_from str:"r>"]; // retrieve the return address from return stack
                forth_cpush f [func:#forth_swap str:"swap"]; // swap to have the test value on top
                forth_cpush f [func:#forth_to_r str:">r"]; // push the test value to return stack
                forth_cpush f [func:#forth_jmp str:"jmp"]; // jump to the address
                set jmp_addr_w.int = listlen f.cstack;  // update the placeholder for the conditional jump after endof
                0
            )
        )
    );;

/**
 * ENDCASE (immediate)  ( -- )
 * End a case statement
 */
fun forth_endcase f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "ENDCASE Compile mode only"
    ) else (
        // Pop the case address from the return stack
        let hd f.rstack -> case_start in
        let listlen f.cstack -> current_pos in
        let (listnth f.cstack (current_pos - case_start.int)) -> case_start_w in
            if case_start_w.int != FORTH_CASE_PLACEHOLDER then (
                forth_abort_msg f "ENDCASE without matching CASE"
            ) else (
                // Update the placeholder
                set case_start_w.int = current_pos;
                // Pop the address from the return stack
                set f.rstack = tl f.rstack;
                // Compile "rdrop"
                forth_cpush f [func:#forth_rdrop str:"rdrop"];
                0
            );
        nil
    );;
