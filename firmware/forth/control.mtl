/**
 * Control words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

/**
 * ABORT ( i * x -- ) ( R: j * x -- )
 * Empty the data stack and the return stack
 */
fun forth_abort f=
    set f.stack = nil;
    set f.rstack = nil;
    set f.pc = nil; // end execution
    nil;;

/**
 * Write a message and abort
 */
fun forth_abort_msg f msg=
    forth_write f strcatlist "\n" :: msg :: "\n" :: nil;
    forth_abort f;;

/**
 * EXIT ( -- )
 * Return control to the caller
 */
fun forth_exit f=
    set f.pc = nil; // end execution
    nil;;

/**
 * JMP ( addr -- )
 * Unconditional jump
 */
fun forth_jmp f=
    let forth_pop f -> addr in
    if addr.int != nil then set f.pc = addr.int; // jump to addr
    nil;;

/**
 * ?JMP ( cond addr -- )
 * Jump if zero
 */
fun forth_qjmp f=
    let forth_pop f -> addr in
    let forth_pop f -> cond in
    if (cond.int == 0) && (addr.int != nil) then set f.pc = addr.int; // if cond is false , jump to addr
    nil;;

/**
 * BEGIN (immediate)  ( -- )
 * Begin a loop
 * Store the current position in the return stack
 */
fun forth_begin f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "BEGIN Compile mode only"
    ) else (
        // Push the current position onto the return stack
        let listlen f.cstack -> current_pos in
        set f.rstack = [int:current_pos] :: f.rstack;
        nil
    );;

/**
 * UNTIL (immediate)  ( x -- )
 * End a loop
 * Compile a conditional jump back to the matching BEGIN
 */
fun forth_until f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "UNTIL Compile mode only"
    ) else (
        // Get the position of the matching BEGIN from the return stack
        let hd f.rstack -> loop_start in (
            if loop_start == nil then (
                forth_abort_msg f "UNTIL without matching BEGIN"
            ) else (
                // Remove the loop start from the return stack
                set f.rstack = tl f.rstack;
                // Compile a conditional jump back to the loop start
                set f.cstack = [func:#forth_qjmp] :: loop_start :: f.cstack;
                nil
            )
        )
    );;

/**
 * IF (immediate)  ( cond -- )
 * Begin a conditional
 * Compile a conditional jump to the matching ELSE or THEN
 */
fun forth_if f=
    // [ then_addr ?JMP ...(if true)... :then_addr ]
    // [ else_addr ?JMP ...(if true)... then_addr JMP :else_addr ...(if false)...  :then_addr ]
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "IF Compile mode only"
    ) else (
        // Push the current position onto the return stack
        let listlen f.cstack -> current_pos in
            set f.rstack = [int:current_pos+1] :: f.rstack;
        // Compile a placeholder for the conditional jump
        set f.cstack = [func:#forth_qjmp] :: [int:-1] :: f.cstack;
        0
    );;

/**
 * ELSE (immediate)  ( -- )
 * Begin the else part of a conditional
 * Compile an unconditional jump to the matching THEN
 * Update the previous conditional jump to point to the instruction after the ELSE
 */
fun forth_else f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "ELSE Compile mode only"
    ) else (
        // Get the position of the ?JMP/JMP address from the return stack
        let hd f.rstack -> jmp_addr in
        let listlen f.cstack -> current_pos in
        let (listnth f.cstack (current_pos - jmp_addr.int)) -> jmp_addr_w in (
            // Check the else_pos of the else position
            if (jmp_addr == nil) || (jmp_addr_w.int != -1) then (
                forth_abort_msg f "ELSE without matching IF"
            ) else (
                // Pop the address from the return stack
                set f.rstack = tl f.rstack;
                // Push the jump address position onto the return stack
                set f.rstack = [int:current_pos+1] :: f.rstack;
                // Compile an unconditional jump
                set f.cstack = [func:#forth_jmp] :: [int:-1] :: f.cstack;
                // Update the placeholder for the conditional jump to point to the instruction after the JMP
                set jmp_addr_w.int = current_pos + 2;
                0
            )
        )
    );;

/**
 * THEN (immediate)  ( -- )
 * End a conditional
 * Update the previous conditional jump or unconditional jump to point to the instruction after THEN
 */
fun forth_then f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "THEN Compile mode only"
    ) else (
        // Get the position of the ?JMP/JMP address from the return stack
        let hd f.rstack -> jmp_addr in
        let listlen f.cstack -> current_pos in
        let (listnth f.cstack (current_pos - jmp_addr.int)) -> jmp_addr_w in (
            // Check the else_pos of the else position
            if (jmp_addr == nil) || (jmp_addr_w.int != -1) then (
                forth_abort_msg f "THEN without matching IF"
            ) else (
                // Pop the address from the return stack
                set f.rstack = tl f.rstack;
                // Update the placeholder for the conditional jump to point to the instruction after the JMP
                set jmp_addr_w.int = current_pos;
                0
            )
        )
    );;
