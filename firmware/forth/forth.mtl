/**
 * Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

// https://forth-standard.org/
// https://www.forth.org/Ting/Forth-for-the-Complete-Idiot/Forth-79-Handy-Reference.pdf
// https://win32forth.sourceforge.net/doc/Guide/primer.htm

type Word=[
    name                // name of the defined word
    code                // array of Words if a colon
    func                // function if primitive
    int                 // data field - integer value for variables/constants
    str                 // data field - string value
    wstack              // data field - stack of Words
    flag                // immediate, async
];;

type Interpreter=[
    start               // current token start
    end                 // current token end
    end_ln              // next end of line position
    parentheses         // parentheses depth
    input               // input text
    text_len            // length of the input text
    token               // current token
    quoted              // true if the token is a quoted string
    inter_cb            // interpreter callback
];;

// The dictionary is a list of Words
var forth_dictionary;;

#include protos/forth_protos.mtl
#include forth/stack.mtl
#include forth/logical.mtl
#include forth/arithmetic.mtl
#include forth/comparison.mtl
#include forth/output.mtl
#include forth/wstack.mtl
#include forth/control.mtl
#include forth/misc.mtl
#include forth/nabaztag.mtl
#include forth/dictionary.mtl

fun forth_word_list_to_array words =
    let 0 -> i in
    let tabnew [name:"" func:nil] (listlen words) -> t in (
        for p=words; p!=nil; tl p do
        (
            set t.i=hd p;
            set i=i+1
        );
        t
    );;

fun forth_print_word w=
    if w.int != nil then (Iecholn w.int; 0)
    else if w.str != nil then (Secho w.str; Secholn " [str]"; 0)
    else (
    Secho w.name; Secho " [";
    if w.func!=nil then (Secho "func"; 0)
    else if w.code!=nil then (Secho "code"; 0)
    else (Secho "int "; Iecho w.int; 0);
    Secholn "]"; 0
    );;

fun forth_new_word token=
    if is_numeric token then
        [int:(atoi token)]
    else
        [str:token];;



// TODO recursive words

/**
 * Run a sequence of Words as code, managing the return stack for nested calls.
 * Return the word flag (FORTH_IMMEDIATE, FORTH_ASYNC) if set
 */
fun forth_execute_code f code=
    let 0 -> flag in (
        while (code != nil) && (f.pc != nil) && (f.pc < (tablen code)) && (flag != FORTH_ASYNC) do
            let code.(f.pc) -> word in (
                Secho "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
                set f.pc = f.pc + 1;
                set flag = word.flag;
                if word.flag == FORTH_ASYNC then (
                    // If asynchronous word, push current pc and code onto return stack
                    // and return after word execution
                    forth_rpush f [int:f.pc code:code]
                );

                if word.code != nil then ( // Colon-defined word
                    // Push current pc and code onto return stack
                    forth_rpush f [int:f.pc code:code];
                    set f.pc = 0;
                    set code = word.code;
                    nil
                )
                // Execute primitive function
                else if word.func != nil then call word.func [f]
                // Push the word onto the stack
                else forth_push f word;

                // Check if we need to return from the current word
                if (f.pc == nil) || (f.pc >= (tablen code)) then
                    // Pop return address from return stack
                    let forth_rpop f -> ret_addr in (
                        set code = ret_addr.code;
                        set f.pc = ret_addr.int
                    )

            );
        flag
    );;

/**
 * Extract the next token from the input text.
 * Tokens are separated by spaces or newlines.
 */
fun forth_get_token f=
    let f.inter -> i in (
        set i.end = strstr i.input " " i.start;
        set i.end_ln = strstr i.input "\n" i.start;
        if (i.end_ln != nil) && ((i.end == nil) || (i.end_ln < i.end)) then set i.end = i.end_ln;
        if i.end == nil then set i.end = i.text_len;
        // Skip leading spaces
        while (i.start < i.end) && ((strget i.input i.start) == FORTH_SPACE) do set i.start = i.start + 1;
        // Handle quoted strings
        if (strget i.input i.start) == FORTH_DOUBLE_QUOTE then (
            set i.start = i.start + 1; // skip opening quote
            set i.end = strstr i.input "\"" (i.start) + 1;
            set i.token = strsub i.input i.start (i.end-i.start);
            set i.start = i.end + 2; // skip closing quote and following space
            set i.quoted = 1
        ) else (
            set i.token = strsub i.input i.start (i.end-i.start);
            set i.start = i.end + 1;
            set i.quoted = 0
        );
        0
    );;

/**
 * Resume execution of a the Forth interpreter after an asynchronous word.
 * f: existing Forth interpreter state
 */
fun forth_interpreter_resume f=
    let 0 -> flag in (
        Secholn "forth_interpreter_resume";
        // First, check the return stack
        if f.rstack != nil then (
            Secholn "forth_interpreter_resume stack not empty";
            let forth_rpop f -> ret_addr in (
                set f.pc = ret_addr.int;
                set flag = forth_execute_code f ret_addr.code
            )
        );
        Secho "forth_interpreter_resume flag: "; Iecholn flag;
        if flag != FORTH_ASYNC then (
            // Then continue the main interpreter loop
            forth_interpreter_loop f
        )
    );;

/**
 * Initialize a new Forth interpreter state or reuse an existing one.
 * text: input Forth code as a string
 * f: existing Forth interpreter state or nil to create a new one
 * cb: callback function to call when execution completes
 */
fun _forth_interpreter_setup text f cb=
    if forth_dictionary==nil then forth_init_dictionary;
    let [start:0 end:0 end_ln:0 parentheses:0 input:text text_len:(strlen text) token:nil inter_cb:cb] -> i in
    if f == nil then (
        [
            stack:nil // data stack
            rstack:nil // return stack
            pc:0 // program counter
            inter:i // interpreter state
        ]
    ) else (
        set f.inter = i;
        f
    );;

// const FORTH_TEST = "5 2 + 10 * dup 1 + >";;
// const FORTH_TEST = ": bla 1 + exit 10 + ; 5 2 + bla exit 100 +";;
// const FORTH_TEST = "1 2 3 4 dup";;
// const FORTH_TEST = "9 8 7 1 2 over";;
// const FORTH_TEST = "9 8 7 1 2 1 pick";;
//const FORTH_TEST = "0 . cr : test dup >r 10 + r> * ; 10 test . cr";;
// const FORTH_TEST = "
// 0 . cr
// : sqrt dup * ;
// : test 1 + sqrt \"test: \" . ;
// 10 test . cr
// ";;
// const FORTH_TEST = "10 10 + .";;
// const FORTH_TEST = "
// : bla 1 + exit 10 + ;
// 5 2 + bla . space
// 1 . space 2 . space 3 . space 4 . ( test aa bb ) space 65 emit cr
// Spaghetti . cr
// nil 10 :: 20 :: 30 :: dup dup . space tl . space . cr
// \"ciao mondo\" . cr
// : test2 \"v: \" . dup . space if \"true\" . else \"false\" . then cr ;
// 0 test2
// 1 test2
// : test3 \"v: \" . dup . space if \"true\" . then cr ;
// 0 test3
// 1 test3
// ";;
// const FORTH_TEST = ": bla begin dup . 1 - dup 0 = until ; 5 bla \"ciao\" emit";;
const FORTH_TEST = "server-url :: \"/init.forth\" str-join http-get .";;

/**
 * Execute a single word.
 * Update the program counter and state as needed.
 * f: Forth interpreter state
 * word: Word to execute
 * Return the word flag (FORTH_IMMEDIATE, FORTH_ASYNC) if set
 */
fun forth_interpreter_execute_word f word=
    Secho "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
    set f.pc = f.pc + 1;
    // Execute a colon-defined word
    if word.code != nil then (
        // Push current pc and code onto return stack
        forth_rpush f [int:f.pc];
        set f.pc = 0;
        forth_execute_code f word.code
    )
    // Execute primitive function
    else if word.func != nil then (
        call word.func [f];
        word.flag
    )
    // Push the word onto the stack
    else (
        forth_push f word;
        word.flag
    );;

/**
 * Forth interpreter loop
 */
fun forth_interpreter_loop f=
    let 0 -> flags in (
        while (f.pc != nil) && (f.inter.end != f.inter.text_len) && (flags != FORTH_ASYNC) do (
            forth_get_token f;
            let if f.inter.quoted then nil else forth_get_word f.inter.token -> word in (
                if word == nil then set word = forth_new_word f.inter.token;
                // TODO \ comment to end of line

                if word.func == #forth_p then ( // open parentheses
                    set f.inter.parentheses = f.inter.parentheses + 1
                );

                if f.inter.parentheses > 0 then ( // inside parentheses - ignore tokens until closing parenthesis
                    if !strcmp f.inter.token ")" then set f.inter.parentheses = f.inter.parentheses - 1;
                    0
                ) else if (strlen f.inter.token) == 0 then ( // empty token, skip
                    0
                ) else if word.func == #forth_colon then ( // start of new word definition
                    if f.state == FORTH_STATE_COMPILATION then (
                        forth_abort_msg f "Error: Nested ':' not allowed"
                    ) else (
                        set f.state = FORTH_STATE_COMPILATION;
                        set f.new_word_name = nil;
                        set f.new_word_definition = nil;
                        0
                    )
                ) else if word.func == #forth_semi then ( // end of new word definition
                    if f.state != FORTH_STATE_COMPILATION then (
                        forth_abort_msg f "Error: ';' without matching ':'"
                    ) else if f.new_word_name == nil then (
                        forth_abort_msg f "Error: ';' without word name"
                    ) else (
                        // Finish the new word definition
                        let forth_word_list_to_array (rev f.new_word_definition nil) -> code in
                            set forth_dictionary = [ name:f.new_word_name code:code ]::forth_dictionary;
                            set f.new_word_name = nil;
                            set f.new_word_definition = nil;
                            set f.state = FORTH_STATE_NORMAL;
                            0
                    )

                ) else if f.state == FORTH_STATE_COMPILATION then (  // compilation state
                    if word.flag == FORTH_IMMEDIATE then (
                        // immediate word, execute now
                        set flags = forth_interpreter_execute_word f word

                    ) else (
                        // Secho "--> compiling "; Secho f.inter.token; Secholn "";
                        if f.new_word_name == nil then (
                            // first word after ":" is the new word's name
                            set f.new_word_name = f.inter.token;
                            0
                        ) else (
                            // add word to the latest defined word's code
                            set f.new_word_definition = word :: f.new_word_definition;
                            0
                        )
                    )

                ) else ( // normal state
                    set flags = forth_interpreter_execute_word f word
                )
            )
        );
        if (flags != FORTH_ASYNC) then
            call f.inter.inter_cb [f]
    );;

/**
 * Main entry point for the Forth interpreter.
 * text: input Forth code as a string
 * f: existing interpreter state or nil to create a new one
 * cb: callback function to call when execution completes
 */
fun forth_interpreter text f cb=
    if forth_dictionary == nil then forth_init_dictionary;
    let _forth_interpreter_setup text f cb -> f in
        forth_interpreter_loop f;;

/**
 * Handle HTTP callback for Forth interpreter. Return the output as JSON.
 */
fun _forth_http_cb f cb_args=
    Secholn "_forth_http_cb";
    let cb_args -> [cnx sock] in
    http_send_content_and_close cnx sock "application/json"
    strcatlist
        "{\n" ::
            (json_str "output" (strcatlist (rev f.output nil))) ::
        "\n}" ::
        nil;;

/**
 * Handle an HTTP POST request to execute Forth code.
 * cnx: TCP connection
 * sock: socket object for this connection
 * args: HTTP request arguments
 */
fun forth_http_post cnx sock args=
    let _http_arg_str args 'c' -> code in
    forth_interpreter code nil (fixarg2 #_forth_http_cb [cnx sock]);;

fun _forth_test_cb f cb_args=
    Secholn "_forth_test_cb";
    if f.output != nil then (
        Secholn "------------\nOutput:";
        Secholn strcatlist (rev f.output nil);
        Secholn "------------"
    );
    // Avoid compiler error
    let cb_args -> [cnx sock] in 0;;

fun forth_test=
    forth_interpreter FORTH_TEST nil (fixarg2 #_forth_test_cb [nil nil]);
    reboot 0x0407FE58 0x13fb6754;;
