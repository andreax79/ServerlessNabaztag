/**
 * Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

// https://forth-standard.org/
// https://www.forth.org/Ting/Forth-for-the-Complete-Idiot/Forth-79-Handy-Reference.pdf
// https://win32forth.sourceforge.net/doc/Guide/primer.htm

// #define FORTH_DEBUG

#ifdef FORTH_DEBUG
fun _forth_debug str= Secho strcatlist "[forth] " :: str :: nil; nil;;
#endif

type Interpreter=[
    start               // current token start
    end                 // current token end
    end_ln              // next end of line position
    parentheses         // parentheses depth
    input               // input text
    text_len            // length of the input text
    token               // current token
    quoted              // true if the token is a quoted string
    inter_cb            // interpreter callback
];;

// The dictionary is a list of Words
var forth_dictionary = nil;; // list of [Word Word] tuples (the first Word is the key, the second is the value)
var forth_memory = nil;; // list of allocated memory blocks

#include protos/ascii_protos.mtl
#include protos/forth_protos.mtl
#include forth/stack.mtl
#include forth/logical.mtl
#include forth/arithmetic.mtl
#include forth/comparison.mtl
#include forth/output.mtl
#include forth/list.mtl
#include forth/json.mtl
#include forth/control.mtl
#include forth/misc.mtl
#include forth/net.mtl
#include forth/config.mtl
#include forth/nabaztag.mtl
#include forth/interpreter.mtl
#include forth/memory.mtl
#include forth/task.mtl
#include forth/dictionary.mtl

fun forth_word_list_to_array words =
    let 0 -> i in
    let tabnew [func:nil] (listlen words) -> t in (
        for p=words; p!=nil; tl p do
        (
            set t.i=hd p;
            set i=i+1
        );
        t
    );;

#ifdef FORTH_DEBUG
fun forth_print_word w=
    if w.int != nil then (Iecholn w.int; 0)
    else if w.str != nil then (Secho w.str; Secholn " [str]"; 0)
    else (
    Secho w.name; Secho " [";
    if w.func!=nil then (Secho "func"; 0)
    else if w.code!=nil then (Secho "code"; 0)
    else (Secho "int "; Iecho w.int; 0);
    Secholn "]"; 0
    );;
#endif

/**
 * Compare two Words.
 * Returns 0 if equal, -1 if w1 < w2, 1 if w1 > w2, nil if not comparable.
 */
fun forth_compare_words w1 w2=
    // TODO compare other types
    if w1.int != nil && w2.int != nil then
        if w1.int == w2.int then 0 // equal
        else if w1.int < w2.int then -1  // w1 less than w2
        else 1 // w1 greater than w2
    else if w1.str != nil && w2.str != nil then
        str_compare w1.str w2.str
    else
        nil;;

/**
 * Run a sequence of Words as code, managing the return stack for nested calls.
 * Return the word flag (FORTH_IMMEDIATE, FORTH_ASYNC) if set
 */
fun forth_execute_code f code=
    let 0 -> flag in (
        while (code != nil) && (f.pc != nil) && (f.pc < (tablen code)) && (flag != FORTH_ASYNC) do
            let code.(f.pc) -> word in (
#ifdef FORTH_DEBUG
                _forth_debug "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
#endif
                set f.pc = f.pc + 1;
                set flag = word.flag;

                // Execute a colon-defined word
                if word.code != nil then (
                    // Push current pc and code onto return stack
                    forth_rpush f [int:f.pc code:code];
                    set f.pc = 0;
                    set code = word.code;
                    nil
                )
                // Execute primitive function
                else if word.func != nil then (
                    if word.flag == FORTH_ASYNC then (
                        // If asynchronous word, push current pc and code onto return stack
                        // and return after word execution
                        forth_rpush f [int:f.pc code:code]
                    );
                    call word.func [f]
                )
                // Push the word onto the stack
                else (
                    forth_push f word
                );

                // Check if we need to return from the current word
                if (f.pc == nil) || (f.pc >= (tablen code)) then
                    // Pop return address from return stack
                    let forth_rpop f -> ret_addr in (
                        set code = ret_addr.code;
                        set f.pc = ret_addr.int
                    )

            );
        flag
    );;

/**
 * Forth interpreter hook for connection established.
 * Set the run state to idleRun and execute the on-connet word.
 */
fun _forth_init_cb _=
    run_set_state idleRun;
    forth_interpreter WORD_ON_CONNECT;
    0;;

/**
 * Initialize the Forth interpreter by loading the init.forth script from the server.
 * Set the run state to configwaitRun while fetching init.forth
 */
fun forth_init=
    if forth_dictionary==nil then forth_init_dictionary;
    let strcat config_get_server_url "/init.forth" -> url in
        run_set_state configwaitRun forth_load url #_forth_init_cb;;

// const FORTH_TEST = "5 2 + 10 * dup 1 + >";;
// const FORTH_TEST = ": bla 1 + exit 10 + ; 5 2 + bla exit 100 +";;
// const FORTH_TEST = "1 2 3 4 dup";;
// const FORTH_TEST = "9 8 7 1 2 over";;
// const FORTH_TEST = "9 8 7 1 2 1 pick";;
//const FORTH_TEST = "0 . cr : test dup >r 10 + r> * ; 10 test . cr";;
// const FORTH_TEST = "
// 0 . cr
// : sqrt dup * ;
// : test 1 + sqrt \"test: \" . ;
// 10 test . cr
// ";;
// const FORTH_TEST = "10 10 + .";;
// const FORTH_TEST = "
// : bla 1 + exit 10 + ;
// 5 2 + bla . space
// 1 . space 2 . space 3 . space 4 . ( test aa bb ) space 65 emit cr
// Spaghetti . cr
// nil 10 :: 20 :: 30 :: dup dup . space tl . space . cr
// \"ciao mondo\" . cr
// : test2 \"v: \" . dup . space if \"true\" . else \"false\" . then cr ;
// 0 test2
// 1 test2
// : test3 \"v: \" . dup . space if \"true\" . then cr ;
// 0 test3
// 1 test3
// ";;
// const FORTH_TEST = ": bla begin dup . 1 - dup 0 = until ; 5 bla \"ciao\" emit";;
// const FORTH_TEST = "server-url :: \"/init.forth\" str-join http-get .";;
//
// fun _forth_test_cb f cb_args=
//     Secholn "_forth_test_cb";
//     if f.output != nil then (
//         Secholn "------------\nOutput:";
//         Secholn strcatlist (rev f.output nil);
//         Secholn "------------"
//     );
//     // Avoid compiler error
//     let cb_args -> [cnx sock] in 0;;
//
// fun forth_test=
//     forth_interpreter_ex FORTH_TEST nil nil (fixarg2 #_forth_test_cb [nil nil]);
//     reboot 0x0407FE58 0x13fb6754;;
