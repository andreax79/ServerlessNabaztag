/**
 * Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

const FORTH_STRING_BUFFER_SIZE = 16;;

/**
 * Create a new word for a token not found in the dictionary.
 * If the token is numeric, create an integer word.
 * Otherwise, create a string word.
 */
fun forth_interpreter_new_word token quoted=
    if quoted then
        [str:token]
    else
        forth_str_to_int nil token;;

/**
 * Process a quoted string token, handles escape sequences.
 */
fun _forth_process_quoted_string i=
    set i.end = nil;
    let FORTH_STRING_BUFFER_SIZE -> buffer_len in
    let 0 -> token_len in
    let strnew FORTH_STRING_BUFFER_SIZE -> buffer in (
        set i.start = i.start + 1; // skip opening quote

        for p=i.start; (p<i.text_len)&&(i.end==nil); p+1 do (
            let strget i.input p -> ch in
            if ch == ASCII_DOUBLE_QUOTE then (
                // Closing quote found
                set i.end = p
            ) else if ch == ASCII_BACKSLASH then (  // Escape sequence
                // Grow buffer if needed
                if buffer_len <= (token_len + 1) then (
                    set buffer = strcat buffer strnew FORTH_STRING_BUFFER_SIZE;
                    set buffer_len = buffer_len + FORTH_STRING_BUFFER_SIZE
                );
                let strget i.input (p+1) -> next_ch in
                if next_ch == ASCII_DOUBLE_QUOTE then ( // Escaped double quote \"
                    strset buffer token_len ASCII_DOUBLE_QUOTE;
                    set p = p + 1
                ) else if next_ch == ASCII_BACKSLASH then ( // Escaped backslash \\
                    strset buffer token_len ASCII_BACKSLASH;
                    set p = p + 1
                ) else if next_ch == ASCII_N then ( // Newline \n
                    strset buffer token_len ASCII_NEWLINE;
                    set p = p + 1
                ) else if next_ch == ASCII_T then ( // Tab \t
                    strset buffer token_len ASCII_TAB;
                    set p = p + 1
                ) else if (next_ch == ASCII_X) || (next_ch == ASCII_DOLLAR) then (
                    // Hexadecimal escape sequence \xNN
                    let strget i.input (p+2) -> hex1 in
                    let strget i.input (p+3) -> hex2 in
                    let (hex_to_int hex1) * 16 + (hex_to_int hex2) -> hex_val in
                    strset buffer token_len hex_val;
                    set p = p + 3
                ) else if (next_ch >= ASCII_0) && (next_ch <= ASCII_7) then (
                    // Octal escape sequence \NNN
                    let strget i.input (p+1) -> oct1 in
                    let strget i.input (p+2) -> oct2 in
                    let strget i.input (p+3) -> oct3 in
                    let (oct_to_int oct1) * 64 + (oct_to_int oct2) * 8 + (oct_to_int oct3) -> oct_val in
                    strset buffer token_len oct_val;
                    set p = p + 3
                ) else if next_ch == ASCII_NEWLINE then ( // Escaped newline \ (line continuation)
                    // skip both characters
                    set p = p + 1;
                    set token_len = token_len - 1
                ) else (
                    strset buffer token_len ASCII_BACKSLASH;  // keep the backslash
                    nil
                );
                set token_len = token_len + 1
            ) else (  // Regular character
                // Grow buffer if needed
                if buffer_len <= (token_len + 1) then (
                    set buffer = strcat buffer strnew FORTH_STRING_BUFFER_SIZE;
                    set buffer_len = buffer_len + FORTH_STRING_BUFFER_SIZE
                );
                strset buffer token_len ch;
                set token_len = token_len + 1
            )
        );
        if i.end == nil then set i.end = i.text_len; // if not found, go to end of text
        set i.token = strsub buffer 0 token_len;
        set i.start = i.end + 2; // skip closing quote and following space
        set i.quoted = 1
    )
    ;;

/**
 * Extract the next token from the input text.
 * Tokens are separated by spaces or newlines.
 * Quoted strings are handled as single tokens.
 * Comments starting with parentheses are ignored until the matching closing parenthesis.
 * Comments starting with backslash are ignored until end of line.
 */
fun forth_interpreter_get_token f=
    let hd f.istack -> i in (
        set i.end = strstr i.input " " i.start;
        set i.end_ln = strstr i.input "\n" i.start;
        if (i.end_ln != nil) && ((i.end == nil) || (i.end_ln < i.end)) then set i.end = i.end_ln;
        if i.end == nil then set i.end = i.text_len;
        // Skip leading spaces
        while (i.start < i.end) && ((strget i.input i.start) == ASCII_SPACE) do set i.start = i.start + 1;
        let strget i.input i.start -> ch in
        if ch == ASCII_DOUBLE_QUOTE then ( // Handle quoted strings
            _forth_process_quoted_string i
        ) else if ch == ASCII_BACKSLASH then ( // Comment - skip to end of line
            set i.end = if i.end_ln != nil then i.end_ln else i.text_len;
            set i.start = i.end + 1;
            set i.token = "";
            set i.quoted = 0
        ) else (
            set i.token = strsub i.input i.start (i.end-i.start);
            set i.start = i.end + 1;
            set i.quoted = 0
        );
        0
    );;

/**
 * Resume execution of a the Forth interpreter after an asynchronous word.
 * f: existing Forth interpreter state
 */
fun forth_interpreter_resume f=
    let 0 -> flag in (
        // First, check the return stack
        if f.rstack != nil then (
            let forth_rpop f -> ret_addr in (
                // Restore pc
                set f.pc = ret_addr.int;
                // Execute code at the return address
                // code is nil if we are resuming to interpreted mode
                if ret_addr.code != nil then
                    set flag = forth_execute_code f ret_addr.code
            )
        );
        // Secho "forth_interpreter_resume flag: "; Iecholn flag;
        if flag != FORTH_ASYNC then (
            // Then continue the main interpreter loop
            forth_interpreter_loop f
        )
    );;

/**
 * Initialize a new Forth interpreter state or reuse an existing one.
 * text: input Forth code as a string
 * f: existing Forth interpreter state or nil to create a new one
 * sock: socket
 * task: task associated with this interpreter
 * cb: callback function to call when execution completes
 */
fun forth_interpreter_setup text f sock task cb=
    if forth_dictionary==nil then forth_init_dictionary;
    let [
        start:0
        end:0
        end_ln:0
        parentheses:0
        input:text
        text_len:(strlen text)
        token:nil
        inter_cb:cb
    ] -> inter in
    if f == nil then (
        // Secho "Creating new Forth interpreter\n";
        // Secholn if sock != nil then "with socket" else "without socket";
        [
            stack:nil // data stack
            rstack:nil // return stack
            pc:0 // program counter
            state:FORTH_STATE_NORMAL // normal (not compilation) state
            forth_sock: sock // socket
            forth_task: task // task
            istack: inter :: nil // interpreter state
        ]
    ) else (
        set f.istack = inter :: f.istack;
        f
    );;

/**
 * Execute a single word during interpreted mode.
 * Update the program counter and state as needed.
 * f: Forth interpreter state
 * word: Word to execute
 * Return the word flag (FORTH_IMMEDIATE, FORTH_ASYNC) if set
 */
fun forth_interpreter_execute_word f word=
#ifdef FORTH_DEBUG
    _forth_debug "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
#endif
    set f.pc = f.pc + 1;
    // Execute a colon-defined word
    if word.code != nil then (
        // Push current pc onto return stack.
        // Code is nil because we are in interpreted mode.
        forth_rpush f [int:f.pc code:nil];
        set f.pc = 0;
        forth_execute_code f word.code
    )
    // Execute primitive function
    else if word.func != nil then (
        if word.flag == FORTH_ASYNC then (
            // If asynchronous word, push current pc onto return stack
            // and return after word execution
            forth_rpush f [int:f.pc code:nil]
        );
        call word.func [f];
        word.flag
    )
    // Push the word onto the stack
    else (
        forth_push f word;
        word.flag
    );;

/**
 * Forth interpreter loop
 */
fun forth_interpreter_loop f=
    let 0 -> flags in
    let hd f.istack -> inter in (
#ifdef FORTH_DEBUG
        _forth_debug "Entering interpreter loop\n";
#endif
        while (f.pc != nil) && (inter.end != inter.text_len) && (flags != FORTH_ASYNC) do (
            forth_interpreter_get_token f;
            if (strlen inter.token) > 0 || inter.quoted then // skip empty tokens unless quoted
            let if inter.quoted then nil else forth_get_word inter.token -> word in ( // get the word from the dictionary if not quoted
                // Secho "Token: '"; Secho inter.token; Secholn "'";
                // Iecho inter.end; Secho " / "; Iecholn inter.text_len;
                if word == nil then set word = forth_interpreter_new_word inter.token inter.quoted;

                if word.func == #forth_p then ( // open parentheses
                    set inter.parentheses = inter.parentheses + 1
                );

                if inter.parentheses > 0 then ( // inside parentheses - ignore tokens until closing parenthesis
                    if !strcmp inter.token ")" then set inter.parentheses = inter.parentheses - 1;
                    0
                ) else if f.state == FORTH_STATE_COMPILATION then (  // compilation state
                    if word.flag == FORTH_IMMEDIATE then (
                        // immediate word, execute now
                        set flags = forth_interpreter_execute_word f word

                    ) else (
                        // add word to the control stack
                        // Secho "--> compiling "; Secho inter.token; Secholn "";
                        set f.cstack = word :: f.cstack;
                        0
                    )

                ) else ( // normal state
                    set flags = forth_interpreter_execute_word f word
                )
            )
        );
#ifdef FORTH_DEBUG
        _forth_debug "Exiting interpreter loop\n";
#endif
        if (flags != FORTH_ASYNC) then (
            call inter.inter_cb [f]
        )
    );;

/**
 * Main entry point for the Forth interpreter.
 * text: input Forth code as a string
 * f: existing interpreter state or nil to create a new one
 * sock: socket
 * task: task associated with this interpreter
 * cb: callback function to call when execution completes
 */
fun forth_interpreter_ex text f sock task cb=
    if forth_dictionary==nil then forth_init_dictionary;
    let forth_interpreter_setup text f sock task cb -> f in
        forth_interpreter_loop f;;

/**
 * Simple Forth interpreter entry point without socket or callback.
 * text: input Forth code as a string
 */
fun forth_interpreter text=
    forth_interpreter_ex text nil nil nil nil;;
