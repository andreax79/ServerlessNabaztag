/**
 * Misc words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

/**
 * : Begin a new word definition
 */
fun forth_colon f=
    if f.state == FORTH_STATE_COMPILATION then (
        forth_abort_msg f ": Nested definitions not allowed"
    ) else (
        // Enter compilation state
        set f.state = FORTH_STATE_COMPILATION;
        set f.new_word_name = nil;
        set f.new_word_definition = nil;
        nil
    );;

/**
 * ; End a word definition
 */
fun forth_semi f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "; Compile mode only"
    ) else (
        set f.state = FORTH_STATE_NORMAL;
        let forth_word_list_to_array (rev f.new_word_definition nil) -> code in
        set forth_dictionary=[ name:f.new_word_name code:code ]::forth_dictionary;
        set f.new_word_name = nil;
        set f.new_word_definition = nil;
        nil
    );;

fun forth_p f=
    nil;;

/**
 * Helper function to print words in the dictionary
 */
fun _forth_print_words f forth_dictionary=
    if forth_dictionary==nil then nil
    else let hd forth_dictionary -> head in (
        forth_write f strcat " " head.name;
        _forth_print_words f (tl forth_dictionary)
    );;

/**
 * WORDS ( -- )
 * List the words in the dictionary
 */
fun forth_words f=
    _forth_print_words f forth_dictionary;
    forth_write f " \n";
    nil;;

/**
 * TIME&DATE ( -- sec min hour day month year)
 * Push the current time and date onto the stack
 */
fun forth_time_and_date f=
    let time_local -> [local_time_year local_time_month local_time_day local_time_hour local_time_minute local_time_second days_since_epoc] in (
        forth_push f [int:local_time_second];
        forth_push f [int:local_time_minute];
        forth_push f [int:local_time_hour];
        forth_push f [int:local_time_day];
        forth_push f [int:local_time_month];
        forth_push f [int:local_time_year];
        nil
    );;

/**
 * Callback function to resume interpreter after EVALUATE
 * Restore the previous interpreter state
 */
fun _forth_evaluate_cb f inter=
    set f.inter = inter; // restore interpreter state
    forth_interpreter_resume f;;

/**
 * EVALUATE ( str -- )
 * Evaluate a string as Forth code
 */
fun forth_evaluate f=
    let forth_pop f -> word in
    if word.str == nil then (
        forth_push f word;
        forth_interpreter_resume f
        // forth_abort_msg f "EVALUATE expects a string"
    ) else (
        forth_interpreter word.str f f.forth_sock (fixarg2 #_forth_evaluate_cb f.inter)
    );;
