/**
 * Misc words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

/**
 * : Begin a new word definition
 */
fun forth_colon f=
    if f.state == FORTH_STATE_COMPILATION then (
        forth_abort_msg f ": Nested definitions not allowed"
    ) else (
        // Enter compilation state
        set f.state = FORTH_STATE_COMPILATION;
        // Get the new word name
        forth_get_token f;
        if !strcmp f.inter.token ";" then
            forth_abort_msg f "Error: ';' without word name"
        else
            let forth_get_word f.inter.token -> new_word in (
                if new_word == nil then (
                    // Secho "Creating new word "; Secholn f.inter.token;
                    set new_word = [name:to_lower f.inter.token code:nil];
                    set forth_dictionary = new_word :: forth_dictionary;
                    forth_rpush f new_word
                );
                set f.cstack = nil;
            nil
        )
    );;

/**
 * ; End a word definition
 */
fun forth_semi f=
    if f.state != FORTH_STATE_COMPILATION then (
        forth_abort_msg f "Error: ';' without matching ':'"
    ) else
        let forth_rpop f -> new_word in (
            // Finish the new word definition
            set new_word.code = forth_word_list_to_array (rev f.cstack nil);
            set f.cstack = nil;
            set f.state = FORTH_STATE_NORMAL;
            nil
        );;

fun forth_p f=
    nil;;

/**
 * Helper function to print words in the dictionary
 */
fun _forth_print_words f forth_dictionary=
    if forth_dictionary==nil then nil
    else let hd forth_dictionary -> head in (
        forth_write f strcat " " head.name;
        _forth_print_words f (tl forth_dictionary)
    );;

/**
 * CONSTANT (immediate) ( x "<spaces>name" -- )
 * Define a constant with the given name and value
 */
fun forth_constant f=
    // Get the new word name
    forth_get_token f;
    let forth_pop f -> x in
    let forth_get_word f.inter.token -> new_word in
        if new_word == nil then (
            set new_word = [name:to_lower f.inter.token code:{x}];
            set forth_dictionary = new_word :: forth_dictionary;
            nil
        )
        else
        (
            set new_word.code = {x};
            nil
        );;

/**
 * WORDS ( -- )
 * List the words in the dictionary
 */
fun forth_words f=
    _forth_print_words f forth_dictionary;
    forth_write f " \n";
    nil;;

/**
 * TIME&DATE ( -- sec min hour day month year)
 * Push the current time and date onto the stack
 */
fun forth_time_and_date f=
    let time_local -> [local_time_year local_time_month local_time_day local_time_hour local_time_minute local_time_second days_since_epoc] in (
        forth_push f [int:local_time_second];
        forth_push f [int:local_time_minute];
        forth_push f [int:local_time_hour];
        forth_push f [int:local_time_day];
        forth_push f [int:local_time_month];
        forth_push f [int:local_time_year];
        nil
    );;

/**
 * Callback function to resume interpreter after EVALUATE
 * Restore the previous interpreter state
 */
fun _forth_evaluate_cb f inter=
    set f.inter = inter; // restore interpreter state
    forth_interpreter_resume f;;

/**
 * EVALUATE ( str -- )
 * Evaluate a string as Forth code
 */
fun forth_evaluate f=
    let forth_pop f -> word in
    if word.str == nil then (
        forth_push f word;
        forth_interpreter_resume f
        // forth_abort_msg f "EVALUATE expects a string"
    ) else (
        forth_interpreter word.str f f.forth_sock (fixarg2 #_forth_evaluate_cb f.inter)
    );;

/**
 * TIME-MS ( -- ms )
 * Push the current time in milliseconds onto the stack
 */
fun forth_time_ms f=
    let time_ms -> ms in
    forth_push f [int:ms];
    nil;;
