/**
 * Nabaztag words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

/**
 * SLEEPING? ( -- flag)
 * Return true if the Nabaztag is in sleep mode
 */
fun forth_sleeping f=
    forth_push f [int:if sleep_is_sleeping then FORTH_TRUE else FORTH_FALSE];;

/**
 * SLEEP ( -- )
 * Put the Nabaztag into sleep mode
 */
fun forth_sleep f=
    sleep_start f;
    nil;;

/**
 * WAKE-UP ( -- )
 * Wake up the Nabaztag from sleep mode
 */
fun forth_wake_up f=
    sleep_wake_up f;
    nil;;

/**
 * LEFT-EAR-POSITION ( -- pos )
 * Return the current position of the left ear
 */
fun forth_left_ear_position f=
    forth_push f [int:ears_target_position.EARS_LEFT];;

/**
 * MOVE-LEFT-EAR ( dir pos -- )
 * Move the left ear in direction dir (0=left, 1=right) to position pos (0..16)
 */
fun forth_move_left_ear f=
    let forth_pop f -> pos in
    let forth_pop f -> dir in
    ears_go EARS_LEFT dir.int pos.int;
    nil;;

/**
 * RIGHT-EAR-POSITION ( -- pos )
 * Return the current position of the right ear
 */
fun forth_right_ear_position f=
    forth_push f [int:ears_target_position.EARS_RIGHT];;

/**
 * MOVE-RIGHT-EAR ( dir pos -- )
 * Move the left ear in direction dir (0=left, 1=right) to position pos (0..16)
 */
fun forth_move_right_ear f=
    let forth_pop f -> pos in
    let forth_pop f -> dir in
    ears_go EARS_RIGHT dir.int pos.int;
    nil;;

/**
 * RANDOM ( max -- n )
 * Return a pseudo-random number n between 0 and max-1
 */
fun forth_random f=
    let forth_pop f -> max in
    let random (if max.int > 0 then max.int else 0) -> n in
    forth_push f [int:n];;

/**
 * VOLUME ( -- vol )
 * Get the audio volume
 */
fun forth_volume f=
    forth_push f [int:audiolib_volume];;

/**
 * CLEAR-INFO ( -- )
 * Clear all information
 */
fun forth_clear_info f=
    for i=1;i<=8 do (
        info_src_update 0 i
    );
    nil;;

/**
 * PLAY-URL ( url -- )
 * Play a WAV file from an HTTP URL
 * HTTPS is not supported
 */
fun forth_play_url f=
    let forth_pop f -> url in
    audiolib_start_http url.str #streaming_wav_error;
    nil;;

/**
 * PLAY-MIDI ( i -- )
 * Play a MIDI sound/note
 * If i>=100, play note (i-100)
 * If 0<=i<100, play sound i
 * If i<0, play a random note
 */
fun forth_play_midi f=
    let forth_pop f -> i in
    if i.int>=100 then
        midi_play_note (i.int-100)
    else if i.int>=0 then
        midi_play i.int
    else
        midi_play_random_note;;

/**
 * PLAY-CHOR ( chor_data -- )
 * Play a choreography
 */
fun forth_play_chor f=
    let forth_pop f -> chor in
    let fixarg1 #forth_interpreter_resume f -> cb in
    chor_start chor.str cb nil;
    nil;;

/**
 * EVAL-TRAME ( str -- )
 * Evaluate a trame
 */
fun forth_eval_trame f=
    let forth_pop f -> t in
    trame_eval t.str;
    nil;;

/**
 * GC ( -- mem% )
 * Perform garbage collection and return the memory usage percentage
 */
fun forth_gc f=
    let gc -> mem in
        forth_push f [int:mem];
    nil;;

/**
 * REVISION ( -- str )
 * Push the revision string onto the stack
 */
fun forth_revision f=
    forth_push f [str:BYTECODE_REVISION_STR];;
