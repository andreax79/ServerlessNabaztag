/**
 * Stack manipulation words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

/**
 * Push a value onto the stack
 */
fun forth_push f x=
    set f.stack = x :: f.stack;
    nil;;

/**
 * Pop a value from the stack
 */
fun forth_pop f=
    if f.stack==nil then nil
    else let hd f.stack -> head in (
        set f.stack = tl f.stack;
        head
    );;

/**
 * Get an element from the stack at a given position without removing it
 */
fun forth_stack_at f i=
    listnth f.stack i;;
    // if !i then hd f.stack else if i>0 then forth_stack_at tl f (i-1);;

/**
 * Push a value onto the return stack
 */
fun forth_rpush f x=
    set f.rstack = x :: f.rstack;
    nil;;

/**
 * Pop a value from the return stack
 */
fun forth_rpop f=
    if f.rstack==nil then nil
    else let hd f.rstack -> head in (
        set f.rstack = tl f.rstack;
        head
    );;

/**
 * DUP ( n -- n n ) Duplicate top of stack
 */
fun forth_dup f=
    if f.stack==nil then nil
    else
        let hd f.stack -> head in
        set f.stack = head :: f.stack;
    nil;;

/**
 * DROP ( n --  ) Discard top of stack
 */
fun forth_drop f=
    let forth_pop f -> a in
    nil;;

/**
 * SWAP ( n1 n2 -- n2 n1 ) Exchange top two stack items
 */
fun forth_swap f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = b :: a :: f.stack;
    nil;;

/**
 * OVER ( n1 n2 -- n1 n2 n1 ) Make copy of second item on top
 */
fun forth_over f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = b :: a :: b :: f.stack;
    nil;;

/**
 * ROT ( n1 n2 n3 -- n2 n3 n1 ) Rotate third item to top
 */
fun forth_rot f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    let forth_pop f -> c in
    set f.stack = b :: a :: c :: f.stack;
    nil;;

/**
 * PICK ( n ... ni - n ... ni ni ) Copy nth item to top of stack
 */
fun forth_pick f=
    let forth_pop f -> n in
    let forth_stack_at f n.int -> v in
    forth_push f v;;

// fun forth_roll f= // TODO

/**
 * NIP ( n1 n2 -- n2 ) Drop the first item below the top of stack
 */
fun forth_nip f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = a :: f.stack;
    nil;;

/**
 * TUCK ( n1 n2 -- n1 n2 n1 ) Copy the first (top) stack item below the second stack item
 */
fun forth_tuck f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = b :: a :: b :: f.stack;
    nil;;

/**
 * ?DUP ( x -- 0 | x x ) Duplicate top of stack if not zero
 */
fun forth_qdup f=
    if f.stack==nil then nil
    else
        let hd f.stack -> v in
        if v.int!=0 then forth_push f v;;

/**
 * >R ( x -- ) ( R: -- x ) Move top item to ‘return stack” for temporary storage
 */
fun forth_to_r f=
    if f.stack==nil then nil
    else forth_rpush f (forth_pop f);;

/**
 * R> ( -- x ) ( R: x -- ) Retrieve item from return stack
 */
fun forth_r_from f=
    if f.rstack==nil then nil
    else forth_push f (forth_rpop f);;

/**
 * R@ ( -- x ) ( R: x -- x ) Copy top of return stack onto data stack
 */
fun forth_r_fetch f=
    if f.rstack==nil then nil
    else
        let hd f.rstack -> head in
        set f.stack = head :: f.stack;
    nil;;

/**
 * DEPTH ( -- count ) Count number of items on stack
 */
fun forth_depth f=
    let listlen f.stack -> l in
    forth_push f [int:l];;

