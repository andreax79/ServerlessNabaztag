/**
 * Stack manipulation words for Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

/**
 * Push a value onto the stack
 */
fun forth_push f x=
    set f.stack = x :: f.stack;
    nil;;

/**
 * Pop a value from the stack
 */
fun forth_pop f=
    if f.stack==nil then nil
    else let hd f.stack -> head in (
        set f.stack = tl f.stack;
        head
    );;

/**
 * Get an element from the stack at a given position without removing it
 */
fun forth_stack_at f i=
    listnth f.stack i;;

/**
 * Push a value onto the return stack
 */
fun forth_rpush f x=
    set f.rstack = x :: f.rstack;
    nil;;

/**
 * Pop a value from the return stack
 */
fun forth_rpop f=
    if f.rstack==nil then nil
    else let hd f.rstack -> head in (
        set f.rstack = tl f.rstack;
        head
    );;

/**
 * Push a value onto the compiler stack
 */
fun forth_cpush f x=
    set f.cstack = x :: f.cstack;
    nil;;

/**
 * Pop a value from the compiler stack
 */
fun forth_cpop f=
    if f.cstack==nil then nil
    else let hd f.cstack -> head in (
        set f.cstack = tl f.cstack;
        head
    );;

/**
 * DUP ( n -- n n )
 * Duplicate top of stack
 */
fun forth_dup f=
    if f.stack==nil then nil
    else
        let hd f.stack -> head in
        set f.stack = head :: f.stack;
    nil;;

/**
 * DROP ( n --  )
 * Discard top of stack
 */
fun forth_drop f=
    set f.stack = tl f.stack;
    nil;;

/**
 * SWAP ( n1 n2 -- n2 n1 )
 * Exchange top two stack items
 */
fun forth_swap f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = b :: a :: f.stack;
    nil;;

/**
 * OVER ( n1 n2 -- n1 n2 n1 )
 * Make copy of second item on top
 */
fun forth_over f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = b :: a :: b :: f.stack;
    nil;;

/**
 * ROT ( n1 n2 n3 -- n2 n3 n1 )
 * Rotate third item to top
 */
fun forth_rot f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    let forth_pop f -> c in
    set f.stack = b :: a :: c :: f.stack;
    nil;;

/**
 * PICK ( n ... ni - n ... ni ni )
 * Copy nth item to top of stack
 */
fun forth_pick f=
    let forth_pop f -> n in
    let forth_stack_at f n.int -> v in
    forth_push f v;;

// fun forth_roll f= // TODO

/**
 * NIP ( n1 n2 -- n2 )
 * Drop the first item below the top of stack
 */
fun forth_nip f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = a :: f.stack;
    nil;;

/**
 * TUCK ( n1 n2 -- n1 n2 n1 )
 * Copy the first (top) stack item below the second stack item
 */
fun forth_tuck f=
    let forth_pop f -> a in
    let forth_pop f -> b in
    set f.stack = b :: a :: b :: f.stack;
    nil;;

/**
 * ?DUP ( x -- 0 | x x )
 * Duplicate top of stack if not zero
 */
fun forth_qdup f=
    if f.stack==nil then nil
    else
        let hd f.stack -> v in
        if v.int!=0 then forth_push f v;;

/**
 * DEPTH ( -- count )
 * Count number of items on stack
 */
fun forth_depth f=
    let listlen f.stack -> l in
    forth_push f [int:l];;

/**
 * >R ( x -- ) ( R: -- x )
 * Move top item to ‘return stack” for temporary storage
 */
fun forth_to_r f=
    if f.stack==nil then nil
    else forth_rpush f (forth_pop f);;

/**
 * R> ( -- x ) ( R: x -- )
 * Retrieve item from return stack
 */
fun forth_r_from f=
    if f.rstack==nil then nil
    else forth_push f (forth_rpop f);;

/**
 * R@ ( -- x ) ( R: x -- x )
 * Copy top of return stack onto data stack
 */
fun forth_r_fetch f=
    if f.rstack==nil then nil
    else
        let hd f.rstack -> head in
        set f.stack = head :: f.stack;
    nil;;

/**
 * RDROP ( n --  )
 * Discard top of return stack
 */
fun forth_rdrop f=
    set f.rstack = tl f.rstack;
    nil;;

/**
 * RDEPTH ( -- count )
 * Count number of items on return stack
 */
fun forth_rdepth f=
    let listlen f.rstack -> l in
    forth_push f [int:l];;

/**
 * 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
 * Move two items to return stack
 */
fun forth_two_to_r f=
    let forth_pop f -> a in
    let forth_pop f -> b in (
        forth_rpush f b;
        forth_rpush f a
    );;

/**
 * 2R> ( -- x1 x2 ) ( r: x1 x2 -- )
 * Retrieve two items from return stack
 */
fun forth_two_r_from f=
    let forth_rpop f -> a in
    let forth_rpop f -> b in (
        forth_push f b;
        forth_push f a
    );;

/**
 * 2R@ ( -- x1 x2 ) ( r: x1 x2 -- x1 x2 )
 * Copy two items from return stack to data stack
 */
fun forth_two_r_fetch f=
    let hd f.rstack -> a in
    let hd tl f.rstack -> b in (
        forth_push f b;
        forth_push f a
    );;
